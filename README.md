# Split-Verse: Infinite Horizontal Sharding Framework

**Split-Verse** is a production-ready Java framework for infinite horizontal sharding across MySQL databases. It provides transparent data distribution, automatic partition management, and enforces best practices for distributed systems.

## üéØ Key Features

- **Infinite Horizontal Sharding**: Scale from 1 to N shards seamlessly
- **String-Only IDs**: Enforced external ID generation (UUID, ULID, NanoID)
- **Dual Repository Modes**:
  - **PARTITIONED**: Single table with MySQL native partitions
  - **MULTI_TABLE**: Separate table for each time period (day/hour/month)
- **Automatic Partitioning**: All partitions created upfront during table initialization
- **Hash-Based Routing**: Consistent hashing for even data distribution
- **Builder-Only API**: Enforced encapsulation prevents misuse
- **Compile-Time Safety**: Type-safe entity validation
- **Runtime Enforcement**: Strict validation at startup prevents configuration errors
- **Extensible Partition Types**: Currently supports DATE_BASED with future support for HASH_BASED, RANGE_BASED, LIST_BASED, and COMPOSITE
- **Batch Partition Operations**: Efficient single ALTER TABLE for multiple partition operations
- **Configurable Charset/Collation**: Customizable character encoding (default: utf8mb4/utf8mb4_bin)

## üöÄ Quick Start

### 1. Define Your Entity

```java
@Table(name = "users")
public class User implements ShardingEntity {
    
    @Id(autoGenerated = false)  // Required: String ID, no auto-generation
    @Column(name = "user_id")
    private String id;
    
    @ShardingKey  // Required: LocalDateTime for partitioning
    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    @Column(name = "username")
    private String username;
    
    @Column(name = "email")
    private String email;
    
    // Required interface methods
    @Override
    public String getId() { return id; }
    
    @Override
    public void setId(String id) { this.id = id; }
    
    @Override
    public LocalDateTime getCreatedAt() { return createdAt; }
    
    @Override
    public void setCreatedAt(LocalDateTime createdAt) { 
        this.createdAt = createdAt; 
    }
}
```

### 2. Create Repository

```java
// Single shard configuration
ShardConfig config = ShardConfig.builder()
    .shardId("primary")
    .host("127.0.0.1")
    .port(3306)
    .database("myapp")
    .username("root")
    .password("password")
    .connectionPoolSize(10)
    .enabled(true)
    .build();

// Option 1: Partitioned Mode (Default) - Single table with MySQL partitions
SplitVerseRepository<User> partitionedRepo =
    SplitVerseRepository.<User>builder()
        .withSingleShard(config)
        .withEntityClass(User.class)
        .withPartitionType(PartitionType.DATE_BASED)  // Default: DATE_BASED
        .withPartitionKeyColumn("created_at")         // Default: created_at
        .withRetentionDays(30)                        // Default: 30 days
        .withCharset("utf8mb4")                       // Default: utf8mb4
        .withCollation("utf8mb4_bin")                 // Default: utf8mb4_bin
        .build();

// Option 2: Multi-Table Mode - Separate table for each time period
SplitVerseRepository<User> multiTableRepo =
    SplitVerseRepository.<User>builder()
        .withSingleShard(config)
        .withEntityClass(User.class)
        .withRepositoryMode(RepositoryMode.MULTI_TABLE)
        .withTableGranularity(TableGranularity.DAILY) // DAILY, HOURLY, or MONTHLY
        .withRetentionDays(30)                        // Keep 30 days of tables
        .withCharset("utf8mb4")
        .withCollation("utf8mb4_bin")
        .build();
```

### 3. Use the Repository

```java
// Insert
User user = new User();
user.setId(UUID.randomUUID().toString());  // External ID generation
user.setUsername("john_doe");
user.setEmail("john@example.com");
user.setCreatedAt(LocalDateTime.now());
repository.insert(user);

// Find by ID
User found = repository.findById(user.getId());

// Query by date range
List<User> recentUsers = repository.findAllByDateRange(
    LocalDateTime.now().minusDays(7),
    LocalDateTime.now()
);

// Cursor-based pagination
List<User> batch = repository.findBatchByIdGreaterThan(lastId, 100);
```

## üìã Entity Requirements (Strictly Enforced)

All entities **MUST** meet these requirements. Violations throw `IllegalArgumentException` at startup:

| Requirement | Description | Enforcement |
|------------|-------------|-------------|
| **Implements ShardingEntity** | Must implement the interface | Compile-time (generics) |
| **Exactly ONE @Id** | Single String ID field | Runtime validation |
| **String ID type** | ID must be String, not Long/Integer | Runtime validation |
| **No AUTO_INCREMENT** | `@Id(autoGenerated = false)` required | Runtime validation |
| **Exactly ONE @ShardingKey** | Single LocalDateTime field for partitioning | Runtime validation |
| **LocalDateTime type** | ShardingKey must be LocalDateTime | Runtime validation |

### Example Error Messages

```java
// Multiple @Id annotations
"Entity User has 2 fields annotated with @Id, but only ONE is allowed"

// Wrong ID type
"Entity User @Id field 'id' must be of type String for Split-Verse (found: Long)"

// Auto-generated ID
"Entity User @Id field 'id' must have autoGenerated=false"

// Missing @ShardingKey
"Entity User must have exactly ONE field annotated with @ShardingKey"
```

## üóÇÔ∏è Partition Types

Split-Verse supports different partitioning strategies to optimize data distribution:

### Currently Implemented

| Type | Description | Use Case |
|------|-------------|----------|
| **DATE_BASED** | Partitions by date ranges (daily/monthly/yearly) | Time-series data, logs, events |

### Planned (Throw UnsupportedOperationException)

| Type | Description | Status |
|------|-------------|--------|
| **HASH_BASED** | Hash-based partitioning on numeric fields | Not yet implemented |
| **RANGE_BASED** | Range-based partitioning on numeric values | Not yet implemented |
| **LIST_BASED** | List-based partitioning on categorical values | Not yet implemented |
| **COMPOSITE** | Composite partitioning with multiple strategies | Not yet implemented |

### Configuration Example

```java
// Explicitly specify partition type (default is DATE_BASED)
SplitVerseRepository<User> repository =
    SplitVerseRepository.<User>builder()
        .withSingleShard(config)
        .withEntityClass(User.class)
        .withPartitionType(PartitionType.DATE_BASED)
        .withPartitionKeyColumn("created_at")
        .build();

// Attempting to use unimplemented types throws exception
try {
    repository = SplitVerseRepository.<User>builder()
        .withSingleShard(config)
        .withEntityClass(User.class)
        .withPartitionType(PartitionType.HASH_BASED)  // Throws!
        .build();
} catch (UnsupportedOperationException e) {
    // "Partition type HASH_BASED is not yet implemented"
}
```

## üîß Multi-Shard Configuration

Scale to multiple shards for true horizontal scaling:

```java
// Configure multiple shards
List<ShardConfig> shardConfigs = Arrays.asList(
    ShardConfig.builder()
        .shardId("shard1")
        .host("db1.example.com")
        .database("app_shard1")
        .username("user")
        .password("pass")
        .build(),
    
    ShardConfig.builder()
        .shardId("shard2")
        .host("db2.example.com")
        .database("app_shard2")
        .username("user")
        .password("pass")
        .build(),
    
    ShardConfig.builder()
        .shardId("shard3")
        .host("db3.example.com")
        .database("app_shard3")
        .username("user")
        .password("pass")
        .build()
);

// Create multi-shard repository
SplitVerseRepository<User> repository =
    SplitVerseRepository.<User>builder()
        .withShardConfigs(shardConfigs)
        .withEntityClass(User.class)
        .withRepositoryMode(RepositoryMode.PARTITIONED)  // or MULTI_TABLE
        .withPartitionType(PartitionType.DATE_BASED)
        .withPartitionKeyColumn("created_at")
        .withRetentionDays(30)
        .build();
```

## üèóÔ∏è Architecture

### Builder-Only Access Pattern

Split-Verse enforces a strict builder-only access pattern. Internal repository classes (`GenericPartitionedTableRepository`, `GenericMultiTableRepository`) are package-private and cannot be accessed directly:

```java
// ‚úÖ CORRECT - Only way to create repositories
SplitVerseRepository<User> repo = SplitVerseRepository.<User>builder()...

// ‚ùå WRONG - Won't compile (package-private)
GenericPartitionedTableRepository<User> repo = ...  // Compile error!
```

### Sharding Strategy

- **Hash-Based Routing**: Uses consistent hashing on String IDs
- **Even Distribution**: Automatically balances data across shards
- **Partition Pruning**: Time-based queries only scan relevant partitions
- **Transparent Failover**: Continues operating if some shards fail

### Repository Modes

Split-Verse supports two repository modes for different use cases:

#### 1. PARTITIONED Mode (Default)
Single table with MySQL native partitions:
- **RANGE COLUMNS partitioning** for date-based partitioning
- **All partitions created upfront** during table initialization
- **Retention period partitions**: Creates `(retention_days √ó 2) + 1` partitions
- **Composite primary key**: `(id, created_at)` required for MySQL partition compatibility
- **Batch partition operations**: Adds/drops multiple partitions in single ALTER TABLE
- **Best for**: Standard time-series data, queries spanning multiple days

#### 2. MULTI_TABLE Mode
Separate table for each time period:
- **Table per period**: Daily, hourly, or monthly granularity
- **Simple primary key**: Only `id` field required
- **Dynamic table creation**: Tables created on-demand or upfront
- **Easy maintenance**: Simple DROP TABLE for old data
- **Best for**: Complete day isolation, varied schemas over time, easy archival

## üìä Performance Features

- **Connection Pooling**: HikariCP for optimal performance
- **Parallel Queries**: Fan-out queries across shards in parallel
- **Batch Operations**: Efficient bulk inserts and updates
- **Cursor Pagination**: Efficient traversal of large datasets
- **Partition Pruning**: Date ranges only query relevant partitions

## üîç API Reference

### Core Operations

| Method | Description |
|--------|-------------|
| `insert(T entity)` | Insert single entity |
| `insertMultiple(List<T> entities)` | Batch insert |
| `findById(String id)` | Find by primary key |
| `findAllByDateRange(start, end)` | Query by date range |
| `updateById(String id, T entity)` | Update entity |
| `findBatchByIdGreaterThan(String cursor, int size)` | Cursor pagination |
| `shutdown()` | Clean shutdown |

### ShardingEntity Interface

```java
public interface ShardingEntity {
    String getId();
    void setId(String id);
    LocalDateTime getCreatedAt();
    void setCreatedAt(LocalDateTime createdAt);
}
```

### Configuration Options

| Option | Description | Default |
|--------|-------------|---------|
| `withRepositoryMode(mode)` | Repository storage mode (PARTITIONED or MULTI_TABLE) | `PARTITIONED` |
| `withPartitionType(type)` | Partition strategy (DATE_BASED only currently) | `DATE_BASED` |
| `withPartitionKeyColumn(column)` | Column name for partitioning (partitioned mode) | `created_at` |
| `withTableGranularity(granularity)` | Table creation period (DAILY, HOURLY, MONTHLY) for multi-table mode | `DAILY` |
| `withRetentionDays(days)` | Days to retain data/tables | `30` |
| `withCharset(charset)` | MySQL character set | `utf8mb4` |
| `withCollation(collation)` | MySQL collation | `utf8mb4_bin` |
| `withConnectionPoolSize(size)` | HikariCP pool size per shard | `10` |

## üß™ Testing

The framework includes comprehensive test suites:

```java
// Run basic operations test
mvn test -Dtest=SplitVerseBasicOperationsTest

// Run multi-shard test
mvn test -Dtest=SplitVerseMultiShardTest

// Run enforcement tests
mvn test -Dtest=AnnotationEnforcementTest
```

### Test Coverage

- ‚úÖ Basic CRUD operations
- ‚úÖ Multi-shard distribution
- ‚úÖ Date range queries with partition pruning
- ‚úÖ Cursor-based pagination
- ‚úÖ SQL injection prevention
- ‚úÖ Null handling
- ‚úÖ Entity validation enforcement
- ‚úÖ Concurrent operations
- ‚úÖ Shard failure handling

## üìù ID Generation Examples

Since AUTO_INCREMENT is not allowed, use external ID generators:

```java
// UUID (random)
entity.setId(UUID.randomUUID().toString());

// ULID (sortable, timestamp-based)
entity.setId(UlidCreator.getUlid().toString());

// NanoID (URL-safe, compact)
entity.setId(NanoIdUtils.randomNanoId());

// Custom format
entity.setId(String.format("user_%d_%s", 
    System.currentTimeMillis(), 
    RandomStringUtils.randomAlphanumeric(8)));

// Snowflake ID (distributed sequence)
entity.setId(String.valueOf(snowflake.nextId()));
```

## üîß Important: Partition Initialization

Split-Verse creates ALL partitions upfront during table creation to avoid MySQL partition ordering issues:

### How It Works:
1. **Table Creation**: Creates table with all partitions in a single `CREATE TABLE` statement
2. **Partition Range**: Creates `(retention_days √ó 2) + 1` partitions:
   - Past: `retention_days` partitions before today
   - Present: Today's partition
   - Future: `retention_days` partitions after today
3. **No Incremental Creation**: Avoids "VALUES LESS THAN must be strictly increasing" errors

### Example with 7-day retention:
```sql
CREATE TABLE users (...) ENGINE=InnoDB
/*!50500 PARTITION BY RANGE COLUMNS(created_at)
(PARTITION p20250907 VALUES LESS THAN ('2025-09-08') ENGINE = InnoDB,
 PARTITION p20250908 VALUES LESS THAN ('2025-09-09') ENGINE = InnoDB,
 ... -- 15 total partitions (7 past + 1 today + 7 future)
 PARTITION p20250921 VALUES LESS THAN ('2025-09-22') ENGINE = InnoDB) */
```

### Daily Maintenance:
- **Drops**: Old partitions beyond retention period (single ALTER TABLE)
- **Creates**: New future partitions as needed (single ALTER TABLE)
- **Automatic**: Runs at 4 AM by default (configurable)

## ‚öôÔ∏è Configuration Options

### ShardConfig

| Option | Description | Default |
|--------|-------------|---------|
| `shardId` | Unique shard identifier | Required |
| `host` | Database host | Required |
| `port` | Database port | 3306 |
| `database` | Database name | Required |
| `username` | DB username | Required |
| `password` | DB password | Required |
| `connectionPoolSize` | HikariCP pool size | 10 |
| `maxLifetime` | Connection max lifetime (ms) | 1800000 |
| `enabled` | Whether shard is active | true |

## üö® Important Notes

1. **String IDs Only**: No support for numeric IDs or AUTO_INCREMENT
2. **External ID Generation**: You must generate IDs before insertion
3. **Composite Primary Key**: Tables use `(id, created_at)` for partitioning
4. **Builder-Only Access**: Cannot instantiate repositories directly
5. **Startup Validation**: Invalid entities cause startup failure
6. **MySQL 5.7+**: Requires MySQL 5.7 or higher for native partitioning

## üìà Production Deployment

### Recommended Settings

```java
ShardConfig productionConfig = ShardConfig.builder()
    .shardId("prod-shard-1")
    .host("prod-db.example.com")
    .port(3306)
    .database("production")
    .username("app_user")
    .password(System.getenv("DB_PASSWORD"))  // Use environment variables
    .connectionPoolSize(50)  // Adjust based on load
    .maxLifetime(600000)     // 10 minutes
    .connectionTimeout(5000) // 5 seconds
    .enabled(true)
    .build();
```

### Monitoring

Split-Verse provides detailed logging for monitoring:
- Connection pool metrics
- Query performance statistics
- Shard distribution metrics
- Partition management activities
- Error rates and recovery

### Scaling Strategy

1. **Start with single shard** for simplicity
2. **Monitor data growth** and query patterns
3. **Add shards** when needed (no downtime)
4. **Rebalance** using built-in migration tools
5. **Monitor distribution** for hot spots

## üìö Examples

See the `/src/main/java/com/telcobright/splitverse/examples/` directory for:
- `TelecomSubscriberExample.java` - Telecom use case
- `SimpleSplitVerseTest.java` - Basic operations
- `SplitVerseMultiShardTest.java` - Multi-shard scenarios

## ü§ù Contributing

Contributions are welcome! Please ensure:
1. All tests pass
2. Entity validation rules are maintained
3. Builder-only pattern is preserved
4. Documentation is updated

## üìÑ License

This project is proprietary software. All rights reserved.

## üÜò Support

For issues or questions:
- Check the [Entity Requirements](ENTITY_REQUIREMENTS.md)
- Review test cases for examples
- Open an issue on GitHub

---

**Split-Verse**: Built for scale, designed for simplicity, enforced for correctness.