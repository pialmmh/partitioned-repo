# Split-Verse: Infinite Horizontal Sharding Framework

**Split-Verse** is a production-ready Java framework for infinite horizontal sharding across MySQL databases. It provides transparent data distribution, automatic partition management, and enforces best practices for distributed systems.

## üéØ Key Features

- **Infinite Horizontal Sharding**: Scale from 1 to N shards seamlessly
- **String-Only IDs**: Enforced external ID generation (UUID, ULID, NanoID)
- **Automatic Partitioning**: Time-based partitions with retention management
- **Hash-Based Routing**: Consistent hashing for even data distribution
- **Builder-Only API**: Enforced encapsulation prevents misuse
- **Compile-Time Safety**: Type-safe entity validation
- **Runtime Enforcement**: Strict validation at startup prevents configuration errors

## üöÄ Quick Start

### 1. Define Your Entity

```java
@Table(name = "users")
public class User implements ShardingEntity {
    
    @Id(autoGenerated = false)  // Required: String ID, no auto-generation
    @Column(name = "user_id")
    private String id;
    
    @ShardingKey  // Required: LocalDateTime for partitioning
    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    @Column(name = "username")
    private String username;
    
    @Column(name = "email")
    private String email;
    
    // Required interface methods
    @Override
    public String getId() { return id; }
    
    @Override
    public void setId(String id) { this.id = id; }
    
    @Override
    public LocalDateTime getCreatedAt() { return createdAt; }
    
    @Override
    public void setCreatedAt(LocalDateTime createdAt) { 
        this.createdAt = createdAt; 
    }
}
```

### 2. Create Repository

```java
// Single shard configuration
ShardConfig config = ShardConfig.builder()
    .shardId("primary")
    .host("127.0.0.1")
    .port(3306)
    .database("myapp")
    .username("root")
    .password("password")
    .connectionPoolSize(10)
    .enabled(true)
    .build();

// Create Split-Verse repository (the ONLY way to access the framework)
SplitVerseRepository<User> repository = 
    SplitVerseRepository.<User>builder()
        .withSingleShard(config)
        .withEntityClass(User.class)
        .build();
```

### 3. Use the Repository

```java
// Insert
User user = new User();
user.setId(UUID.randomUUID().toString());  // External ID generation
user.setUsername("john_doe");
user.setEmail("john@example.com");
user.setCreatedAt(LocalDateTime.now());
repository.insert(user);

// Find by ID
User found = repository.findById(user.getId());

// Query by date range
List<User> recentUsers = repository.findAllByDateRange(
    LocalDateTime.now().minusDays(7),
    LocalDateTime.now()
);

// Cursor-based pagination
List<User> batch = repository.findBatchByIdGreaterThan(lastId, 100);
```

## üìã Entity Requirements (Strictly Enforced)

All entities **MUST** meet these requirements. Violations throw `IllegalArgumentException` at startup:

| Requirement | Description | Enforcement |
|------------|-------------|-------------|
| **Implements ShardingEntity** | Must implement the interface | Compile-time (generics) |
| **Exactly ONE @Id** | Single String ID field | Runtime validation |
| **String ID type** | ID must be String, not Long/Integer | Runtime validation |
| **No AUTO_INCREMENT** | `@Id(autoGenerated = false)` required | Runtime validation |
| **Exactly ONE @ShardingKey** | Single LocalDateTime field for partitioning | Runtime validation |
| **LocalDateTime type** | ShardingKey must be LocalDateTime | Runtime validation |

### Example Error Messages

```java
// Multiple @Id annotations
"Entity User has 2 fields annotated with @Id, but only ONE is allowed"

// Wrong ID type
"Entity User @Id field 'id' must be of type String for Split-Verse (found: Long)"

// Auto-generated ID
"Entity User @Id field 'id' must have autoGenerated=false"

// Missing @ShardingKey
"Entity User must have exactly ONE field annotated with @ShardingKey"
```

## üîß Multi-Shard Configuration

Scale to multiple shards for true horizontal scaling:

```java
// Configure multiple shards
List<ShardConfig> shardConfigs = Arrays.asList(
    ShardConfig.builder()
        .shardId("shard1")
        .host("db1.example.com")
        .database("app_shard1")
        .username("user")
        .password("pass")
        .build(),
    
    ShardConfig.builder()
        .shardId("shard2")
        .host("db2.example.com")
        .database("app_shard2")
        .username("user")
        .password("pass")
        .build(),
    
    ShardConfig.builder()
        .shardId("shard3")
        .host("db3.example.com")
        .database("app_shard3")
        .username("user")
        .password("pass")
        .build()
);

// Create multi-shard repository
SplitVerseRepository<User> repository = 
    SplitVerseRepository.<User>builder()
        .withShardConfigs(shardConfigs)
        .withEntityClass(User.class)
        .build();
```

## üèóÔ∏è Architecture

### Builder-Only Access Pattern

Split-Verse enforces a strict builder-only access pattern. Internal repository classes (`GenericPartitionedTableRepository`, `GenericMultiTableRepository`) are package-private and cannot be accessed directly:

```java
// ‚úÖ CORRECT - Only way to create repositories
SplitVerseRepository<User> repo = SplitVerseRepository.<User>builder()...

// ‚ùå WRONG - Won't compile (package-private)
GenericPartitionedTableRepository<User> repo = ...  // Compile error!
```

### Sharding Strategy

- **Hash-Based Routing**: Uses consistent hashing on String IDs
- **Even Distribution**: Automatically balances data across shards
- **Partition Pruning**: Time-based queries only scan relevant partitions
- **Transparent Failover**: Continues operating if some shards fail

### Partitioning

Each shard uses MySQL native partitioning:
- **RANGE partitioning** by `TO_DAYS(created_at)`
- **Daily partitions** automatically created
- **Retention management** with configurable period
- **Composite primary key**: `(id, created_at)` for partition compatibility

## üìä Performance Features

- **Connection Pooling**: HikariCP for optimal performance
- **Parallel Queries**: Fan-out queries across shards in parallel
- **Batch Operations**: Efficient bulk inserts and updates
- **Cursor Pagination**: Efficient traversal of large datasets
- **Partition Pruning**: Date ranges only query relevant partitions

## üîç API Reference

### Core Operations

| Method | Description |
|--------|-------------|
| `insert(T entity)` | Insert single entity |
| `insertMultiple(List<T> entities)` | Batch insert |
| `findById(String id)` | Find by primary key |
| `findAllByDateRange(start, end)` | Query by date range |
| `updateById(String id, T entity)` | Update entity |
| `findBatchByIdGreaterThan(String cursor, int size)` | Cursor pagination |
| `shutdown()` | Clean shutdown |

### ShardingEntity Interface

```java
public interface ShardingEntity {
    String getId();
    void setId(String id);
    LocalDateTime getCreatedAt();
    void setCreatedAt(LocalDateTime createdAt);
}
```

## üß™ Testing

The framework includes comprehensive test suites:

```java
// Run basic operations test
mvn test -Dtest=SplitVerseBasicOperationsTest

// Run multi-shard test
mvn test -Dtest=SplitVerseMultiShardTest

// Run enforcement tests
mvn test -Dtest=AnnotationEnforcementTest
```

### Test Coverage

- ‚úÖ Basic CRUD operations
- ‚úÖ Multi-shard distribution
- ‚úÖ Date range queries with partition pruning
- ‚úÖ Cursor-based pagination
- ‚úÖ SQL injection prevention
- ‚úÖ Null handling
- ‚úÖ Entity validation enforcement
- ‚úÖ Concurrent operations
- ‚úÖ Shard failure handling

## üìù ID Generation Examples

Since AUTO_INCREMENT is not allowed, use external ID generators:

```java
// UUID (random)
entity.setId(UUID.randomUUID().toString());

// ULID (sortable, timestamp-based)
entity.setId(UlidCreator.getUlid().toString());

// NanoID (URL-safe, compact)
entity.setId(NanoIdUtils.randomNanoId());

// Custom format
entity.setId(String.format("user_%d_%s", 
    System.currentTimeMillis(), 
    RandomStringUtils.randomAlphanumeric(8)));

// Snowflake ID (distributed sequence)
entity.setId(String.valueOf(snowflake.nextId()));
```

## ‚öôÔ∏è Configuration Options

### ShardConfig

| Option | Description | Default |
|--------|-------------|---------|
| `shardId` | Unique shard identifier | Required |
| `host` | Database host | Required |
| `port` | Database port | 3306 |
| `database` | Database name | Required |
| `username` | DB username | Required |
| `password` | DB password | Required |
| `connectionPoolSize` | HikariCP pool size | 10 |
| `maxLifetime` | Connection max lifetime (ms) | 1800000 |
| `enabled` | Whether shard is active | true |

## üö® Important Notes

1. **String IDs Only**: No support for numeric IDs or AUTO_INCREMENT
2. **External ID Generation**: You must generate IDs before insertion
3. **Composite Primary Key**: Tables use `(id, created_at)` for partitioning
4. **Builder-Only Access**: Cannot instantiate repositories directly
5. **Startup Validation**: Invalid entities cause startup failure
6. **MySQL 5.7+**: Requires MySQL 5.7 or higher for native partitioning

## üìà Production Deployment

### Recommended Settings

```java
ShardConfig productionConfig = ShardConfig.builder()
    .shardId("prod-shard-1")
    .host("prod-db.example.com")
    .port(3306)
    .database("production")
    .username("app_user")
    .password(System.getenv("DB_PASSWORD"))  // Use environment variables
    .connectionPoolSize(50)  // Adjust based on load
    .maxLifetime(600000)     // 10 minutes
    .connectionTimeout(5000) // 5 seconds
    .enabled(true)
    .build();
```

### Monitoring

Split-Verse provides detailed logging for monitoring:
- Connection pool metrics
- Query performance statistics
- Shard distribution metrics
- Partition management activities
- Error rates and recovery

### Scaling Strategy

1. **Start with single shard** for simplicity
2. **Monitor data growth** and query patterns
3. **Add shards** when needed (no downtime)
4. **Rebalance** using built-in migration tools
5. **Monitor distribution** for hot spots

## üìö Examples

See the `/src/main/java/com/telcobright/splitverse/examples/` directory for:
- `TelecomSubscriberExample.java` - Telecom use case
- `SimpleSplitVerseTest.java` - Basic operations
- `SplitVerseMultiShardTest.java` - Multi-shard scenarios

## ü§ù Contributing

Contributions are welcome! Please ensure:
1. All tests pass
2. Entity validation rules are maintained
3. Builder-only pattern is preserved
4. Documentation is updated

## üìÑ License

This project is proprietary software. All rights reserved.

## üÜò Support

For issues or questions:
- Check the [Entity Requirements](ENTITY_REQUIREMENTS.md)
- Review test cases for examples
- Open an issue on GitHub

---

**Split-Verse**: Built for scale, designed for simplicity, enforced for correctness.