# SimpleSequentialRepository User Guide

## Overview

SimpleSequentialRepository is a specialized repository implementation designed for managing entities with sequential numeric IDs while leveraging the split-verse library's partitioning capabilities. It provides automatic ID generation, state persistence, and seamless integration with date-based partitioned tables.

### Key Features
- **Sequential ID Management**: Auto-generates sequential numeric IDs (1, 2, 3...)
- **State Persistence**: Maintains ID counter across application restarts
- **Thread-Safe Operations**: All ID operations are thread-safe for concurrent access
- **ID Wraparound**: Optional wraparound when maximum ID is reached
- **Client ID Support**: Accept client-provided IDs while maintaining sequence
- **Range Operations**: Reserve and allocate ID ranges for bulk operations
- **Partition Integration**: Works seamlessly with date-based partitioned tables

### Architecture Note
While split-verse requires String IDs internally, SimpleSequentialRepository handles int/long IDs by converting them to String format (`String.valueOf(id)`). This allows numeric sequence logic while maintaining compatibility with the underlying framework.

## Getting Started

### Basic Setup

```java
import com.telcobright.core.repository.SimpleSequentialRepository;

// Create repository with auto-generated IDs
SimpleSequentialRepository<LogEntry> repository =
    SimpleSequentialRepository.builder(LogEntry.class)
        .connection("127.0.0.1", 3306, "mydb", "user", "password")
        .tableName("logs")
        .maxId(1000000)  // Maximum ID value
        .retentionDays(30)  // Keep 30 days of data
        .build();
```

### Entity Requirements

Your entity must:
1. Implement `ShardingEntity<LocalDateTime>`
2. Have a String ID field annotated with `@Id(autoGenerated = false)`
3. Have a LocalDateTime field as the sharding key

```java
@Table(name = "logs")
public class LogEntry implements ShardingEntity<LocalDateTime> {

    @Id(autoGenerated = false)  // Important: We generate IDs externally
    @Column(name = "id")
    private String id;

    @ShardingKey
    @Column(name = "timestamp")
    private LocalDateTime timestamp;

    @Column(name = "message")
    private String message;

    // Required interface methods
    @Override
    public String getId() { return id; }

    @Override
    public void setId(String id) { this.id = id; }

    @Override
    public LocalDateTime getPartitionColValue() { return timestamp; }

    @Override
    public void setPartitionColValue(LocalDateTime value) {
        this.timestamp = value;
    }
}
```

## Core APIs

### ID Generation

#### Get Single ID
```java
// Get next sequential ID
long nextId = repository.getNextId();
// Returns: 1, then 2, then 3, etc.
```

#### Get Multiple IDs
```java
// Get 100 sequential IDs at once
List<Long> ids = repository.getNextN(100);
// Returns: [1, 2, 3, ..., 100]
```

#### Check Current ID
```java
// Get current ID without incrementing
long currentId = repository.getCurrentId();
```

### Insertion Operations

#### Auto-ID Insertion
```java
// Single entity with auto-generated ID
LogEntry log = new LogEntry();
log.setTimestamp(LocalDateTime.now());
log.setMessage("Application started");

long assignedId = repository.insertWithAutoId(log);
System.out.println("Inserted with ID: " + assignedId);
```

#### Bulk Auto-ID Insertion
```java
// Multiple entities with auto-generated IDs
List<LogEntry> logs = createLogs(100);
List<Long> assignedIds = repository.insertMultipleWithAutoId(logs);
// Each log gets sequential ID: 1, 2, 3, ..., 100
```

### Client-Provided IDs

Enable client IDs in the builder:
```java
SimpleSequentialRepository<LogEntry> repository =
    SimpleSequentialRepository.builder(LogEntry.class)
        .connection(host, port, db, user, pass)
        .tableName("logs")
        .maxId(1000000)
        .allowClientIds(true)  // Enable client IDs
        .build();
```

Insert with client ID:
```java
// Single entity with client ID
LogEntry log = new LogEntry();
log.setTimestamp(LocalDateTime.now());
log.setMessage("Client message");

repository.insertWithClientId(log, 5000L);
// Internal counter advances to 5000 if it was less
```

Bulk insert with client IDs:
```java
// Multiple entities with client IDs
List<LogEntry> entities = Arrays.asList(log1, log2, log3);
List<Long> clientIds = Arrays.asList(5001L, 5002L, 5003L);

repository.insertMultipleWithClientIds(entities, clientIds);
```

### Range Operations

#### Reserve ID Range
```java
// Reserve a block of IDs for distributed processing
SimpleSequentialRepository.IdRange range = repository.reserveIdRange(1000);
System.out.println("Reserved IDs: " + range.getStartId() + " to " + range.getEndId());
// Use these IDs in another system or process
```

#### Insert with Reserved Range
```java
// Reserve range
SimpleSequentialRepository.IdRange range = repository.reserveIdRange(100);

// Create entities
List<LogEntry> logs = createLogs(100);

// Insert with reserved range
repository.insertWithIdRange(logs, range);
// Each log gets ID from the reserved range
```

#### Insert with Custom Range
```java
// Insert with specific ID range (must have allowClientIds enabled)
List<LogEntry> logs = createLogs(50);
repository.insertWithinIdRange(logs, 1000L, 1049L);
// Logs get IDs 1000-1049
```

### State Management

#### Reset ID Counter
```java
// Reset to specific value
repository.resetId(1000);
// Next ID will be 1001
```

#### Check Wraparound Configuration
```java
boolean wraps = repository.isWrapAroundEnabled();
long maxId = repository.getMaxId();
```

## Advanced Configuration

### Complete Builder Options

```java
SimpleSequentialRepository<LogEntry> repository =
    SimpleSequentialRepository.builder(LogEntry.class)
        // Database connection
        .connection("127.0.0.1", 3306, "mydb", "user", "password")

        // Or use explicit connection parameters
        .host("127.0.0.1")
        .port(3306)
        .database("mydb")
        .username("user")
        .password("password")

        // Table configuration
        .tableName("logs")
        .stateTableName("log_id_state")  // Custom state table name

        // ID configuration
        .maxId(10000000)         // Maximum ID value (default: Long.MAX_VALUE)
        .wrapAround(true)        // Enable wraparound at max (default: false)
        .allowClientIds(true)    // Allow client-provided IDs (default: false)

        // Partition configuration
        .retentionDays(30)       // Days to retain data (default: 30)
        .partitionRange(PartitionRange.DAILY)  // Partition size
        .autoMaintenance(true)   // Auto-manage partitions
        .maintenanceTime(LocalTime.of(2, 0))  // Maintenance at 2 AM

        // Connection pool
        .maxPoolSize(20)         // Max connections (default: 10)

        .build();
```

### Wraparound Behavior

Without wraparound (default):
```java
SimpleSequentialRepository<LogEntry> repository =
    SimpleSequentialRepository.builder(LogEntry.class)
        .connection(host, port, db, user, pass)
        .tableName("logs")
        .maxId(1000)
        .wrapAround(false)  // Throw exception at max
        .build();

// When ID 1000 is reached:
repository.getNextId();  // Throws IllegalStateException
```

With wraparound:
```java
SimpleSequentialRepository<LogEntry> repository =
    SimpleSequentialRepository.builder(LogEntry.class)
        .connection(host, port, db, user, pass)
        .tableName("logs")
        .maxId(1000)
        .wrapAround(true)  // Start over at 1
        .build();

// When ID 1000 is reached:
long id = repository.getNextId();  // Returns 1 (wrapped)
```

## Usage Patterns

### Pattern 1: Simple Log Storage
```java
public class LogService {
    private final SimpleSequentialRepository<LogEntry> repository;

    public LogService() {
        this.repository = SimpleSequentialRepository.builder(LogEntry.class)
            .connection("127.0.0.1", 3306, "logs_db", "user", "pass")
            .tableName("application_logs")
            .maxId(Long.MAX_VALUE)
            .retentionDays(90)
            .build();
    }

    public void log(String level, String message) {
        LogEntry entry = new LogEntry();
        entry.setTimestamp(LocalDateTime.now());
        entry.setLevel(level);
        entry.setMessage(message);

        try {
            long id = repository.insertWithAutoId(entry);
            System.out.println("Logged with ID: " + id);
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```

### Pattern 2: Batch Processing with Ranges
```java
public class BatchProcessor {
    private final SimpleSequentialRepository<LogEntry> repository;

    public void processBatch(List<String> messages) throws SQLException {
        // Reserve IDs for entire batch
        IdRange range = repository.reserveIdRange(messages.size());

        // Process in parallel knowing IDs are reserved
        List<LogEntry> logs = messages.parallelStream()
            .map(msg -> {
                LogEntry log = new LogEntry();
                log.setTimestamp(LocalDateTime.now());
                log.setMessage(msg);
                return log;
            })
            .collect(Collectors.toList());

        // Insert with reserved range
        repository.insertWithIdRange(logs, range);
    }
}
```

### Pattern 3: Distributed ID Allocation
```java
public class DistributedWorker {
    private final SimpleSequentialRepository<LogEntry> repository;
    private IdRange myRange;
    private long currentId;

    public void allocateWorkRange() {
        // Each worker reserves a range
        myRange = repository.reserveIdRange(10000);
        currentId = myRange.getStartId();
        System.out.println("Worker allocated IDs: " +
            myRange.getStartId() + " - " + myRange.getEndId());
    }

    public long getNextWorkerId() {
        if (currentId > myRange.getEndId()) {
            allocateWorkRange();  // Get new range
        }
        return currentId++;
    }
}
```

### Pattern 4: Migration from External System
```java
public class DataMigration {
    private final SimpleSequentialRepository<LogEntry> repository;

    public DataMigration() {
        this.repository = SimpleSequentialRepository.builder(LogEntry.class)
            .connection(host, port, db, user, pass)
            .tableName("logs")
            .allowClientIds(true)  // Accept external IDs
            .maxId(Long.MAX_VALUE)
            .build();
    }

    public void migrateFromLegacy(List<LegacyLog> legacyLogs) throws SQLException {
        List<LogEntry> logs = new ArrayList<>();
        List<Long> ids = new ArrayList<>();

        for (LegacyLog legacy : legacyLogs) {
            LogEntry log = convertToLogEntry(legacy);
            logs.add(log);
            ids.add(legacy.getId());
        }

        // Insert preserving original IDs
        repository.insertMultipleWithClientIds(logs, ids);

        // Repository automatically advances counter past highest ID
    }
}
```

## Iteration and Retrieval

### Simple Batch Retrieval
```java
// Retrieve records by ID range - simple and efficient
// startId=1000, batchSize=100 returns IDs 1000-1099
List<LogEntry> batch = repository.findByIdRange(1000, 100);

// Iterate through all logs sequentially
long currentId = 0;
int batchSize = 1000;

while (true) {
    List<LogEntry> batch = repository.findByIdRange(currentId, batchSize);

    if (batch.isEmpty()) {
        break;  // No more records
    }

    // Process batch
    processBatch(batch);

    // Move to next batch
    currentId += batchSize;
}
```

### Date Range Queries
```java
// Find logs within date range
LocalDateTime startDate = LocalDateTime.now().minusDays(7);
LocalDateTime endDate = LocalDateTime.now();

List<LogEntry> weekLogs = repository.findAllByPartitionRange(startDate, endDate);
```

### Find by ID
```java
// Retrieve specific log by ID
LogEntry log = repository.findById("12345");
if (log != null) {
    System.out.println("Found: " + log.getMessage());
}
```

## State Persistence

The repository automatically persists its state to a MySQL table to survive restarts:

```sql
-- Automatically created state table
CREATE TABLE log_id_state (
    id INT PRIMARY KEY,
    current_id BIGINT NOT NULL,
    max_id BIGINT NOT NULL,
    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

State is persisted:
- Every 100 ID increments (configurable via PERSIST_THRESHOLD)
- On repository shutdown
- When client provides higher ID
- After ID reset

### Graceful Shutdown
```java
// Always shutdown to ensure state is persisted
Runtime.getRuntime().addShutdownHook(new Thread(() -> {
    repository.shutdown();
}));
```

## Performance Considerations

### Thread Safety
- All ID operations use ReentrantLock for thread safety
- Safe for concurrent access from multiple threads
- No risk of duplicate IDs

### Bulk Operations
- Use `getNextN()` for allocating multiple IDs at once
- Use `insertMultiple*` methods for batch inserts
- Reserve ranges for distributed processing

### Partition Pruning
- Date-based queries automatically benefit from partition pruning
- Sequential ID iteration scans partitions in order
- Old partitions auto-dropped based on retention period

## Error Handling

### Common Exceptions

```java
try {
    long id = repository.getNextId();
} catch (IllegalStateException e) {
    // Thrown when max ID reached without wraparound
    System.err.println("Maximum ID reached: " + e.getMessage());
}

try {
    repository.insertWithClientId(log, clientId);
} catch (IllegalStateException e) {
    // Thrown when client IDs not enabled
    System.err.println("Client IDs not allowed: " + e.getMessage());
} catch (IllegalArgumentException e) {
    // Thrown for invalid ID values
    System.err.println("Invalid ID: " + e.getMessage());
} catch (SQLException e) {
    // Database errors
    System.err.println("Database error: " + e.getMessage());
}
```

## Best Practices

1. **Choose Appropriate Max ID**: Set based on expected volume to avoid wraparound issues
2. **Enable Client IDs Only When Needed**: Keep disabled for pure sequential generation
3. **Use Batch Operations**: Leverage bulk methods for better performance
4. **Handle Wraparound Appropriately**: Decide if wraparound makes sense for your use case
5. **Shutdown Gracefully**: Always call shutdown() to persist final state
6. **Reserve Ranges for Distributed Systems**: Use range reservation for multi-process scenarios
7. **Monitor ID Usage**: Track current ID to predict when max will be reached

## Migration Guide

### From Flat Table
```java
// 1. Create new repository with client IDs enabled
SimpleSequentialRepository<LogEntry> newRepo =
    SimpleSequentialRepository.builder(LogEntry.class)
        .connection(host, port, db, user, pass)
        .tableName("logs_partitioned")
        .allowClientIds(true)
        .maxId(Long.MAX_VALUE)
        .build();

// 2. Read from old table
List<LogEntry> oldLogs = readFromOldTable();

// 3. Insert preserving IDs
for (LogEntry log : oldLogs) {
    long oldId = Long.parseLong(log.getId());
    newRepo.insertWithClientId(log, oldId);
}

// 4. Reset to continue from highest ID
long maxOldId = findMaxId(oldLogs);
newRepo.resetId(maxOldId);
```

### From UUID-based System
```java
// For systems using UUIDs, use SimpleSequentialRepository
// for new data while keeping old UUIDs

public class HybridLogService {
    private final SimpleSequentialRepository<LogEntry> seqRepo;
    private final GenericPartitionedTableRepository<LogEntry> uuidRepo;

    public void insertNewLog(LogEntry log) throws SQLException {
        // New logs get sequential IDs
        seqRepo.insertWithAutoId(log);
    }

    public LogEntry findById(String id) {
        // Try parsing as number first (new logs)
        try {
            Long.parseLong(id);
            return seqRepo.findById(id);
        } catch (NumberFormatException e) {
            // Fall back to UUID repository for old logs
            return uuidRepo.findById(id);
        }
    }
}
```

## Limitations

1. **String ID Storage**: IDs are stored as strings in the database (split-verse requirement)
2. **LocalDateTime Only**: Currently requires LocalDateTime as partition key
3. **Single Sequence**: One sequence per repository instance
4. **No Gaps Guarantee**: IDs may have gaps if transactions rollback

## Troubleshooting

### Issue: "Maximum ID reached"
**Solution**: Enable wraparound or increase maxId
```java
.maxId(Long.MAX_VALUE)
.wrapAround(true)
```

### Issue: "Client IDs not allowed"
**Solution**: Enable in builder
```java
.allowClientIds(true)
```

### Issue: State not persisting
**Solution**: Ensure shutdown() is called
```java
repository.shutdown();
```

### Issue: Duplicate key errors
**Solution**: Check that entity has `@Id(autoGenerated = false)`

## Complete Example

```java
import com.telcobright.core.repository.SimpleSequentialRepository;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.sql.SQLException;
import java.util.*;

public class LoggingSystem {
    private final SimpleSequentialRepository<LogEntry> repository;

    public LoggingSystem() {
        this.repository = SimpleSequentialRepository.builder(LogEntry.class)
            .connection("127.0.0.1", 3306, "logs_db", "app", "password")
            .tableName("application_logs")
            .maxId(100000000L)  // 100 million max
            .wrapAround(false)  // Don't wrap, throw error
            .allowClientIds(false)  // Only auto-generated
            .retentionDays(90)  // Keep 3 months
            .partitionRange(PartitionRange.DAILY)
            .autoMaintenance(true)
            .maintenanceTime(LocalTime.of(3, 0))  // 3 AM maintenance
            .maxPoolSize(20)
            .build();

        // Ensure cleanup on shutdown
        Runtime.getRuntime().addShutdownHook(new Thread(repository::shutdown));
    }

    public void log(String level, String message) throws SQLException {
        LogEntry entry = new LogEntry();
        entry.setTimestamp(LocalDateTime.now());
        entry.setLevel(level);
        entry.setMessage(message);
        entry.setThreadName(Thread.currentThread().getName());

        long id = repository.insertWithAutoId(entry);
        System.out.printf("Logged with ID %d: [%s] %s%n", id, level, message);
    }

    public void logBatch(List<String> messages) throws SQLException {
        List<LogEntry> entries = new ArrayList<>();
        LocalDateTime now = LocalDateTime.now();

        for (String message : messages) {
            LogEntry entry = new LogEntry();
            entry.setTimestamp(now);
            entry.setLevel("INFO");
            entry.setMessage(message);
            entries.add(entry);
        }

        List<Long> ids = repository.insertMultipleWithAutoId(entries);
        System.out.printf("Logged %d entries with IDs %d-%d%n",
            ids.size(), ids.get(0), ids.get(ids.size()-1));
    }

    public List<LogEntry> getRecentLogs(int days) {
        LocalDateTime start = LocalDateTime.now().minusDays(days);
        LocalDateTime end = LocalDateTime.now();
        return repository.findAllByPartitionRange(start, end);
    }

    public void processAllLogs() {
        String cursor = null;
        int processed = 0;

        while (true) {
            List<LogEntry> batch = repository.findBatchByIdGreaterThan(cursor, 1000);
            if (batch.isEmpty()) break;

            // Process batch
            batch.forEach(this::processLog);
            processed += batch.size();

            cursor = batch.get(batch.size() - 1).getId();
        }

        System.out.printf("Processed %d total logs%n", processed);
    }

    private void processLog(LogEntry log) {
        // Processing logic here
    }

    public static void main(String[] args) throws SQLException {
        LoggingSystem system = new LoggingSystem();

        // Single log
        system.log("INFO", "Application started");

        // Batch logs
        List<String> messages = Arrays.asList(
            "Processing request 1",
            "Processing request 2",
            "Processing request 3"
        );
        system.logBatch(messages);

        // Query recent
        List<LogEntry> recent = system.getRecentLogs(7);
        System.out.printf("Found %d logs from past week%n", recent.size());

        // Process all
        system.processAllLogs();
    }
}
```

## Complete API Reference

### ID Generation Methods
```java
long getNextId()                              // Get next sequential ID
List<Long> getNextN(int count)                // Get N sequential IDs at once
long getCurrentId()                           // Get current ID without incrementing
void resetId(long newId)                      // Reset counter to specific value
```

### Insertion Methods

#### Auto-Generated IDs
```java
void insert(T entity)                         // Insert single entity with auto ID
void insertMultiple(List<T> entities)         // Bulk insert with auto IDs
List<Long> insertMultipleWithAutoId(List<T> entities)  // Returns assigned IDs
```

#### Client-Provided IDs (requires allowClientIds=true)
```java
void insertWithClientId(T entity, long clientId)       // Single entity with client ID
void insertMultipleWithClientIds(List<T> entities, List<Long> clientIds)  // Bulk with IDs
```

### Retrieval Methods
```java
T findById(long id)                           // Find single entity by ID
List<T> findByIdRange(long startId, int batchSize)  // Batch retrieval
// Example: findByIdRange(1000, 100) returns records with IDs 1000-1099
// Missing records within range are skipped
```

### Range Operations
```java
IdRange reserveIdRange(int count)             // Reserve ID range for future use
void insertWithIdRange(List<T> entities, IdRange range)  // Use reserved range
void insertWithinIdRange(List<T> entities, long startId, long endId)  // Use specific range
```

### Date-Based Queries (inherited from underlying repository)
```java
List<T> findByPartitionColBetween(LocalDateTime start, LocalDateTime end)
List<T> findByPartitionColBetweenPaginated(LocalDateTime start, LocalDateTime end, 
                                          String cursor, int limit)
```

### Repository Management
```java
void shutdown()                                // Gracefully shutdown and persist state
```

