<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Split-Verse Design Requirements & Specifications</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f5f5;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        /* Sidebar Styles */
        .sidebar {
            width: 320px;
            background: #2c3e50;
            color: white;
            padding: 20px;
            overflow-y: auto;
            position: fixed;
            height: 100%;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
        }

        .sidebar h2 {
            font-size: 20px;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #34495e;
        }

        .nav-section {
            margin-bottom: 20px;
        }

        .nav-section h3 {
            font-size: 14px;
            text-transform: uppercase;
            color: #95a5a6;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .nav-section ul {
            list-style: none;
        }

        .nav-section li {
            margin-bottom: 5px;
        }

        .nav-section a {
            color: #ecf0f1;
            text-decoration: none;
            display: block;
            padding: 8px 12px;
            border-radius: 4px;
            transition: background 0.3s;
            font-size: 14px;
        }

        .nav-section a:hover {
            background: #34495e;
        }

        .nav-section a.active {
            background: #3498db;
        }

        .nav-subsection {
            margin-left: 15px;
            margin-top: 5px;
        }

        .nav-subsection a {
            font-size: 13px;
            color: #bdc3c7;
        }

        /* Main Content Styles */
        .main-content {
            margin-left: 320px;
            padding: 40px;
            width: calc(100% - 320px);
            background: white;
            min-height: 100vh;
        }

        .section {
            margin-bottom: 40px;
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        h1 {
            color: #2c3e50;
            font-size: 36px;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 3px solid #3498db;
        }

        h2 {
            color: #2c3e50;
            font-size: 28px;
            margin-top: 30px;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #ecf0f1;
        }

        h3 {
            color: #34495e;
            font-size: 20px;
            margin-top: 25px;
            margin-bottom: 15px;
        }

        h4 {
            color: #34495e;
            font-size: 16px;
            margin-top: 20px;
            margin-bottom: 10px;
            font-weight: 600;
        }

        p {
            margin-bottom: 15px;
            line-height: 1.8;
        }

        ul, ol {
            margin-left: 30px;
            margin-bottom: 15px;
        }

        li {
            margin-bottom: 8px;
        }

        /* Code Blocks */
        pre {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 15px;
            overflow-x: auto;
            margin: 15px 0;
        }

        code {
            background: #f8f9fa;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
        }

        pre code {
            background: none;
            padding: 0;
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th {
            background: #34495e;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }

        td {
            padding: 12px;
            border: 1px solid #e9ecef;
        }

        tr:nth-child(even) {
            background: #f8f9fa;
        }

        /* Requirement Boxes */
        .requirement {
            background: #e8f4f8;
            border-left: 4px solid #3498db;
            padding: 15px;
            margin: 20px 0;
        }

        .requirement-critical {
            background: #ffeaa7;
            border-left: 4px solid #fdcb6e;
        }

        .requirement-optional {
            background: #dfe6e9;
            border-left: 4px solid #74b9ff;
        }

        .tag {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            margin-right: 5px;
        }

        .tag-must {
            background: #e74c3c;
            color: white;
        }

        .tag-should {
            background: #f39c12;
            color: white;
        }

        .tag-could {
            background: #3498db;
            color: white;
        }

        .tag-wont {
            background: #95a5a6;
            color: white;
        }

        /* Diagrams */
        .diagram {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }

        /* Status Indicators */
        .status {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
        }

        .status-implemented {
            background: #2ecc71;
            color: white;
        }

        .status-planned {
            background: #3498db;
            color: white;
        }

        .status-deprecated {
            background: #e74c3c;
            color: white;
        }
    </style>
</head>
<body>
    <!-- Sidebar Navigation -->
    <div class="sidebar">
        <h2>Split-Verse Documentation</h2>

        <div class="nav-section">
            <h3>Overview</h3>
            <ul>
                <li><a href="#introduction">Introduction</a></li>
                <li><a href="#goals">Project Goals</a></li>
                <li><a href="#architecture">Architecture Overview</a></li>
            </ul>
        </div>

        <div class="nav-section">
            <h3>Functional Requirements</h3>
            <ul>
                <li><a href="#fr-sharding">Database Sharding</a></li>
                <li><a href="#fr-partitioning">Table Partitioning</a></li>
                <li><a href="#fr-crud">CRUD Operations</a></li>
                <li><a href="#fr-query">Query Resolution</a></li>
                <li><a href="#fr-maintenance">Automatic Maintenance</a></li>
            </ul>
        </div>

        <div class="nav-section">
            <h3>Non-Functional Requirements</h3>
            <ul>
                <li><a href="#nfr-performance">Performance</a></li>
                <li><a href="#nfr-scalability">Scalability</a></li>
                <li><a href="#nfr-availability">Availability</a></li>
                <li><a href="#nfr-security">Security</a></li>
                <li><a href="#nfr-maintainability">Maintainability</a></li>
            </ul>
        </div>

        <div class="nav-section">
            <h3>Technical Specifications</h3>
            <ul>
                <li><a href="#ts-entities">Entity Requirements</a></li>
                <li><a href="#ts-sharding-strategies">Sharding Strategies</a></li>
                <li><a href="#ts-partition-types">Partition Types</a></li>
                <li><a href="#ts-api">API Design</a></li>
                <li><a href="#ts-builder">Builder Pattern</a></li>
            </ul>
        </div>

        <div class="nav-section">
            <h3>Data Model</h3>
            <ul>
                <li><a href="#dm-primary-key">Primary Key Design</a></li>
                <li><a href="#dm-partition-column">Partition Column Types</a></li>
                <li><a href="#dm-table-naming">Table Naming</a></li>
                <li><a href="#dm-indexes">Index Strategy</a></li>
            </ul>
        </div>

        <div class="nav-section">
            <h3>Implementation Details</h3>
            <ul>
                <li><a href="#impl-routing">Query Routing</a></li>
                <li><a href="#impl-connection">Connection Management</a></li>
                <li><a href="#impl-transaction">Transaction Handling</a></li>
                <li><a href="#impl-monitoring">Monitoring</a></li>
            </ul>
        </div>

        <div class="nav-section">
            <h3>Configuration</h3>
            <ul>
                <li><a href="#config-shard">Shard Configuration</a></li>
                <li><a href="#config-partition">Partition Configuration</a></li>
                <li><a href="#config-retention">Retention Policies</a></li>
            </ul>
        </div>

        <div class="nav-section">
            <h3>Appendix</h3>
            <ul>
                <li><a href="#examples">Usage Examples</a></li>
                <li><a href="#migration">Migration Guide</a></li>
                <li><a href="#glossary">Glossary</a></li>
            </ul>
        </div>
    </div>

    <!-- Main Content -->
    <div class="main-content">
        <div class="section">
            <h1 id="introduction">Split-Verse Design Requirements & Specifications</h1>
            <p>Version: 2.0.0 | Last Updated: September 2025</p>

            <h2>Executive Summary</h2>
            <p>Split-Verse is a production-ready Java framework for infinite horizontal sharding across MySQL databases. It provides transparent data distribution, automatic partition management, and enforces best practices for distributed systems while maintaining simplicity and high performance.</p>
        </div>

        <!-- Project Goals -->
        <div class="section" id="goals">
            <h2>Project Goals</h2>

            <div class="requirement requirement-critical">
                <span class="tag tag-must">MUST</span>
                <strong>G-001:</strong> Support infinite horizontal scaling across distributed MySQL instances
            </div>

            <div class="requirement requirement-critical">
                <span class="tag tag-must">MUST</span>
                <strong>G-002:</strong> Maintain single primary key constraint (no composite keys)
            </div>

            <div class="requirement requirement-critical">
                <span class="tag tag-must">MUST</span>
                <strong>G-003:</strong> Provide complete CRUD operations with optimal performance
            </div>

            <div class="requirement">
                <span class="tag tag-should">SHOULD</span>
                <strong>G-004:</strong> Automatically manage partition lifecycle
            </div>

            <div class="requirement">
                <span class="tag tag-should">SHOULD</span>
                <strong>G-005:</strong> Support multiple partition strategies (range, hash)
            </div>
        </div>

        <!-- Architecture Overview -->
        <div class="section" id="architecture">
            <h2>Architecture Overview</h2>

            <div class="diagram">
                <pre>
┌─────────────────────────────────────────────────────────┐
│                    Application Layer                      │
└─────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────┐
│              SplitVerseRepository (Public API)            │
│  • Builder-only access pattern                           │
│  • Type-safe configuration                               │
│  • Compile-time validation                               │
└─────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────┐
│                    Routing Layer                         │
│  • Level 1: Hash(ID) → Select Shard                      │
│  • Level 2: Partition Value → Select Table               │
└─────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────┐
│                  Physical Storage Layer                  │
│  Shard 1              Shard 2              Shard N       │
└─────────────────────────────────────────────────────────┘
                </pre>
            </div>
        </div>

        <!-- Functional Requirements -->
        <div class="section" id="fr-sharding">
            <h2>Functional Requirements</h2>

            <h3>FR-1: Database Sharding</h3>

            <div class="requirement requirement-critical">
                <span class="tag tag-must">MUST</span>
                <strong>FR-1.1:</strong> Support hash-based sharding at database level
                <pre><code>// Configuration without database names
ShardConfig.builder()
    .shardId("shard1")
    .host("server1.dc1.com")
    .port(3306)
    // No database name - derived from sharding strategy
    .build()</code></pre>
            </div>

            <div class="requirement requirement-critical">
                <span class="tag tag-must">MUST</span>
                <strong>FR-1.2:</strong> Distribute data across geographically distributed datacenters
            </div>

            <div class="requirement">
                <span class="tag tag-should">SHOULD</span>
                <strong>FR-1.3:</strong> Support dynamic shard addition without downtime
            </div>

            <table>
                <thead>
                    <tr>
                        <th>Sharding Strategy</th>
                        <th>Status</th>
                        <th>Use Case</th>
                        <th>Performance</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>SINGLE_KEY_HASH</td>
                        <td><span class="status status-implemented">Implemented</span></td>
                        <td>User profiles, accounts</td>
                        <td>O(1) lookup</td>
                    </tr>
                    <tr>
                        <td>DUAL_KEY_HASH_RANGE</td>
                        <td><span class="status status-planned">Planned</span></td>
                        <td>Time-series data</td>
                        <td>O(log n) with pruning</td>
                    </tr>
                    <tr>
                        <td>DUAL_KEY_HASH_HASH</td>
                        <td><span class="status status-planned">Planned</span></td>
                        <td>Categorical data</td>
                        <td>O(1) with hint</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="section" id="fr-partitioning">
            <h3>FR-2: Table Partitioning</h3>

            <div class="requirement requirement-critical">
                <span class="tag tag-must">MUST</span>
                <strong>FR-2.1:</strong> Support multi-table partitioning (separate tables per partition)
            </div>

            <div class="requirement requirement-critical">
                <span class="tag tag-must">MUST</span>
                <strong>FR-2.2:</strong> Support multiple partition column types
                <ul>
                    <li>LocalDateTime - for time-series data</li>
                    <li>Long - for numeric ranges</li>
                    <li>Integer - for smaller numeric ranges</li>
                    <li>Double - for floating-point ranges</li>
                    <li>String - for hash-based partitioning only</li>
                </ul>
            </div>

            <div class="requirement">
                <span class="tag tag-should">SHOULD</span>
                <strong>FR-2.3:</strong> Support configurable partition granularity
                <pre><code>// Daily partitions for datetime
PartitionConfig.range(24)  // 24 hours

// Value-based partitions for numeric
PartitionConfig.range(1_000_000)  // Every 1M value range

// Hash buckets for strings
PartitionConfig.hash(10)  // 10 buckets</code></pre>
            </div>

            <h4>Partition Naming Conventions</h4>
            <table>
                <thead>
                    <tr>
                        <th>Type</th>
                        <th>Pattern</th>
                        <th>Example</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>DateTime (Daily)</td>
                        <td>{base}_{yyyy}_{MM}_{dd}</td>
                        <td>orders_2024_01_15</td>
                    </tr>
                    <tr>
                        <td>DateTime (Hourly)</td>
                        <td>{base}_{yyyy}_{MM}_{dd}_{HH}</td>
                        <td>logs_2024_01_15_14</td>
                    </tr>
                    <tr>
                        <td>Numeric Range</td>
                        <td>{base}_range_{index}</td>
                        <td>accounts_range_5</td>
                    </tr>
                    <tr>
                        <td>Hash</td>
                        <td>{base}_hash_{bucket}</td>
                        <td>users_hash_3</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="section" id="fr-crud">
            <h3>FR-3: CRUD Operations</h3>

            <div class="requirement requirement-critical">
                <span class="tag tag-must">MUST</span>
                <strong>FR-3.1:</strong> Provide complete CRUD operations
            </div>

            <h4>CREATE Operations</h4>
            <pre><code>void insert(T entity);
void insertBatch(List&lt;T&gt; entities);</code></pre>

            <h4>READ Operations</h4>
            <pre><code>// ID-based (may scan all partitions)
T findById(String id);

// Partition-aware (efficient)
List&lt;T&gt; findByPartitionRange(P start, P end);
T findByIdInPartition(String id, P partitionValue);

// Pagination
List&lt;T&gt; findBatchByIdGreaterThan(String cursor, int size);</code></pre>

            <h4>UPDATE Operations</h4>
            <pre><code>void updateById(String id, T entity);
void updateByIdInPartition(String id, T entity, P partitionValue);
void updateBatch(List&lt;T&gt; entities);</code></pre>

            <h4>DELETE Operations</h4>
            <pre><code>void deleteById(String id);
void deleteByPartitionRange(P start, P end);
void deleteByIdInPartition(String id, P partitionValue);</code></pre>

            <div class="requirement requirement-critical">
                <span class="tag tag-must">MUST</span>
                <strong>FR-3.2:</strong> Operations must be atomic within a single shard
            </div>

            <div class="requirement">
                <span class="tag tag-wont">WON'T</span>
                <strong>FR-3.3:</strong> Cross-shard transactions are not supported in v1.0
            </div>
        </div>

        <div class="section" id="fr-query">
            <h3>FR-4: Query Resolution</h3>

            <div class="requirement requirement-critical">
                <span class="tag tag-must">MUST</span>
                <strong>FR-4.1:</strong> Optimize queries using partition pruning
            </div>

            <h4>Query Performance Matrix</h4>
            <table>
                <thead>
                    <tr>
                        <th>Query Type</th>
                        <th>Has ID?</th>
                        <th>Has Partition Value?</th>
                        <th>Performance</th>
                        <th>Complexity</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Point Lookup</td>
                        <td>✅</td>
                        <td>✅</td>
                        <td>⭐⭐⭐⭐⭐</td>
                        <td>O(1)</td>
                    </tr>
                    <tr>
                        <td>Range Scan</td>
                        <td>❌</td>
                        <td>✅</td>
                        <td>⭐⭐⭐⭐</td>
                        <td>O(p) where p=partitions</td>
                    </tr>
                    <tr>
                        <td>ID Only</td>
                        <td>✅</td>
                        <td>❌</td>
                        <td>⭐⭐</td>
                        <td>O(n) full scan</td>
                    </tr>
                    <tr>
                        <td>Full Scan</td>
                        <td>❌</td>
                        <td>❌</td>
                        <td>⭐</td>
                        <td>O(s*n) all shards</td>
                    </tr>
                </tbody>
            </table>

            <h4>Query Resolution Algorithm</h4>
            <pre><code>// Step 1: Identify target shards
if (query.hasId()) {
    shards = [hash(id) % numShards];
} else {
    shards = ALL_SHARDS;  // Fan-out
}

// Step 2: Identify target partitions
if (query.hasPartitionValue()) {
    tables = getTablesForPartitionValue(value);
} else if (query.hasPartitionRange()) {
    tables = getTablesInRange(start, end);
} else {
    tables = ALL_TABLES;  // Expensive
}

// Step 3: Execute and merge
results = executeOnShardsAndTables(shards, tables, query);
return mergeResults(results);</code></pre>
        </div>

        <div class="section" id="fr-maintenance">
            <h3>FR-5: Automatic Maintenance</h3>

            <div class="requirement">
                <span class="tag tag-should">SHOULD</span>
                <strong>FR-5.1:</strong> Automatically create future partitions
            </div>

            <div class="requirement">
                <span class="tag tag-should">SHOULD</span>
                <strong>FR-5.2:</strong> Automatically drop expired partitions based on retention
            </div>

            <pre><code>public class MaintenanceScheduler {
    @Scheduled(cron = "0 0 4 * * *")  // Daily at 4 AM
    public void performMaintenance() {
        // Drop old partitions
        dropPartitionsOlderThan(retentionDays);

        // Create future partitions
        createPartitionsForNext(futureDays);
    }
}</code></pre>
        </div>

        <!-- Non-Functional Requirements -->
        <div class="section" id="nfr-performance">
            <h2>Non-Functional Requirements</h2>

            <h3>NFR-1: Performance Requirements</h3>

            <div class="requirement requirement-critical">
                <span class="tag tag-must">MUST</span>
                <strong>NFR-1.1:</strong> Point lookups must complete in &lt; 10ms (99th percentile)
            </div>

            <div class="requirement requirement-critical">
                <span class="tag tag-must">MUST</span>
                <strong>NFR-1.2:</strong> Batch inserts must achieve &gt; 10,000 records/second per shard
            </div>

            <div class="requirement">
                <span class="tag tag-should">SHOULD</span>
                <strong>NFR-1.3:</strong> Range queries should use partition pruning to minimize scanned data
            </div>

            <table>
                <thead>
                    <tr>
                        <th>Operation</th>
                        <th>Target Latency (p99)</th>
                        <th>Throughput</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Insert Single</td>
                        <td>&lt; 5ms</td>
                        <td>5,000/sec</td>
                    </tr>
                    <tr>
                        <td>Insert Batch</td>
                        <td>&lt; 100ms</td>
                        <td>10,000/sec</td>
                    </tr>
                    <tr>
                        <td>Find by ID + Partition</td>
                        <td>&lt; 10ms</td>
                        <td>10,000/sec</td>
                    </tr>
                    <tr>
                        <td>Range Query (1 day)</td>
                        <td>&lt; 100ms</td>
                        <td>100/sec</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="section" id="nfr-scalability">
            <h3>NFR-2: Scalability Requirements</h3>

            <div class="requirement requirement-critical">
                <span class="tag tag-must">MUST</span>
                <strong>NFR-2.1:</strong> Support horizontal scaling to unlimited shards
            </div>

            <div class="requirement requirement-critical">
                <span class="tag tag-must">MUST</span>
                <strong>NFR-2.2:</strong> Support billions of records across all shards
            </div>

            <h4>Scalability Limits</h4>
            <table>
                <thead>
                    <tr>
                        <th>Dimension</th>
                        <th>Limit</th>
                        <th>Constraint</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Shards</td>
                        <td>Unlimited</td>
                        <td>Network topology</td>
                    </tr>
                    <tr>
                        <td>Tables per shard</td>
                        <td>10,000+</td>
                        <td>MySQL limit</td>
                    </tr>
                    <tr>
                        <td>Records per table</td>
                        <td>100M+</td>
                        <td>Storage capacity</td>
                    </tr>
                    <tr>
                        <td>Concurrent connections</td>
                        <td>1,000 per shard</td>
                        <td>Connection pool</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="section" id="nfr-availability">
            <h3>NFR-3: Availability Requirements</h3>

            <div class="requirement">
                <span class="tag tag-should">SHOULD</span>
                <strong>NFR-3.1:</strong> Continue operating if individual shards fail
            </div>

            <div class="requirement">
                <span class="tag tag-could">COULD</span>
                <strong>NFR-3.2:</strong> Support read replicas for each shard
            </div>
        </div>

        <!-- Technical Specifications -->
        <div class="section" id="ts-entities">
            <h2>Technical Specifications</h2>

            <h3>Entity Requirements</h3>

            <div class="requirement requirement-critical">
                <span class="tag tag-must">MUST</span>
                <strong>TS-1.1:</strong> All entities must implement ShardingEntity interface
            </div>

            <pre><code>public interface ShardingEntity {
    String getId();
    void setId(String id);
    LocalDateTime getCreatedAt();
    void setCreatedAt(LocalDateTime createdAt);
}

@Table(name = "orders")
public class Order implements ShardingEntity {
    @Id(autoGenerated = false)  // MUST be false
    @Column(name = "order_id")
    private String id;  // VARCHAR(8-22)

    @ShardingKey
    @Column(name = "created_at")
    private LocalDateTime createdAt;

    // ... other fields
}</code></pre>

            <h4>Entity Validation Rules</h4>
            <ul>
                <li>Exactly ONE field with @Id annotation</li>
                <li>ID field MUST be String type</li>
                <li>ID must have autoGenerated=false</li>
                <li>ID size configurable between 8-22 bytes</li>
                <li>Exactly ONE field with @ShardingKey annotation (if using DUAL_KEY strategy)</li>
            </ul>
        </div>

        <div class="section" id="ts-sharding-strategies">
            <h3>Sharding Strategies</h3>

            <pre><code>public enum ShardingStrategy {
    SINGLE_KEY_HASH {
        // ID serves as both shard and partition key
        @Override
        public boolean requiresPartitionColumn() { return false; }
    },

    DUAL_KEY_HASH_RANGE {
        // ID for sharding, separate column for range partitioning
        @Override
        public boolean requiresPartitionColumn() { return true; }
    },

    DUAL_KEY_HASH_HASH {
        // ID for sharding, separate column for hash partitioning
        @Override
        public boolean requiresPartitionColumn() { return true; }
    }
}</code></pre>
        </div>

        <div class="section" id="ts-api">
            <h3>API Design</h3>

            <h4>Repository Interface</h4>
            <pre><code>public interface ShardingRepository&lt;T extends ShardingEntity, P&gt; {
    // T = Entity type
    // P = Partition column type (LocalDateTime, Long, String, etc.)

    // CREATE
    void insert(T entity) throws SQLException;
    void insertBatch(List&lt;T&gt; entities) throws SQLException;

    // READ
    T findById(String id) throws SQLException;
    T findByIdInPartition(String id, P partitionValue) throws SQLException;
    List&lt;T&gt; findByPartitionRange(P start, P end) throws SQLException;

    // UPDATE
    void updateById(String id, T entity) throws SQLException;
    void updateByIdInPartition(String id, T entity, P value) throws SQLException;

    // DELETE
    void deleteById(String id) throws SQLException;
    void deleteByIdInPartition(String id, P value) throws SQLException;
    void deleteByPartitionRange(P start, P end) throws SQLException;

    // UTILITY
    long count() throws SQLException;
    long countByPartitionRange(P start, P end) throws SQLException;
    boolean exists(String id) throws SQLException;

    // LIFECYCLE
    void shutdown();
}</code></pre>
        </div>

        <div class="section" id="ts-builder">
            <h3>Builder Pattern Configuration</h3>

            <pre><code>// Complete builder example
SplitVerseRepository&lt;Order, LocalDateTime&gt; repository =
    SplitVerseRepository.&lt;Order, LocalDateTime&gt;builder()
        // Sharding configuration
        .withShardConfigs(Arrays.asList(
            ShardConfig.builder()
                .shardId("shard1")
                .host("server1.dc1.com")
                .port(3306)
                .build(),
            ShardConfig.builder()
                .shardId("shard2")
                .host("server2.dc2.com")
                .port(3306)
                .build()
        ))

        // Entity configuration
        .withEntityClass(Order.class)
        .withIdColumnSize(22)  // VARCHAR(22)

        // Sharding strategy
        .withShardingStrategy(ShardingStrategy.DUAL_KEY_HASH_RANGE)

        // Partition configuration
        .withPartitionColumn("created_at", LocalDateTime.class)
        .withPartitionConfig(PartitionConfig.range(24))  // Daily

        // Table mode
        .withRepositoryMode(RepositoryMode.MULTI_TABLE)

        // Maintenance
        .withRetentionDays(30)
        .withAutoMaintenance(true)

        // Character encoding
        .withCharset("utf8mb4")
        .withCollation("utf8mb4_bin")

        .build();</code></pre>
        </div>

        <!-- Data Model -->
        <div class="section" id="dm-primary-key">
            <h2>Data Model</h2>

            <h3>Primary Key Design</h3>

            <div class="requirement requirement-critical">
                <span class="tag tag-must">MUST</span>
                <strong>DM-1.1:</strong> Use single column primary keys only (no composite keys)
            </div>

            <pre><code>-- ✅ CORRECT: Single primary key
CREATE TABLE orders (
    id VARCHAR(22) PRIMARY KEY,
    created_at DATETIME NOT NULL,
    amount DECIMAL(10,2)
);

-- ❌ WRONG: Composite primary key
CREATE TABLE orders (
    id VARCHAR(22),
    created_at DATETIME,
    PRIMARY KEY (id, created_at)  -- NOT ALLOWED
);</code></pre>

            <h4>ID Generation Strategies</h4>
            <table>
                <thead>
                    <tr>
                        <th>Strategy</th>
                        <th>Length</th>
                        <th>Example</th>
                        <th>Pros</th>
                        <th>Cons</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>UUID v4</td>
                        <td>36 chars</td>
                        <td>550e8400-e29b-41d4-a716-446655440000</td>
                        <td>Universal standard</td>
                        <td>Large size</td>
                    </tr>
                    <tr>
                        <td>ULID</td>
                        <td>26 chars</td>
                        <td>01ARZ3NDEKTSV4RRFFQ69G5FAV</td>
                        <td>Sortable, timestamp</td>
                        <td>Less common</td>
                    </tr>
                    <tr>
                        <td>NanoID</td>
                        <td>21 chars</td>
                        <td>V1StGXR8_Z5jdHi6B-myT</td>
                        <td>Compact, fast</td>
                        <td>No timestamp</td>
                    </tr>
                    <tr>
                        <td>Custom</td>
                        <td>8-22 chars</td>
                        <td>ORD2024X7K9</td>
                        <td>Domain-specific</td>
                        <td>Collision risk</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="section" id="dm-partition-column">
            <h3>Partition Column Types</h3>

            <table>
                <thead>
                    <tr>
                        <th>Type</th>
                        <th>Java Type</th>
                        <th>SQL Type</th>
                        <th>Partition Strategy</th>
                        <th>Example</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>DateTime</td>
                        <td>LocalDateTime</td>
                        <td>DATETIME</td>
                        <td>RANGE</td>
                        <td>Daily, Hourly, Monthly</td>
                    </tr>
                    <tr>
                        <td>Long</td>
                        <td>Long</td>
                        <td>BIGINT</td>
                        <td>RANGE</td>
                        <td>Every 1M values</td>
                    </tr>
                    <tr>
                        <td>Integer</td>
                        <td>Integer</td>
                        <td>INT</td>
                        <td>RANGE</td>
                        <td>Every 10K values</td>
                    </tr>
                    <tr>
                        <td>Double</td>
                        <td>Double</td>
                        <td>DOUBLE</td>
                        <td>RANGE</td>
                        <td>Every 1000.0</td>
                    </tr>
                    <tr>
                        <td>String</td>
                        <td>String</td>
                        <td>VARCHAR</td>
                        <td>HASH only</td>
                        <td>10 buckets</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <!-- Configuration Examples -->
        <div class="section" id="examples">
            <h2>Usage Examples</h2>

            <h3>Example 1: Time-Series Data (Call Records)</h3>
            <pre><code>// Call records: sharded by callId, partitioned by callStartTime
SplitVerseRepository&lt;CallRecord, LocalDateTime&gt; callRepo =
    SplitVerseRepository.&lt;CallRecord, LocalDateTime&gt;builder()
        .withEntityClass(CallRecord.class)
        .withShardingStrategy(ShardingStrategy.DUAL_KEY_HASH_RANGE)
        .withPartitionColumn("callStartTime", LocalDateTime.class)
        .withPartitionConfig(PartitionConfig.range(24))  // Daily
        .withRetentionDays(90)  // Keep 3 months
        .build();

// Efficient query for today's calls
List&lt;CallRecord&gt; todaysCalls = callRepo.findByPartitionRange(
    LocalDateTime.now().truncatedTo(ChronoUnit.DAYS),
    LocalDateTime.now()
);</code></pre>

            <h3>Example 2: User Profiles (Simple Sharding)</h3>
            <pre><code>// Users: sharded by userId only
SplitVerseRepository&lt;User&gt; userRepo =
    SplitVerseRepository.&lt;User&gt;builder()
        .withEntityClass(User.class)
        .withShardingStrategy(ShardingStrategy.SINGLE_KEY_HASH)
        .withShardConfigs(shardList)
        .build();

// Simple operations
User user = userRepo.findById("user-123");
userRepo.insert(newUser);</code></pre>

            <h3>Example 3: Financial Transactions (Range Partitioning)</h3>
            <pre><code>// Transactions: partitioned by amount ranges
SplitVerseRepository&lt;Transaction, Long&gt; txRepo =
    SplitVerseRepository.&lt;Transaction, Long&gt;builder()
        .withEntityClass(Transaction.class)
        .withShardingStrategy(ShardingStrategy.DUAL_KEY_HASH_RANGE)
        .withPartitionColumn("amount", Long.class)
        .withPartitionConfig(PartitionConfig.range(1_000_000))  // Per million
        .build();

// Query high-value transactions
List&lt;Transaction&gt; highValue = txRepo.findByPartitionRange(
    10_000_000L,  // $10M+
    100_000_000L  // up to $100M
);</code></pre>
        </div>

        <!-- Glossary -->
        <div class="section" id="glossary">
            <h2>Glossary</h2>

            <table>
                <thead>
                    <tr>
                        <th>Term</th>
                        <th>Definition</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Shard</strong></td>
                        <td>A separate database instance containing a subset of data</td>
                    </tr>
                    <tr>
                        <td><strong>Partition</strong></td>
                        <td>A table or table segment within a shard</td>
                    </tr>
                    <tr>
                        <td><strong>Sharding Key</strong></td>
                        <td>The column used to determine which shard receives the data</td>
                    </tr>
                    <tr>
                        <td><strong>Partition Column</strong></td>
                        <td>The column used to determine which table/partition within a shard</td>
                    </tr>
                    <tr>
                        <td><strong>Partition Pruning</strong></td>
                        <td>Query optimization that skips irrelevant partitions</td>
                    </tr>
                    <tr>
                        <td><strong>Fan-out Query</strong></td>
                        <td>Query that must be executed across multiple shards</td>
                    </tr>
                    <tr>
                        <td><strong>Hot Partition</strong></td>
                        <td>A partition receiving disproportionately high traffic</td>
                    </tr>
                    <tr>
                        <td><strong>Retention Period</strong></td>
                        <td>How long data is kept before automatic deletion</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <script>
        // Add active class to clicked links
        document.querySelectorAll('.sidebar a').forEach(link => {
            link.addEventListener('click', function(e) {
                document.querySelectorAll('.sidebar a').forEach(a => a.classList.remove('active'));
                this.classList.add('active');
            });
        });

        // Smooth scrolling
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // Highlight current section on scroll
        window.addEventListener('scroll', () => {
            let current = '';
            const sections = document.querySelectorAll('.section[id], h2[id], h3[id]');

            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                const sectionHeight = section.clientHeight;
                if (scrollY >= sectionTop - 60) {
                    current = section.getAttribute('id');
                }
            });

            document.querySelectorAll('.sidebar a').forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });
        });
    </script>
</body>
</html>