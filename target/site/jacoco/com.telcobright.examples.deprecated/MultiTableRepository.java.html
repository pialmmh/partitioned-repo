<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MultiTableRepository.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Generic Sharding-Aware Repository Framework</a> &gt; <a href="index.source.html" class="el_package">com.telcobright.examples.deprecated</a> &gt; <span class="el_source">MultiTableRepository.java</span></div><h1>MultiTableRepository.java</h1><pre class="source lang-java linenums">package com.telcobright.examples.deprecated;

import com.telcobright.core.query.QueryDSL;
import com.telcobright.examples.entity.SmsEntity;

import javax.sql.DataSource;
import java.sql.*;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.math.BigDecimal;

/**
 * Multi-table repository for entities with generic ID type
 * Creates separate tables per day: sms_20250803, sms_20250804, etc.
 * Uses 2-level queries with UNION ALL for cross-table operations
 * @param &lt;T&gt; The type of the ID column (Long, String, UUID, etc.)
 */
public class MultiTableRepository&lt;T&gt; {
    
    private final DataSource dataSource;
    private final String database;
    private final String tablePrefix;
    private final int partitionRetentionPeriod;
    private final boolean autoManagePartitions;
    private final boolean initializePartitionsOnStart;
    private final LocalTime partitionAdjustmentTime;
    private final ScheduledExecutorService scheduler;
<span class="nc" id="L33">    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(&quot;yyyyMMdd&quot;);</span>
    
<span class="nc" id="L35">    private MultiTableRepository(Builder&lt;T&gt; builder) {</span>
<span class="nc" id="L36">        this.dataSource = createDataSource(builder.host, builder.port, builder.database, </span>
                                          builder.username, builder.password);
<span class="nc" id="L38">        this.database = builder.database;</span>
<span class="nc" id="L39">        this.tablePrefix = builder.tablePrefix;</span>
<span class="nc" id="L40">        this.partitionRetentionPeriod = builder.partitionRetentionPeriod;</span>
<span class="nc" id="L41">        this.autoManagePartitions = builder.autoManagePartitions;</span>
<span class="nc" id="L42">        this.initializePartitionsOnStart = builder.initializePartitionsOnStart;</span>
<span class="nc" id="L43">        this.partitionAdjustmentTime = builder.partitionAdjustmentTime;</span>
<span class="nc bnc" id="L44" title="All 2 branches missed.">        this.scheduler = autoManagePartitions ? Executors.newScheduledThreadPool(1) : null;</span>
        
<span class="nc bnc" id="L46" title="All 2 branches missed.">        if (initializePartitionsOnStart) {</span>
            try {
<span class="nc" id="L48">                LocalDateTime now = LocalDateTime.now();</span>
<span class="nc" id="L49">                createTablesForDateRange(</span>
<span class="nc" id="L50">                    now.minusDays(partitionRetentionPeriod), </span>
<span class="nc" id="L51">                    now.plusDays(partitionRetentionPeriod)</span>
                );
<span class="nc" id="L53">            } catch (SQLException e) {</span>
<span class="nc" id="L54">                throw new RuntimeException(&quot;Failed to initialize partitions on start&quot;, e);</span>
<span class="nc" id="L55">            }</span>
        }
        
        // Start daily scheduler if auto-management is enabled
<span class="nc bnc" id="L59" title="All 4 branches missed.">        if (autoManagePartitions &amp;&amp; scheduler != null) {</span>
<span class="nc" id="L60">            startDailyScheduler();</span>
        }
<span class="nc" id="L62">    }</span>
    
    public static &lt;T&gt; Builder&lt;T&gt; builder() {
<span class="nc" id="L65">        return new Builder&lt;T&gt;();</span>
    }
    
<span class="nc" id="L68">    public static class Builder&lt;T&gt; {</span>
<span class="nc" id="L69">        private String host = &quot;localhost&quot;;</span>
<span class="nc" id="L70">        private int port = 3306;</span>
        private String database;
        private String username;
        private String password;
        private String tablePrefix;
<span class="nc" id="L75">        private int partitionRetentionPeriod = 7; // Default 7 days</span>
<span class="nc" id="L76">        private boolean autoManagePartitions = true; // Default enabled</span>
<span class="nc" id="L77">        private boolean initializePartitionsOnStart = false; // Default disabled</span>
<span class="nc" id="L78">        private LocalTime partitionAdjustmentTime = LocalTime.of(4, 0); // Default 04:00</span>
        
        public Builder&lt;T&gt; host(String host) {
<span class="nc" id="L81">            this.host = host;</span>
<span class="nc" id="L82">            return this;</span>
        }
        
        public Builder&lt;T&gt; port(int port) {
<span class="nc" id="L86">            this.port = port;</span>
<span class="nc" id="L87">            return this;</span>
        }
        
        public Builder&lt;T&gt; username(String username) {
<span class="nc" id="L91">            this.username = username;</span>
<span class="nc" id="L92">            return this;</span>
        }
        
        public Builder&lt;T&gt; password(String password) {
<span class="nc" id="L96">            this.password = password;</span>
<span class="nc" id="L97">            return this;</span>
        }
        
        public Builder&lt;T&gt; database(String database) {
<span class="nc" id="L101">            this.database = database;</span>
<span class="nc" id="L102">            return this;</span>
        }
        
        public Builder&lt;T&gt; tablePrefix(String tablePrefix) {
<span class="nc" id="L106">            this.tablePrefix = tablePrefix;</span>
<span class="nc" id="L107">            return this;</span>
        }
        
        public Builder&lt;T&gt; partitionRetentionPeriod(int days) {
<span class="nc" id="L111">            this.partitionRetentionPeriod = days;</span>
<span class="nc" id="L112">            return this;</span>
        }
        
        public Builder&lt;T&gt; autoManagePartitions(boolean autoManage) {
<span class="nc" id="L116">            this.autoManagePartitions = autoManage;</span>
<span class="nc" id="L117">            return this;</span>
        }
        
        public Builder&lt;T&gt; initializePartitionsOnStart(boolean initialize) {
<span class="nc" id="L121">            this.initializePartitionsOnStart = initialize;</span>
<span class="nc" id="L122">            return this;</span>
        }
        
        public Builder&lt;T&gt; partitionAdjustmentTime(LocalTime adjustmentTime) {
<span class="nc" id="L126">            this.partitionAdjustmentTime = adjustmentTime;</span>
<span class="nc" id="L127">            return this;</span>
        }
        
        public Builder&lt;T&gt; partitionAdjustmentTime(int hour, int minute) {
<span class="nc" id="L131">            this.partitionAdjustmentTime = LocalTime.of(hour, minute);</span>
<span class="nc" id="L132">            return this;</span>
        }
        
        public MultiTableRepository&lt;T&gt; build() {
<span class="nc bnc" id="L136" title="All 4 branches missed.">            if (database == null || database.trim().isEmpty()) {</span>
<span class="nc" id="L137">                throw new IllegalArgumentException(&quot;Database name is required&quot;);</span>
            }
<span class="nc bnc" id="L139" title="All 4 branches missed.">            if (username == null || username.trim().isEmpty()) {</span>
<span class="nc" id="L140">                throw new IllegalArgumentException(&quot;Username is required&quot;);</span>
            }
<span class="nc bnc" id="L142" title="All 2 branches missed.">            if (password == null) {</span>
<span class="nc" id="L143">                throw new IllegalArgumentException(&quot;Password is required&quot;);</span>
            }
<span class="nc bnc" id="L145" title="All 4 branches missed.">            if (tablePrefix == null || tablePrefix.trim().isEmpty()) {</span>
<span class="nc" id="L146">                throw new IllegalArgumentException(&quot;Table prefix is required&quot;);</span>
            }
<span class="nc bnc" id="L148" title="All 2 branches missed.">            if (partitionRetentionPeriod &lt;= 0) {</span>
<span class="nc" id="L149">                throw new IllegalArgumentException(&quot;Partition retention period must be positive&quot;);</span>
            }
            
<span class="nc" id="L152">            return new MultiTableRepository&lt;T&gt;(this);</span>
        }
    }
    
    /**
     * Insert SMS into appropriate daily table
     */
    public void insert(SmsEntity sms) throws SQLException {
        // Automatically ensure table exists for the SMS date
<span class="nc" id="L161">        ensureTableExistsForDate(sms.getCreatedAt());</span>
        
<span class="nc" id="L163">        String tableName = getTableName(sms.getCreatedAt());</span>
        
<span class="nc" id="L165">        String sql = &quot;INSERT INTO &quot; + tableName + </span>
            &quot; (user_id, phone_number, message, status, created_at, delivered_at, cost, provider) &quot; +
            &quot;VALUES (?, ?, ?, ?, ?, ?, ?, ?)&quot;;
        
<span class="nc" id="L169">        try (Connection conn = dataSource.getConnection();</span>
<span class="nc" id="L170">             PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {</span>
            
<span class="nc" id="L172">            stmt.setString(1, sms.getUserId());</span>
<span class="nc" id="L173">            stmt.setString(2, sms.getPhoneNumber());</span>
<span class="nc" id="L174">            stmt.setString(3, sms.getMessage());</span>
<span class="nc" id="L175">            stmt.setString(4, sms.getStatus());</span>
<span class="nc" id="L176">            stmt.setTimestamp(5, Timestamp.valueOf(sms.getCreatedAt()));</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">            stmt.setTimestamp(6, sms.getDeliveredAt() != null ? </span>
<span class="nc" id="L178">                Timestamp.valueOf(sms.getDeliveredAt()) : null);</span>
<span class="nc" id="L179">            stmt.setBigDecimal(7, sms.getCost());</span>
<span class="nc" id="L180">            stmt.setString(8, sms.getProvider());</span>
            
<span class="nc" id="L182">            stmt.executeUpdate();</span>
            
<span class="nc" id="L184">            try (ResultSet keys = stmt.getGeneratedKeys()) {</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">                if (keys.next()) {</span>
<span class="nc" id="L186">                    sms.setId(String.valueOf(keys.getLong(1)));</span>
                }
            }
        }
<span class="nc" id="L190">    }</span>
    
    /**
     * Execute 2-level partitioned query using Query DSL
     */
    public &lt;R&gt; List&lt;R&gt; executePartitionedQuery(QueryDSL.FromBuilder queryBuilder,
                                              LocalDateTime startDate,
                                              LocalDateTime endDate,
                                              Object[] parameters,
                                              ResultMapper&lt;R&gt; mapper) throws SQLException {
        // Build partitioned query
<span class="nc" id="L201">        String partitionedQuery = queryBuilder.buildPartitioned(database, startDate, endDate);</span>
        
        // Execute query - buildPartitioned() embeds parameters, so pass null
<span class="nc" id="L204">        return executeQuery(partitionedQuery, null, mapper);</span>
    }
    
    /**
     * Find SMS by date range using 2-level query
     */
    public List&lt;SmsEntity&gt; findByDateRange(LocalDateTime startDate, LocalDateTime endDate) throws SQLException {
<span class="nc" id="L211">        String query = QueryDSL.select()</span>
<span class="nc" id="L212">            .column(&quot;*&quot;)</span>
<span class="nc" id="L213">            .from(tablePrefix)</span>
<span class="nc" id="L214">            .where(w -&gt; w.dateRange(&quot;created_at&quot;, startDate, endDate))</span>
<span class="nc" id="L215">            .buildPartitioned(database, startDate, endDate);</span>
        
<span class="nc" id="L217">        return executeQuery(query, null, this::mapSmsEntity);</span>
    }
    
    /**
     * Find entity by ID across all tables (full table scan)
     * Warning: This may be slow as it searches across all existing tables
     * @param id The ID value to search for
     * @return The found entity or null if not found
     */
    public SmsEntity findById(T id) throws SQLException {
<span class="nc" id="L227">        return findById(&quot;id&quot;, id);</span>
    }
    
    /**
     * Find entity by ID column value across all tables (full table scan)
     * Warning: This may be slow as it searches across all existing tables
     * 
     * @param idColumnName The name of the ID column to search by
     * @param value The value to search for
     * @return The found entity or null if not found
     */
    private SmsEntity findById(String idColumnName, T value) throws SQLException {
        // Get all existing tables
<span class="nc" id="L240">        List&lt;String&gt; existingTables = getExistingTables();</span>
        
<span class="nc bnc" id="L242" title="All 2 branches missed.">        if (existingTables.isEmpty()) {</span>
<span class="nc" id="L243">            return null;</span>
        }
        
        // Build UNION ALL query across all tables
<span class="nc" id="L247">        StringBuilder queryBuilder = new StringBuilder();</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">        for (int i = 0; i &lt; existingTables.size(); i++) {</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">            if (i &gt; 0) {</span>
<span class="nc" id="L250">                queryBuilder.append(&quot; UNION ALL &quot;);</span>
            }
<span class="nc" id="L252">            queryBuilder.append(&quot;SELECT * FROM &quot;).append(existingTables.get(i))</span>
<span class="nc" id="L253">                       .append(&quot; WHERE &quot;).append(idColumnName).append(&quot; = &quot;);</span>
            
            // Format value based on type
<span class="nc bnc" id="L256" title="All 2 branches missed.">            if (value instanceof String) {</span>
<span class="nc" id="L257">                queryBuilder.append(&quot;'&quot;).append(value).append(&quot;'&quot;);</span>
            } else {
<span class="nc" id="L259">                queryBuilder.append(value);</span>
            }
        }
        
<span class="nc" id="L263">        queryBuilder.append(&quot; LIMIT 1&quot;);</span>
        
<span class="nc" id="L265">        List&lt;SmsEntity&gt; results = executeQuery(queryBuilder.toString(), null, this::mapSmsEntity);</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">        return results.isEmpty() ? null : results.get(0);</span>
    }
    
    /**
     * Find all entities by ID column value across all tables (full table scan)
     * Useful when ID column is not unique across tables or when searching by non-primary key
     * @param idColumnName The name of the ID column to search by
     * @param value The value to search for
     * @return List of found entities
     */
    public List&lt;SmsEntity&gt; findAllById(String idColumnName, T value) throws SQLException {
        // Get all existing tables
<span class="nc" id="L278">        List&lt;String&gt; existingTables = getExistingTables();</span>
        
<span class="nc bnc" id="L280" title="All 2 branches missed.">        if (existingTables.isEmpty()) {</span>
<span class="nc" id="L281">            return new ArrayList&lt;&gt;();</span>
        }
        
        // Build UNION ALL query across all tables
<span class="nc" id="L285">        StringBuilder queryBuilder = new StringBuilder();</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">        for (int i = 0; i &lt; existingTables.size(); i++) {</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">            if (i &gt; 0) {</span>
<span class="nc" id="L288">                queryBuilder.append(&quot; UNION ALL &quot;);</span>
            }
<span class="nc" id="L290">            queryBuilder.append(&quot;SELECT * FROM &quot;).append(existingTables.get(i))</span>
<span class="nc" id="L291">                       .append(&quot; WHERE &quot;).append(idColumnName).append(&quot; = &quot;);</span>
            
            // Format value based on type
<span class="nc bnc" id="L294" title="All 2 branches missed.">            if (value instanceof String) {</span>
<span class="nc" id="L295">                queryBuilder.append(&quot;'&quot;).append(value).append(&quot;'&quot;);</span>
            } else {
<span class="nc" id="L297">                queryBuilder.append(value);</span>
            }
        }
        
<span class="nc" id="L301">        return executeQuery(queryBuilder.toString(), null, this::mapSmsEntity);</span>
    }
    
    /**
     * Count SMS in date range
     */
    public long countByDateRange(LocalDateTime startDate, LocalDateTime endDate) throws SQLException {
<span class="nc" id="L308">        String query = QueryDSL.select()</span>
<span class="nc" id="L309">            .count(&quot;*&quot;, &quot;total_count&quot;)</span>
<span class="nc" id="L310">            .from(tablePrefix)</span>
<span class="nc" id="L311">            .where(w -&gt; w.dateRange(&quot;created_at&quot;, startDate, endDate))</span>
<span class="nc" id="L312">            .buildPartitioned(database, startDate, endDate);</span>
        
<span class="nc" id="L314">        List&lt;Long&gt; results = executeQuery(query, null, </span>
<span class="nc" id="L315">            rs -&gt; rs.getLong(&quot;total_count&quot;));</span>
        
<span class="nc bnc" id="L317" title="All 2 branches missed.">        return results.isEmpty() ? 0 : results.get(0);</span>
    }
    
    /**
     * Get user SMS statistics using 2-level aggregation
     */
    public List&lt;UserSmsStats&gt; getUserStats(LocalDateTime startDate, LocalDateTime endDate, int limit) throws SQLException {
<span class="nc" id="L324">        String query = QueryDSL.select()</span>
<span class="nc" id="L325">            .column(&quot;user_id&quot;)</span>
<span class="nc" id="L326">            .count(&quot;*&quot;, &quot;message_count&quot;)</span>
<span class="nc" id="L327">            .min(&quot;created_at&quot;, &quot;first_message&quot;)</span>
<span class="nc" id="L328">            .max(&quot;created_at&quot;, &quot;last_message&quot;)</span>
<span class="nc" id="L329">            .sum(&quot;LENGTH(message)&quot;, &quot;total_chars&quot;)</span>
<span class="nc" id="L330">            .avg(&quot;LENGTH(message)&quot;, &quot;avg_message_length&quot;)</span>
<span class="nc" id="L331">            .sum(&quot;cost&quot;, &quot;total_cost&quot;)</span>
<span class="nc" id="L332">            .from(tablePrefix)</span>
<span class="nc" id="L333">            .where(w -&gt; w</span>
<span class="nc" id="L334">                .dateRange(&quot;created_at&quot;, startDate, endDate)</span>
<span class="nc" id="L335">                .isNotNull(&quot;user_id&quot;))</span>
<span class="nc" id="L336">            .groupBy(&quot;user_id&quot;)</span>
<span class="nc" id="L337">            .orderByDesc(&quot;message_count&quot;)</span>
<span class="nc" id="L338">            .limit(limit)</span>
<span class="nc" id="L339">            .buildPartitioned(database, startDate, endDate);</span>
        
<span class="nc" id="L341">        return executeQuery(query, null, rs -&gt; new UserSmsStats(</span>
<span class="nc" id="L342">            rs.getString(&quot;user_id&quot;),</span>
<span class="nc" id="L343">            rs.getLong(&quot;message_count&quot;),</span>
<span class="nc" id="L344">            rs.getTimestamp(&quot;first_message&quot;).toLocalDateTime(),</span>
<span class="nc" id="L345">            rs.getTimestamp(&quot;last_message&quot;).toLocalDateTime(),</span>
<span class="nc" id="L346">            rs.getLong(&quot;total_chars&quot;),</span>
<span class="nc" id="L347">            rs.getDouble(&quot;avg_message_length&quot;),</span>
<span class="nc" id="L348">            rs.getBigDecimal(&quot;total_cost&quot;)</span>
        ));
    }
    
    /**
     * Get hourly SMS statistics across partitions
     */
    public List&lt;HourlyStats&gt; getHourlyStats(LocalDateTime startDate, LocalDateTime endDate) throws SQLException {
<span class="nc" id="L356">        String query = QueryDSL.select()</span>
<span class="nc" id="L357">            .column(&quot;DATE_FORMAT(created_at, '%Y-%m-%d %H:00')&quot;, &quot;hour&quot;)</span>
<span class="nc" id="L358">            .count(&quot;*&quot;, &quot;message_count&quot;)</span>
<span class="nc" id="L359">            .aggregate(QueryDSL.AggregateFunction.COUNT, &quot;user_id&quot;, &quot;unique_users&quot;, true)</span>
<span class="nc" id="L360">            .sum(&quot;CASE WHEN status = 'SENT' THEN 1 ELSE 0 END&quot;, &quot;sent_count&quot;)</span>
<span class="nc" id="L361">            .sum(&quot;CASE WHEN status = 'FAILED' THEN 1 ELSE 0 END&quot;, &quot;failed_count&quot;)</span>
<span class="nc" id="L362">            .sum(&quot;cost&quot;, &quot;total_cost&quot;)</span>
<span class="nc" id="L363">            .from(tablePrefix)</span>
<span class="nc" id="L364">            .where(w -&gt; w.dateRange(&quot;created_at&quot;, startDate, endDate))</span>
<span class="nc" id="L365">            .groupBy(&quot;DATE_FORMAT(created_at, '%Y-%m-%d %H:00')&quot;)</span>
<span class="nc" id="L366">            .orderByDesc(&quot;hour&quot;)</span>
<span class="nc" id="L367">            .limit(24)</span>
<span class="nc" id="L368">            .buildPartitioned(database, startDate, endDate);</span>
        
<span class="nc" id="L370">        return executeQuery(query, null, rs -&gt; new HourlyStats(</span>
<span class="nc" id="L371">            rs.getString(&quot;hour&quot;),</span>
<span class="nc" id="L372">            rs.getLong(&quot;message_count&quot;),</span>
<span class="nc" id="L373">            rs.getLong(&quot;unique_users&quot;),</span>
<span class="nc" id="L374">            rs.getLong(&quot;sent_count&quot;),  </span>
<span class="nc" id="L375">            rs.getLong(&quot;failed_count&quot;),</span>
<span class="nc" id="L376">            rs.getBigDecimal(&quot;total_cost&quot;)</span>
        ));
    }
    
    /**
     * Create tables for date range
     */
    public void createTablesForDateRange(LocalDateTime startDate, LocalDateTime endDate) throws SQLException {
<span class="nc" id="L384">        LocalDateTime current = startDate;</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">        while (!current.isAfter(endDate)) {</span>
<span class="nc" id="L386">            createTableIfNotExists(getTableName(current));</span>
<span class="nc" id="L387">            current = current.plusDays(1);</span>
        }
<span class="nc" id="L389">    }</span>
    
    /**
     * Drop old tables outside retention window  
     */
    public void dropOldTables(LocalDateTime cutoffDate) throws SQLException {
<span class="nc bnc" id="L395" title="All 2 branches missed.">        if (!autoManagePartitions) {</span>
<span class="nc" id="L396">            return; // Skip dropping if auto-management is disabled</span>
        }
<span class="nc" id="L398">        String pattern = tablePrefix + &quot;_%&quot;;</span>
        
<span class="nc" id="L400">        try (Connection conn = dataSource.getConnection();</span>
<span class="nc" id="L401">             PreparedStatement stmt = conn.prepareStatement(</span>
                 &quot;SELECT table_name FROM information_schema.tables &quot; +
                 &quot;WHERE table_schema = ? AND table_name LIKE ?&quot;)) {
            
<span class="nc" id="L405">            stmt.setString(1, database);</span>
<span class="nc" id="L406">            stmt.setString(2, pattern);</span>
            
<span class="nc" id="L408">            List&lt;String&gt; tablesToDrop = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L409">            try (ResultSet rs = stmt.executeQuery()) {</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">                while (rs.next()) {</span>
<span class="nc" id="L411">                    String tableName = rs.getString(&quot;table_name&quot;);</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">                    if (isTableOlderThan(tableName, cutoffDate)) {</span>
<span class="nc" id="L413">                        tablesToDrop.add(tableName);</span>
                    }
<span class="nc" id="L415">                }</span>
            }
            
            // Drop old tables
<span class="nc bnc" id="L419" title="All 2 branches missed.">            for (String tableName : tablesToDrop) {</span>
<span class="nc" id="L420">                try (Statement dropStmt = conn.createStatement()) {</span>
<span class="nc" id="L421">                    dropStmt.execute(&quot;DROP TABLE IF EXISTS &quot; + database + &quot;.&quot; + tableName);</span>
<span class="nc" id="L422">                    System.out.println(&quot;Dropped old table: &quot; + tableName);</span>
                }
<span class="nc" id="L424">            }</span>
        }
<span class="nc" id="L426">    }</span>
    
    /**
     * Clean up old tables based on retention period
     */
    public void cleanupOldTables() throws SQLException {
<span class="nc bnc" id="L432" title="All 2 branches missed.">        if (autoManagePartitions) {</span>
<span class="nc" id="L433">            LocalDateTime cutoffDate = LocalDateTime.now().minusDays(partitionRetentionPeriod);</span>
<span class="nc" id="L434">            dropOldTables(cutoffDate);</span>
        }
<span class="nc" id="L436">    }</span>
    
    // Getter methods for configuration
    public int getPartitionRetentionPeriod() {
<span class="nc" id="L440">        return partitionRetentionPeriod;</span>
    }
    
    public boolean isAutoManagePartitions() {
<span class="nc" id="L444">        return autoManagePartitions;</span>
    }
    
    public boolean isInitializePartitionsOnStart() {
<span class="nc" id="L448">        return initializePartitionsOnStart;</span>
    }
    
    public String getDatabase() {
<span class="nc" id="L452">        return database;</span>
    }
    
    public String getTablePrefix() {
<span class="nc" id="L456">        return tablePrefix;</span>
    }
    
    public LocalTime getPartitionAdjustmentTime() {
<span class="nc" id="L460">        return partitionAdjustmentTime;</span>
    }
    
    // Private helper methods
    
    /**
     * Create DataSource with MySQL configuration
     */
    private static DataSource createDataSource(String host, int port, String database, 
                                             String username, String password) {
<span class="nc" id="L470">        return new DataSource() {</span>
            @Override
            public Connection getConnection() throws SQLException {
                // Try MariaDB URL first, then MySQL
<span class="nc" id="L474">                String mariadbUrl = String.format(&quot;jdbc:mariadb://%s:%d/%s?useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=UTC&quot;, </span>
<span class="nc" id="L475">                                         host, port, database);</span>
<span class="nc" id="L476">                String mysqlUrl = String.format(&quot;jdbc:mysql://%s:%d/%s?useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=UTC&quot;, </span>
<span class="nc" id="L477">                                         host, port, database);</span>
                
                try {
<span class="nc" id="L480">                    return DriverManager.getConnection(mariadbUrl, username, password);</span>
<span class="nc" id="L481">                } catch (SQLException e) {</span>
                    // Fallback to MySQL URL
<span class="nc" id="L483">                    return DriverManager.getConnection(mysqlUrl, username, password);</span>
                }
            }
            
            @Override
            public Connection getConnection(String user, String pass) throws SQLException {
<span class="nc" id="L489">                return getConnection();</span>
            }
            
            // Other DataSource methods with default implementations
<span class="nc" id="L493">            @Override public java.io.PrintWriter getLogWriter() throws SQLException { return null; }</span>
<span class="nc" id="L494">            @Override public void setLogWriter(java.io.PrintWriter out) throws SQLException { }</span>
<span class="nc" id="L495">            @Override public void setLoginTimeout(int seconds) throws SQLException { }</span>
<span class="nc" id="L496">            @Override public int getLoginTimeout() throws SQLException { return 0; }</span>
<span class="nc" id="L497">            @Override public java.util.logging.Logger getParentLogger() { return null; }</span>
<span class="nc" id="L498">            @Override public &lt;T&gt; T unwrap(Class&lt;T&gt; iface) throws SQLException { return null; }</span>
<span class="nc" id="L499">            @Override public boolean isWrapperFor(Class&lt;?&gt; iface) throws SQLException { return false; }</span>
        };
    }
    
    /**
     * Get list of all existing tables with the configured prefix
     */
    private List&lt;String&gt; getExistingTables() throws SQLException {
<span class="nc" id="L507">        List&lt;String&gt; tables = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L508">        String pattern = tablePrefix + &quot;_%&quot;;</span>
        
<span class="nc" id="L510">        try (Connection conn = dataSource.getConnection();</span>
<span class="nc" id="L511">             PreparedStatement stmt = conn.prepareStatement(</span>
                 &quot;SELECT table_name FROM information_schema.tables &quot; +
                 &quot;WHERE table_schema = ? AND table_name LIKE ? ORDER BY table_name&quot;)) {
            
<span class="nc" id="L515">            stmt.setString(1, database);</span>
<span class="nc" id="L516">            stmt.setString(2, pattern);</span>
            
<span class="nc" id="L518">            try (ResultSet rs = stmt.executeQuery()) {</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">                while (rs.next()) {</span>
<span class="nc" id="L520">                    String tableName = rs.getString(&quot;table_name&quot;);</span>
<span class="nc" id="L521">                    tables.add(database + &quot;.&quot; + tableName);</span>
<span class="nc" id="L522">                }</span>
            }
        }
        
<span class="nc" id="L526">        return tables;</span>
    }
    
    /**
     * Automatically ensure table exists for the given date
     * Also performs maintenance if auto-management is enabled
     */
    private void ensureTableExistsForDate(LocalDateTime date) throws SQLException {
<span class="nc" id="L534">        String tableName = getTableName(date);</span>
<span class="nc" id="L535">        createTableIfNotExists(tableName);</span>
        
        // Perform automatic maintenance if enabled
<span class="nc bnc" id="L538" title="All 2 branches missed.">        if (autoManagePartitions) {</span>
<span class="nc" id="L539">            performAutomaticMaintenance(date);</span>
        }
<span class="nc" id="L541">    }</span>
    
    /**
     * Perform automatic maintenance tasks
     */
    private void performAutomaticMaintenance(LocalDateTime currentDate) throws SQLException {
        // Create tables for near future dates (next few days)
<span class="nc" id="L548">        LocalDateTime futureDate = currentDate.plusDays(3);</span>
<span class="nc" id="L549">        LocalDateTime current = currentDate;</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">        while (!current.isAfter(futureDate)) {</span>
<span class="nc" id="L551">            createTableIfNotExists(getTableName(current));</span>
<span class="nc" id="L552">            current = current.plusDays(1);</span>
        }
        
        // Clean up old tables based on retention period
<span class="nc" id="L556">        LocalDateTime cutoffDate = currentDate.minusDays(partitionRetentionPeriod);</span>
<span class="nc" id="L557">        dropOldTables(cutoffDate);</span>
<span class="nc" id="L558">    }</span>
    
    /**
     * Start daily scheduler for automatic partition management
     */
    private void startDailyScheduler() {
<span class="nc" id="L564">        LocalDateTime now = LocalDateTime.now();</span>
<span class="nc" id="L565">        LocalDateTime nextRun = now.toLocalDate().atTime(partitionAdjustmentTime);</span>
        
        // If the adjustment time has already passed today, schedule for tomorrow
<span class="nc bnc" id="L568" title="All 4 branches missed.">        if (nextRun.isBefore(now) || nextRun.isEqual(now)) {</span>
<span class="nc" id="L569">            nextRun = nextRun.plusDays(1);</span>
        }
        
<span class="nc" id="L572">        long initialDelayMinutes = java.time.Duration.between(now, nextRun).toMinutes();</span>
        
<span class="nc" id="L574">        System.out.println(&quot; MultiTable Scheduler: Next maintenance at &quot; + nextRun + </span>
                          &quot; (in &quot; + initialDelayMinutes + &quot; minutes)&quot;);
        
<span class="nc" id="L577">        scheduler.scheduleAtFixedRate(() -&gt; {</span>
            try {
<span class="nc" id="L579">                performScheduledMaintenance();</span>
<span class="nc" id="L580">            } catch (Exception e) {</span>
<span class="nc" id="L581">                System.err.println(&quot; MultiTable scheduled maintenance failed: &quot; + e.getMessage());</span>
<span class="nc" id="L582">                e.printStackTrace();</span>
<span class="nc" id="L583">            }</span>
<span class="nc" id="L584">        }, initialDelayMinutes, 24 * 60, TimeUnit.MINUTES); // Run daily</span>
<span class="nc" id="L585">    }</span>
    
    /**
     * Perform scheduled maintenance - creates/drops tables based on retention period
     */
    private void performScheduledMaintenance() throws SQLException {
<span class="nc" id="L591">        LocalDateTime today = LocalDateTime.now();</span>
        
<span class="nc" id="L593">        System.out.println(&quot; MultiTable scheduled maintenance started at &quot; + today);</span>
        
        // Calculate the valid range: {today - retentionDays} to {today + retentionDays}
<span class="nc" id="L596">        LocalDateTime startRange = today.minusDays(partitionRetentionPeriod);</span>
<span class="nc" id="L597">        LocalDateTime endRange = today.plusDays(partitionRetentionPeriod);</span>
        
<span class="nc" id="L599">        System.out.println(&quot; Valid table range: &quot; + startRange.toLocalDate() + &quot; to &quot; + endRange.toLocalDate());</span>
        
        // Create missing tables in the valid range
<span class="nc" id="L602">        createTablesForDateRange(startRange, endRange);</span>
        
        // Drop tables outside the valid range (older than startRange)
<span class="nc" id="L605">        dropOldTables(startRange);</span>
        
<span class="nc" id="L607">        System.out.println(&quot; MultiTable scheduled maintenance completed&quot;);</span>
<span class="nc" id="L608">    }</span>
    
    /**
     * Shutdown the scheduler (call this when application stops)
     */
    public void shutdown() {
<span class="nc bnc" id="L614" title="All 4 branches missed.">        if (scheduler != null &amp;&amp; !scheduler.isShutdown()) {</span>
<span class="nc" id="L615">            scheduler.shutdown();</span>
            try {
<span class="nc bnc" id="L617" title="All 2 branches missed.">                if (!scheduler.awaitTermination(10, TimeUnit.SECONDS)) {</span>
<span class="nc" id="L618">                    scheduler.shutdownNow();</span>
                }
<span class="nc" id="L620">            } catch (InterruptedException e) {</span>
<span class="nc" id="L621">                scheduler.shutdownNow();</span>
<span class="nc" id="L622">                Thread.currentThread().interrupt();</span>
<span class="nc" id="L623">            }</span>
        }
<span class="nc" id="L625">    }</span>
    
    private String getTableName(LocalDateTime date) {
<span class="nc" id="L628">        return database + &quot;.&quot; + tablePrefix + &quot;_&quot; + date.format(DATE_FORMAT);</span>
    }
    
    private void createTableIfNotExists(String tableName) throws SQLException {
<span class="nc" id="L632">        String createSQL = &quot;CREATE TABLE IF NOT EXISTS &quot; + tableName + &quot; (&quot; +</span>
            &quot;id BIGINT AUTO_INCREMENT PRIMARY KEY, &quot; +
            &quot;user_id VARCHAR(50), &quot; +
            &quot;phone_number VARCHAR(20), &quot; +
            &quot;message TEXT, &quot; +
            &quot;status VARCHAR(20), &quot; +
            &quot;created_at DATETIME NOT NULL, &quot; +
            &quot;delivered_at DATETIME, &quot; +
            &quot;cost DECIMAL(10,4), &quot; +
            &quot;provider VARCHAR(50), &quot; +
            &quot;INDEX idx_created_at (created_at), &quot; +
            &quot;INDEX idx_user_id (user_id), &quot; +
            &quot;INDEX idx_status (status)&quot; +
            &quot;) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4&quot;;
        
<span class="nc" id="L647">        try (Connection conn = dataSource.getConnection();</span>
<span class="nc" id="L648">             Statement stmt = conn.createStatement()) {</span>
<span class="nc" id="L649">            stmt.execute(createSQL);</span>
        }
<span class="nc" id="L651">    }</span>
    
    private boolean isTableOlderThan(String tableName, LocalDateTime cutoffDate) {
<span class="nc" id="L654">        String[] parts = tableName.split(&quot;_&quot;);</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">        if (parts.length &lt; 2) return false;</span>
        
        try {
<span class="nc" id="L658">            String dateStr = parts[parts.length - 1];</span>
<span class="nc" id="L659">            LocalDateTime tableDate = LocalDateTime.parse(dateStr + &quot;000000&quot;, </span>
<span class="nc" id="L660">                DateTimeFormatter.ofPattern(&quot;yyyyMMddHHmmss&quot;));</span>
<span class="nc" id="L661">            return tableDate.isBefore(cutoffDate);</span>
<span class="nc" id="L662">        } catch (Exception e) {</span>
<span class="nc" id="L663">            return false;</span>
        }
    }
    
    private &lt;R&gt; List&lt;R&gt; executeQuery(String sql, Object[] parameters, ResultMapper&lt;R&gt; mapper) throws SQLException {
<span class="nc" id="L668">        List&lt;R&gt; results = new ArrayList&lt;&gt;();</span>
        
<span class="nc" id="L670">        try (Connection conn = dataSource.getConnection();</span>
<span class="nc" id="L671">             PreparedStatement stmt = conn.prepareStatement(sql)) {</span>
            
<span class="nc bnc" id="L673" title="All 2 branches missed.">            if (parameters != null) {</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">                for (int i = 0; i &lt; parameters.length; i++) {</span>
<span class="nc" id="L675">                    setParameter(stmt, i + 1, parameters[i]);</span>
                }
            }
            
<span class="nc" id="L679">            try (ResultSet rs = stmt.executeQuery()) {</span>
<span class="nc bnc" id="L680" title="All 2 branches missed.">                while (rs.next()) {</span>
<span class="nc" id="L681">                    results.add(mapper.map(rs));</span>
                }
            }
        }
        
<span class="nc" id="L686">        return results;</span>
    } 
    
    private void setParameter(PreparedStatement stmt, int index, Object value) throws SQLException {
<span class="nc bnc" id="L690" title="All 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L691">            stmt.setNull(index, Types.NULL);</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">        } else if (value instanceof String) {</span>
<span class="nc" id="L693">            stmt.setString(index, (String) value);</span>
<span class="nc bnc" id="L694" title="All 2 branches missed.">        } else if (value instanceof LocalDateTime) {</span>
<span class="nc" id="L695">            stmt.setTimestamp(index, Timestamp.valueOf((LocalDateTime) value));</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">        } else if (value instanceof Integer) {</span>
<span class="nc" id="L697">            stmt.setInt(index, (Integer) value);</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">        } else if (value instanceof Long) {</span>
<span class="nc" id="L699">            stmt.setLong(index, (Long) value);</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">        } else if (value instanceof BigDecimal) {</span>
<span class="nc" id="L701">            stmt.setBigDecimal(index, (BigDecimal) value);</span>
        } else {
<span class="nc" id="L703">            stmt.setObject(index, value);</span>
        }
<span class="nc" id="L705">    }</span>
    
    private SmsEntity mapSmsEntity(ResultSet rs) throws SQLException {
<span class="nc" id="L708">        SmsEntity sms = new SmsEntity();</span>
<span class="nc" id="L709">        sms.setId(String.valueOf(rs.getLong(&quot;id&quot;)));</span>
<span class="nc" id="L710">        sms.setUserId(rs.getString(&quot;user_id&quot;));</span>
<span class="nc" id="L711">        sms.setPhoneNumber(rs.getString(&quot;phone_number&quot;));</span>
<span class="nc" id="L712">        sms.setMessage(rs.getString(&quot;message&quot;));</span>
<span class="nc" id="L713">        sms.setStatus(rs.getString(&quot;status&quot;));</span>
<span class="nc" id="L714">        sms.setCreatedAt(rs.getTimestamp(&quot;created_at&quot;).toLocalDateTime());</span>
        
<span class="nc" id="L716">        Timestamp delivered = rs.getTimestamp(&quot;delivered_at&quot;);</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">        sms.setDeliveredAt(delivered != null ? delivered.toLocalDateTime() : null);</span>
        
<span class="nc" id="L719">        sms.setCost(rs.getBigDecimal(&quot;cost&quot;));</span>
<span class="nc" id="L720">        sms.setProvider(rs.getString(&quot;provider&quot;));</span>
        
<span class="nc" id="L722">        return sms;</span>
    }
    
    // Result classes
    public static class UserSmsStats {
        public final String userId;
        public final long messageCount;
        public final LocalDateTime firstMessage;
        public final LocalDateTime lastMessage;
        public final long totalChars;
        public final double avgMessageLength;
        public final BigDecimal totalCost;
        
        public UserSmsStats(String userId, long messageCount, LocalDateTime firstMessage,
                           LocalDateTime lastMessage, long totalChars, double avgMessageLength,
<span class="nc" id="L737">                           BigDecimal totalCost) {</span>
<span class="nc" id="L738">            this.userId = userId;</span>
<span class="nc" id="L739">            this.messageCount = messageCount;</span>
<span class="nc" id="L740">            this.firstMessage = firstMessage;</span>
<span class="nc" id="L741">            this.lastMessage = lastMessage;</span>
<span class="nc" id="L742">            this.totalChars = totalChars;</span>
<span class="nc" id="L743">            this.avgMessageLength = avgMessageLength;</span>
<span class="nc" id="L744">            this.totalCost = totalCost;</span>
<span class="nc" id="L745">        }</span>
        
        @Override
        public String toString() {
<span class="nc" id="L749">            return String.format(&quot;User: %s | Messages: %d | Cost: $%s | Avg Length: %.1f chars&quot;,</span>
<span class="nc" id="L750">                userId, messageCount, totalCost, avgMessageLength);</span>
        }
    }
    
    public static class HourlyStats {
        public final String hour;
        public final long messageCount;
        public final long uniqueUsers;
        public final long sentCount;
        public final long failedCount;
        public final BigDecimal totalCost;
        public final double successRate;
        
        public HourlyStats(String hour, long messageCount, long uniqueUsers,
<span class="nc" id="L764">                          long sentCount, long failedCount, BigDecimal totalCost) {</span>
<span class="nc" id="L765">            this.hour = hour;</span>
<span class="nc" id="L766">            this.messageCount = messageCount;</span>
<span class="nc" id="L767">            this.uniqueUsers = uniqueUsers;</span>
<span class="nc" id="L768">            this.sentCount = sentCount;</span>
<span class="nc" id="L769">            this.failedCount = failedCount;</span>
<span class="nc" id="L770">            this.totalCost = totalCost;</span>
<span class="nc bnc" id="L771" title="All 2 branches missed.">            this.successRate = messageCount &gt; 0 ? (double) sentCount / messageCount * 100 : 0;</span>
<span class="nc" id="L772">        }</span>
        
        @Override
        public String toString() {
<span class="nc" id="L776">            return String.format(&quot;Hour: %s | Messages: %d | Users: %d | Success: %.1f%% | Cost: $%s&quot;,</span>
<span class="nc" id="L777">                hour, messageCount, uniqueUsers, successRate, totalCost);</span>
        }
    }
    
    @FunctionalInterface
    public interface ResultMapper&lt;R&gt; {
        R map(ResultSet rs) throws SQLException;
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>