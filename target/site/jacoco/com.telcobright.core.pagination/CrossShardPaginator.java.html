<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CrossShardPaginator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Generic Sharding-Aware Repository Framework</a> &gt; <a href="index.source.html" class="el_package">com.telcobright.core.pagination</a> &gt; <span class="el_source">CrossShardPaginator.java</span></div><h1>CrossShardPaginator.java</h1><pre class="source lang-java linenums">package com.telcobright.core.pagination;

import com.telcobright.core.entity.ShardingEntity;
import com.telcobright.core.query.SortExpression;
import com.telcobright.core.logging.Logger;
import com.telcobright.core.logging.ConsoleLogger;

import java.util.*;
import java.util.concurrent.*;
import java.util.stream.Collectors;
import java.lang.reflect.Method;

/**
 * Handles pagination across multiple shards with proper sorting and memory management
 *
 * Algorithm:
 * 1. Query each shard for up to maxResultCount records
 * 2. Merge all results maintaining sort order
 * 3. Apply pagination to get the requested page
 *
 * For example, if we need 100 records in page 2 (0-based):
 * - Fetch up to maxResultCount from each shard
 * - Merge and sort all results
 * - Skip first 200 records (page 0: 0-99, page 1: 100-199)
 * - Return next 100 records (page 2: 200-299)
 */
<span class="nc" id="L27">public class CrossShardPaginator&lt;T extends ShardingEntity&lt;?&gt;&gt; {</span>

<span class="nc" id="L29">    private static final Logger logger = new ConsoleLogger(&quot;CrossShardPaginator&quot;);</span>

    /**
     * Execute paginated query across multiple shards
     */
    public static &lt;T extends ShardingEntity&lt;?&gt;&gt; List&lt;T&gt; paginateAcrossShards(
            Map&lt;String, Callable&lt;List&lt;T&gt;&gt;&gt; shardQueries,
            PaginationConfig config,
            ExecutorService executor) throws Exception {

        // Step 1: Fetch data from all shards in parallel
<span class="nc" id="L40">        logger.info(String.format(</span>
            &quot;Fetching data from %d shards for page %d (size %d)&quot;,
<span class="nc" id="L42">            shardQueries.size(), config.getPageNumber(), config.getPageSize()</span>
        ));

<span class="nc" id="L45">        List&lt;Future&lt;List&lt;T&gt;&gt;&gt; futures = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L46" title="All 2 branches missed.">        for (Map.Entry&lt;String, Callable&lt;List&lt;T&gt;&gt;&gt; entry : shardQueries.entrySet()) {</span>
<span class="nc" id="L47">            String shardId = entry.getKey();</span>
<span class="nc" id="L48">            Callable&lt;List&lt;T&gt;&gt; query = entry.getValue();</span>

<span class="nc" id="L50">            Future&lt;List&lt;T&gt;&gt; future = executor.submit(() -&gt; {</span>
                try {
<span class="nc" id="L52">                    List&lt;T&gt; result = query.call();</span>
<span class="nc" id="L53">                    logger.info(String.format(&quot;Shard %s returned %d records&quot;, shardId, result.size()));</span>
<span class="nc" id="L54">                    return result;</span>
<span class="nc" id="L55">                } catch (Exception e) {</span>
<span class="nc" id="L56">                    logger.error(&quot;Error querying shard &quot; + shardId + &quot;: &quot; + e.getMessage());</span>
<span class="nc" id="L57">                    return new ArrayList&lt;&gt;();</span>
                }
            });
<span class="nc" id="L60">            futures.add(future);</span>
<span class="nc" id="L61">        }</span>

        // Step 2: Collect all results
<span class="nc" id="L64">        List&lt;T&gt; allResults = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L65">        int totalRecords = 0;</span>

<span class="nc bnc" id="L67" title="All 2 branches missed.">        for (Future&lt;List&lt;T&gt;&gt; future : futures) {</span>
<span class="nc" id="L68">            List&lt;T&gt; shardResults = future.get(30, TimeUnit.SECONDS); // 30 second timeout per shard</span>
<span class="nc" id="L69">            allResults.addAll(shardResults);</span>
<span class="nc" id="L70">            totalRecords += shardResults.size();</span>

            // Stop if we've hit the max result count
<span class="nc bnc" id="L73" title="All 2 branches missed.">            if (totalRecords &gt;= config.getMaxResultCount()) {</span>
<span class="nc" id="L74">                logger.warn(String.format(</span>
                    &quot;Hit maxResultCount limit of %d. Truncating results.&quot;,
<span class="nc" id="L76">                    config.getMaxResultCount()</span>
                ));
<span class="nc" id="L78">                allResults = allResults.subList(0, config.getMaxResultCount());</span>
<span class="nc" id="L79">                break;</span>
            }
<span class="nc" id="L81">        }</span>

<span class="nc" id="L83">        logger.info(String.format(&quot;Collected %d total records from all shards&quot;, allResults.size()));</span>

        // Step 3: Sort the combined results
<span class="nc bnc" id="L86" title="All 2 branches missed.">        if (config.getSortExpression() != null) {</span>
<span class="nc" id="L87">            sortResults(allResults, config.getSortExpression());</span>
        }

        // Step 4: Apply pagination
<span class="nc" id="L91">        int startIndex = config.getStartIndex();</span>
<span class="nc" id="L92">        int endIndex = Math.min(config.getEndIndex(), allResults.size());</span>

<span class="nc bnc" id="L94" title="All 2 branches missed.">        if (startIndex &gt;= allResults.size()) {</span>
<span class="nc" id="L95">            logger.info(String.format(</span>
                &quot;Page %d is beyond available results (total: %d)&quot;,
<span class="nc" id="L97">                config.getPageNumber(), allResults.size()</span>
            ));
<span class="nc" id="L99">            return new ArrayList&lt;&gt;();</span>
        }

<span class="nc" id="L102">        List&lt;T&gt; pageResults = allResults.subList(startIndex, endIndex);</span>

<span class="nc" id="L104">        logger.info(String.format(</span>
            &quot;Returning page %d: records %d-%d of %d total&quot;,
<span class="nc" id="L106">            config.getPageNumber(), startIndex, endIndex - 1, allResults.size()</span>
        ));

<span class="nc" id="L109">        return new ArrayList&lt;&gt;(pageResults); // Return a copy to avoid subList issues</span>
    }

    /**
     * Sort results based on sort expression
     */
    private static &lt;T&gt; void sortResults(List&lt;T&gt; results, SortExpression sortExpression) {
<span class="nc bnc" id="L116" title="All 2 branches missed.">        if (sortExpression.getSortFields().isEmpty()) {</span>
<span class="nc" id="L117">            return;</span>
        }

<span class="nc" id="L120">        Comparator&lt;T&gt; comparator = null;</span>

<span class="nc bnc" id="L122" title="All 2 branches missed.">        for (SortExpression.SortField sortField : sortExpression.getSortFields()) {</span>
<span class="nc" id="L123">            Comparator&lt;T&gt; fieldComparator = createFieldComparator(sortField);</span>

<span class="nc bnc" id="L125" title="All 2 branches missed.">            if (comparator == null) {</span>
<span class="nc" id="L126">                comparator = fieldComparator;</span>
            } else {
<span class="nc" id="L128">                comparator = comparator.thenComparing(fieldComparator);</span>
            }
<span class="nc" id="L130">        }</span>

<span class="nc bnc" id="L132" title="All 2 branches missed.">        if (comparator != null) {</span>
<span class="nc" id="L133">            results.sort(comparator);</span>
        }
<span class="nc" id="L135">    }</span>

    /**
     * Create a comparator for a specific field
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private static &lt;T&gt; Comparator&lt;T&gt; createFieldComparator(SortExpression.SortField sortField) {
<span class="nc" id="L142">        return (o1, o2) -&gt; {</span>
            try {
                // Get the field value using reflection
<span class="nc" id="L145">                Object value1 = getFieldValue(o1, sortField.getFieldName());</span>
<span class="nc" id="L146">                Object value2 = getFieldValue(o2, sortField.getFieldName());</span>

                // Handle nulls
<span class="nc bnc" id="L149" title="All 4 branches missed.">                if (value1 == null &amp;&amp; value2 == null) return 0;</span>
<span class="nc bnc" id="L150" title="All 4 branches missed.">                if (value1 == null) return sortField.getOrder() == SortExpression.SortOrder.ASC ? -1 : 1;</span>
<span class="nc bnc" id="L151" title="All 4 branches missed.">                if (value2 == null) return sortField.getOrder() == SortExpression.SortOrder.ASC ? 1 : -1;</span>

                // Compare values
                int comparison;
<span class="nc bnc" id="L155" title="All 2 branches missed.">                if (value1 instanceof Comparable) {</span>
<span class="nc" id="L156">                    comparison = ((Comparable) value1).compareTo(value2);</span>
                } else {
<span class="nc" id="L158">                    comparison = value1.toString().compareTo(value2.toString());</span>
                }

                // Apply sort order
<span class="nc bnc" id="L162" title="All 2 branches missed.">                return sortField.getOrder() == SortExpression.SortOrder.ASC ? comparison : -comparison;</span>

<span class="nc" id="L164">            } catch (Exception e) {</span>
<span class="nc" id="L165">                logger.error(&quot;Error comparing field &quot; + sortField.getFieldName() + &quot;: &quot; + e.getMessage());</span>
<span class="nc" id="L166">                return 0;</span>
            }
        };
    }

    /**
     * Get field value using reflection
     */
    private static Object getFieldValue(Object obj, String fieldName) throws Exception {
        // Try direct field access first
<span class="nc" id="L176">        String getterName = &quot;get&quot; + Character.toUpperCase(fieldName.charAt(0)) + fieldName.substring(1);</span>

        try {
<span class="nc" id="L179">            Method method = obj.getClass().getMethod(getterName);</span>
<span class="nc" id="L180">            return method.invoke(obj);</span>
<span class="nc" id="L181">        } catch (NoSuchMethodException e) {</span>
            // Try with &quot;is&quot; prefix for boolean
<span class="nc" id="L183">            String isGetterName = &quot;is&quot; + Character.toUpperCase(fieldName.charAt(0)) + fieldName.substring(1);</span>
            try {
<span class="nc" id="L185">                Method method = obj.getClass().getMethod(isGetterName);</span>
<span class="nc" id="L186">                return method.invoke(obj);</span>
<span class="nc" id="L187">            } catch (NoSuchMethodException e2) {</span>
                // Try direct field name as getter (e.g., for &quot;id&quot; -&gt; &quot;getId&quot;)
<span class="nc bnc" id="L189" title="All 2 branches missed.">                if (fieldName.equals(&quot;id&quot;)) {</span>
<span class="nc" id="L190">                    Method method = obj.getClass().getMethod(&quot;getId&quot;);</span>
<span class="nc" id="L191">                    return method.invoke(obj);</span>
                }
<span class="nc" id="L193">                throw new NoSuchMethodException(&quot;No getter found for field: &quot; + fieldName);</span>
            }
        }
    }

    /**
     * Calculate total pages available
     */
    public static int calculateTotalPages(int totalRecords, int pageSize) {
<span class="nc" id="L202">        return (totalRecords + pageSize - 1) / pageSize;</span>
    }

    /**
     * Create a page info object with metadata
     */
    public static PageInfo createPageInfo(int pageNumber, int pageSize, int totalRecords) {
<span class="nc" id="L209">        return new PageInfo(</span>
            pageNumber,
            pageSize,
            totalRecords,
<span class="nc bnc" id="L213" title="All 4 branches missed.">            calculateTotalPages(totalRecords, pageSize),</span>
            pageNumber &gt; 0,
            (pageNumber + 1) * pageSize &lt; totalRecords
        );
    }

    /**
     * Page metadata
     */
    public static class PageInfo {
        public final int pageNumber;
        public final int pageSize;
        public final int totalRecords;
        public final int totalPages;
        public final boolean hasPrevious;
        public final boolean hasNext;

        public PageInfo(int pageNumber, int pageSize, int totalRecords,
<span class="nc" id="L231">                       int totalPages, boolean hasPrevious, boolean hasNext) {</span>
<span class="nc" id="L232">            this.pageNumber = pageNumber;</span>
<span class="nc" id="L233">            this.pageSize = pageSize;</span>
<span class="nc" id="L234">            this.totalRecords = totalRecords;</span>
<span class="nc" id="L235">            this.totalPages = totalPages;</span>
<span class="nc" id="L236">            this.hasPrevious = hasPrevious;</span>
<span class="nc" id="L237">            this.hasNext = hasNext;</span>
<span class="nc" id="L238">        }</span>

        @Override
        public String toString() {
<span class="nc" id="L242">            return String.format(</span>
                &quot;Page %d of %d (size: %d, total records: %d, has prev: %s, has next: %s)&quot;,
<span class="nc" id="L244">                pageNumber + 1, totalPages, pageSize, totalRecords, hasPrevious, hasNext</span>
            );
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>