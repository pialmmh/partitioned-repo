<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SqlGeneratorByEntityRegistry.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Generic Sharding-Aware Repository Framework</a> &gt; <a href="index.source.html" class="el_package">com.telcobright.core.sql</a> &gt; <span class="el_source">SqlGeneratorByEntityRegistry.java</span></div><h1>SqlGeneratorByEntityRegistry.java</h1><pre class="source lang-java linenums">package com.telcobright.core.sql;

import com.telcobright.core.entity.ShardingEntity;
import com.telcobright.core.metadata.EntityMetadata;
import com.telcobright.core.metadata.FieldMetadata;
import com.telcobright.core.persistence.PersistenceProvider;
import com.telcobright.core.logging.Logger;
import com.telcobright.core.logging.ConsoleLogger;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

/**
 * Registry for pre-generating and caching SQL statements for entities.
 * Generates SQL for common batch sizes at startup to avoid runtime overhead.
 *
 * @author Split-Verse Framework
 */
public class SqlGeneratorByEntityRegistry {

<span class="nc" id="L22">    private final Map&lt;Class&lt;?&gt;, EntityMetadata&lt;?&gt;&gt; entityMetadataMap = new ConcurrentHashMap&lt;&gt;();</span>
<span class="nc" id="L23">    private final Map&lt;PersistenceProvider.DatabaseType, SqlStatementCache&gt; cacheByDatabase = new ConcurrentHashMap&lt;&gt;();</span>
    private final Logger logger;
    private SqlStatementCache cache;

    // Common batch sizes to pre-generate
<span class="nc" id="L28">    private static final int[] BATCH_SIZES = {10, 100, 1000, 5000};</span>

    // Singleton instance
    private static SqlGeneratorByEntityRegistry instance;

<span class="nc" id="L33">    public SqlGeneratorByEntityRegistry() {</span>
<span class="nc" id="L34">        this.logger = new ConsoleLogger(&quot;SqlGeneratorRegistry&quot;);</span>
<span class="nc" id="L35">        this.cache = new SqlStatementCache();</span>
<span class="nc" id="L36">    }</span>

<span class="nc" id="L38">    public SqlGeneratorByEntityRegistry(SqlStatementCache cache) {</span>
<span class="nc" id="L39">        this.logger = new ConsoleLogger(&quot;SqlGeneratorRegistry&quot;);</span>
<span class="nc" id="L40">        this.cache = cache;</span>
<span class="nc" id="L41">    }</span>

    public SqlStatementCache getCache() {
<span class="nc" id="L44">        return cache;</span>
    }

    public void setCache(SqlStatementCache cache) {
<span class="nc" id="L48">        this.cache = cache;</span>
<span class="nc" id="L49">    }</span>

    /**
     * Get singleton instance
     */
    public static synchronized SqlGeneratorByEntityRegistry getInstance() {
<span class="nc bnc" id="L55" title="All 2 branches missed.">        if (instance == null) {</span>
<span class="nc" id="L56">            instance = new SqlGeneratorByEntityRegistry();</span>
        }
<span class="nc" id="L58">        return instance;</span>
    }

    /**
     * Register an entity class for SQL pre-generation
     */
    public &lt;T extends ShardingEntity&gt; void registerEntity(Class&lt;T&gt; entityClass) {
<span class="nc bnc" id="L65" title="All 2 branches missed.">        if (entityMetadataMap.containsKey(entityClass)) {</span>
<span class="nc" id="L66">            logger.debug(&quot;Entity already registered: &quot; + entityClass.getSimpleName());</span>
<span class="nc" id="L67">            return;</span>
        }

<span class="nc" id="L70">        EntityMetadata&lt;T&gt; metadata = new EntityMetadata&lt;&gt;(entityClass);</span>
<span class="nc" id="L71">        entityMetadataMap.put(entityClass, metadata);</span>

<span class="nc" id="L73">        logger.info(&quot;Registered entity for SQL generation: &quot; + entityClass.getSimpleName());</span>
<span class="nc" id="L74">    }</span>

    /**
     * Pre-generate SQL for all registered entities and specified tables
     */
    public void pregenerateForTables(PersistenceProvider.DatabaseType dbType,
                                    Map&lt;Class&lt;?&gt;, List&lt;String&gt;&gt; entityTableMap) {
        // Use provided cache or create one for the database type
<span class="nc bnc" id="L82" title="All 2 branches missed.">        if (cache == null) {</span>
<span class="nc" id="L83">            cache = cacheByDatabase.computeIfAbsent(dbType, k -&gt; new SqlStatementCache());</span>
        }

<span class="nc bnc" id="L86" title="All 2 branches missed.">        for (Map.Entry&lt;Class&lt;?&gt;, List&lt;String&gt;&gt; entry : entityTableMap.entrySet()) {</span>
<span class="nc" id="L87">            Class&lt;?&gt; entityClass = entry.getKey();</span>
<span class="nc" id="L88">            List&lt;String&gt; tableNames = entry.getValue();</span>

<span class="nc" id="L90">            EntityMetadata&lt;?&gt; metadata = entityMetadataMap.get(entityClass);</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">            if (metadata == null) {</span>
<span class="nc" id="L92">                registerEntity((Class&lt;? extends ShardingEntity&gt;) entityClass);</span>
<span class="nc" id="L93">                metadata = entityMetadataMap.get(entityClass);</span>
            }

<span class="nc bnc" id="L96" title="All 2 branches missed.">            for (String tableName : tableNames) {</span>
<span class="nc" id="L97">                pregenerateForTable(dbType, entityClass, tableName, metadata, cache);</span>
<span class="nc" id="L98">            }</span>
<span class="nc" id="L99">        }</span>

<span class="nc" id="L101">        SqlStatementCache.CacheStatistics stats = cache.getStatistics();</span>
<span class="nc" id="L102">        logger.info(String.format(&quot;Pre-generated SQL for %s: %s&quot;, dbType, stats));</span>
<span class="nc" id="L103">    }</span>

    /**
     * Pre-generate SQL for a specific entity and table
     */
    private void pregenerateForTable(PersistenceProvider.DatabaseType dbType,
                                    Class&lt;?&gt; entityClass,
                                    String tableName,
                                    EntityMetadata&lt;?&gt; metadata,
                                    SqlStatementCache cache) {

<span class="nc bnc" id="L114" title="All 5 branches missed.">        switch (dbType) {</span>
            case MYSQL:
            case MARIADB:
            case TIDB:
<span class="nc" id="L118">                pregenerateMySQLStatements(entityClass, tableName, metadata, cache);</span>
<span class="nc" id="L119">                break;</span>
            case POSTGRESQL:
            case COCKROACHDB:
<span class="nc" id="L122">                pregeneratePostgreSQLStatements(entityClass, tableName, metadata, cache);</span>
<span class="nc" id="L123">                break;</span>
            case ORACLE:
<span class="nc" id="L125">                pregenerateOracleStatements(entityClass, tableName, metadata, cache);</span>
<span class="nc" id="L126">                break;</span>
            case SQLSERVER:
<span class="nc" id="L128">                pregenerateSQLServerStatements(entityClass, tableName, metadata, cache);</span>
<span class="nc" id="L129">                break;</span>
            default:
<span class="nc" id="L131">                logger.warn(&quot;Unsupported database type for pre-generation: &quot; + dbType);</span>
        }
<span class="nc" id="L133">    }</span>

    /**
     * Generate MySQL statements
     */
    private void pregenerateMySQLStatements(Class&lt;?&gt; entityClass, String tableName,
                                           EntityMetadata&lt;?&gt; metadata, SqlStatementCache cache) {
        // Single INSERT
<span class="nc" id="L141">        cache.put(entityClass, tableName, SqlStatementCache.StatementType.INSERT_SINGLE,</span>
<span class="nc" id="L142">                 generateMySQLInsert(tableName, metadata));</span>

        // Batch INSERTs for different sizes
<span class="nc" id="L145">        cache.put(entityClass, tableName, SqlStatementCache.StatementType.INSERT_BATCH_10,</span>
<span class="nc" id="L146">                 generateMySQLBatchInsert(tableName, metadata, 10));</span>
<span class="nc" id="L147">        cache.put(entityClass, tableName, SqlStatementCache.StatementType.INSERT_BATCH_100,</span>
<span class="nc" id="L148">                 generateMySQLBatchInsert(tableName, metadata, 100));</span>
<span class="nc" id="L149">        cache.put(entityClass, tableName, SqlStatementCache.StatementType.INSERT_BATCH_1000,</span>
<span class="nc" id="L150">                 generateMySQLBatchInsert(tableName, metadata, 1000));</span>
<span class="nc" id="L151">        cache.put(entityClass, tableName, SqlStatementCache.StatementType.INSERT_BATCH_5000,</span>
<span class="nc" id="L152">                 generateMySQLBatchInsert(tableName, metadata, 5000));</span>

        // UPDATE BY ID
<span class="nc" id="L155">        cache.put(entityClass, tableName, SqlStatementCache.StatementType.UPDATE_BY_ID,</span>
<span class="nc" id="L156">                 generateMySQLUpdate(tableName, metadata));</span>

        // DELETE BY ID
<span class="nc" id="L159">        cache.put(entityClass, tableName, SqlStatementCache.StatementType.DELETE_BY_ID,</span>
<span class="nc" id="L160">                 generateMySQLDelete(tableName, metadata));</span>

        // SELECT statements
<span class="nc" id="L163">        cache.put(entityClass, tableName, SqlStatementCache.StatementType.SELECT_BY_ID,</span>
<span class="nc" id="L164">                 generateMySQLSelectById(tableName, metadata));</span>
<span class="nc" id="L165">    }</span>

    /**
     * Generate PostgreSQL statements
     */
    private void pregeneratePostgreSQLStatements(Class&lt;?&gt; entityClass, String tableName,
                                                EntityMetadata&lt;?&gt; metadata, SqlStatementCache cache) {
        // Single INSERT
<span class="nc" id="L173">        cache.put(entityClass, tableName, SqlStatementCache.StatementType.INSERT_SINGLE,</span>
<span class="nc" id="L174">                 generatePostgreSQLInsert(tableName, metadata));</span>

        // Batch INSERTs
<span class="nc" id="L177">        cache.put(entityClass, tableName, SqlStatementCache.StatementType.INSERT_BATCH_10,</span>
<span class="nc" id="L178">                 generatePostgreSQLBatchInsert(tableName, metadata, 10));</span>
<span class="nc" id="L179">        cache.put(entityClass, tableName, SqlStatementCache.StatementType.INSERT_BATCH_100,</span>
<span class="nc" id="L180">                 generatePostgreSQLBatchInsert(tableName, metadata, 100));</span>
<span class="nc" id="L181">        cache.put(entityClass, tableName, SqlStatementCache.StatementType.INSERT_BATCH_1000,</span>
<span class="nc" id="L182">                 generatePostgreSQLBatchInsert(tableName, metadata, 1000));</span>

        // UPDATE, DELETE, SELECT
<span class="nc" id="L185">        cache.put(entityClass, tableName, SqlStatementCache.StatementType.UPDATE_BY_ID,</span>
<span class="nc" id="L186">                 generatePostgreSQLUpdate(tableName, metadata));</span>
<span class="nc" id="L187">        cache.put(entityClass, tableName, SqlStatementCache.StatementType.DELETE_BY_ID,</span>
<span class="nc" id="L188">                 generatePostgreSQLDelete(tableName, metadata));</span>
<span class="nc" id="L189">        cache.put(entityClass, tableName, SqlStatementCache.StatementType.SELECT_BY_ID,</span>
<span class="nc" id="L190">                 generatePostgreSQLSelectById(tableName, metadata));</span>
<span class="nc" id="L191">    }</span>

    /**
     * Generate Oracle statements
     */
    private void pregenerateOracleStatements(Class&lt;?&gt; entityClass, String tableName,
                                            EntityMetadata&lt;?&gt; metadata, SqlStatementCache cache) {
        // Single INSERT
<span class="nc" id="L199">        cache.put(entityClass, tableName, SqlStatementCache.StatementType.INSERT_SINGLE,</span>
<span class="nc" id="L200">                 generateOracleInsert(tableName, metadata));</span>

        // Oracle batch inserts use INSERT ALL
<span class="nc" id="L203">        cache.put(entityClass, tableName, SqlStatementCache.StatementType.INSERT_BATCH_10,</span>
<span class="nc" id="L204">                 generateOracleBatchInsert(tableName, metadata, 10));</span>
<span class="nc" id="L205">        cache.put(entityClass, tableName, SqlStatementCache.StatementType.INSERT_BATCH_100,</span>
<span class="nc" id="L206">                 generateOracleBatchInsert(tableName, metadata, 100));</span>

        // UPDATE, DELETE, SELECT
<span class="nc" id="L209">        cache.put(entityClass, tableName, SqlStatementCache.StatementType.UPDATE_BY_ID,</span>
<span class="nc" id="L210">                 generateOracleUpdate(tableName, metadata));</span>
<span class="nc" id="L211">        cache.put(entityClass, tableName, SqlStatementCache.StatementType.DELETE_BY_ID,</span>
<span class="nc" id="L212">                 generateOracleDelete(tableName, metadata));</span>
<span class="nc" id="L213">        cache.put(entityClass, tableName, SqlStatementCache.StatementType.SELECT_BY_ID,</span>
<span class="nc" id="L214">                 generateOracleSelectById(tableName, metadata));</span>
<span class="nc" id="L215">    }</span>

    /**
     * Generate SQL Server statements
     */
    private void pregenerateSQLServerStatements(Class&lt;?&gt; entityClass, String tableName,
                                               EntityMetadata&lt;?&gt; metadata, SqlStatementCache cache) {
        // Single INSERT
<span class="nc" id="L223">        cache.put(entityClass, tableName, SqlStatementCache.StatementType.INSERT_SINGLE,</span>
<span class="nc" id="L224">                 generateSQLServerInsert(tableName, metadata));</span>

        // Batch INSERTs (similar to MySQL)
<span class="nc" id="L227">        cache.put(entityClass, tableName, SqlStatementCache.StatementType.INSERT_BATCH_10,</span>
<span class="nc" id="L228">                 generateSQLServerBatchInsert(tableName, metadata, 10));</span>
<span class="nc" id="L229">        cache.put(entityClass, tableName, SqlStatementCache.StatementType.INSERT_BATCH_100,</span>
<span class="nc" id="L230">                 generateSQLServerBatchInsert(tableName, metadata, 100));</span>
<span class="nc" id="L231">        cache.put(entityClass, tableName, SqlStatementCache.StatementType.INSERT_BATCH_1000,</span>
<span class="nc" id="L232">                 generateSQLServerBatchInsert(tableName, metadata, 1000));</span>

        // UPDATE, DELETE, SELECT
<span class="nc" id="L235">        cache.put(entityClass, tableName, SqlStatementCache.StatementType.UPDATE_BY_ID,</span>
<span class="nc" id="L236">                 generateSQLServerUpdate(tableName, metadata));</span>
<span class="nc" id="L237">        cache.put(entityClass, tableName, SqlStatementCache.StatementType.DELETE_BY_ID,</span>
<span class="nc" id="L238">                 generateSQLServerDelete(tableName, metadata));</span>
<span class="nc" id="L239">        cache.put(entityClass, tableName, SqlStatementCache.StatementType.SELECT_BY_ID,</span>
<span class="nc" id="L240">                 generateSQLServerSelectById(tableName, metadata));</span>
<span class="nc" id="L241">    }</span>

    // ============= MySQL SQL Generation Methods =============

    private String generateMySQLInsert(String tableName, EntityMetadata&lt;?&gt; metadata) {
<span class="nc" id="L246">        String columns = metadata.getFields().stream()</span>
<span class="nc" id="L247">            .map(FieldMetadata::getColumnName)</span>
<span class="nc" id="L248">            .collect(Collectors.joining(&quot;, &quot;));</span>

<span class="nc" id="L250">        String placeholders = metadata.getFields().stream()</span>
<span class="nc" id="L251">            .map(f -&gt; &quot;?&quot;)</span>
<span class="nc" id="L252">            .collect(Collectors.joining(&quot;, &quot;));</span>

<span class="nc" id="L254">        return String.format(&quot;INSERT INTO %s (%s) VALUES (%s)&quot;, tableName, columns, placeholders);</span>
    }

    private String generateMySQLBatchInsert(String tableName, EntityMetadata&lt;?&gt; metadata, int batchSize) {
<span class="nc" id="L258">        String columns = metadata.getFields().stream()</span>
<span class="nc" id="L259">            .map(FieldMetadata::getColumnName)</span>
<span class="nc" id="L260">            .collect(Collectors.joining(&quot;, &quot;));</span>

<span class="nc" id="L262">        String singlePlaceholder = &quot;(&quot; + metadata.getFields().stream()</span>
<span class="nc" id="L263">            .map(f -&gt; &quot;?&quot;)</span>
<span class="nc" id="L264">            .collect(Collectors.joining(&quot;, &quot;)) + &quot;)&quot;;</span>

<span class="nc" id="L266">        StringJoiner valueGroups = new StringJoiner(&quot;, &quot;);</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">        for (int i = 0; i &lt; batchSize; i++) {</span>
<span class="nc" id="L268">            valueGroups.add(singlePlaceholder);</span>
        }

<span class="nc" id="L271">        return String.format(&quot;INSERT INTO %s (%s) VALUES %s&quot;, tableName, columns, valueGroups.toString());</span>
    }

    private String generateMySQLUpdate(String tableName, EntityMetadata&lt;?&gt; metadata) {
<span class="nc" id="L275">        String setClause = metadata.getFields().stream()</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">            .filter(f -&gt; !f.isId())</span>
<span class="nc" id="L277">            .map(f -&gt; f.getColumnName() + &quot; = ?&quot;)</span>
<span class="nc" id="L278">            .collect(Collectors.joining(&quot;, &quot;));</span>

<span class="nc" id="L280">        return String.format(&quot;UPDATE %s SET %s WHERE %s = ?&quot;,</span>
<span class="nc" id="L281">                           tableName, setClause, metadata.getIdField().getColumnName());</span>
    }

    private String generateMySQLDelete(String tableName, EntityMetadata&lt;?&gt; metadata) {
<span class="nc" id="L285">        return String.format(&quot;DELETE FROM %s WHERE %s = ?&quot;,</span>
<span class="nc" id="L286">                           tableName, metadata.getIdField().getColumnName());</span>
    }

    private String generateMySQLSelectById(String tableName, EntityMetadata&lt;?&gt; metadata) {
<span class="nc" id="L290">        String columns = metadata.getFields().stream()</span>
<span class="nc" id="L291">            .map(FieldMetadata::getColumnName)</span>
<span class="nc" id="L292">            .collect(Collectors.joining(&quot;, &quot;));</span>

<span class="nc" id="L294">        return String.format(&quot;SELECT %s FROM %s WHERE %s = ?&quot;,</span>
<span class="nc" id="L295">                           columns, tableName, metadata.getIdField().getColumnName());</span>
    }

    // ============= PostgreSQL SQL Generation Methods =============

    private String generatePostgreSQLInsert(String tableName, EntityMetadata&lt;?&gt; metadata) {
<span class="nc" id="L301">        String columns = metadata.getFields().stream()</span>
<span class="nc" id="L302">            .map(FieldMetadata::getColumnName)</span>
<span class="nc" id="L303">            .collect(Collectors.joining(&quot;, &quot;));</span>

<span class="nc" id="L305">        String placeholders = metadata.getFields().stream()</span>
<span class="nc" id="L306">            .map(f -&gt; &quot;?&quot;)</span>
<span class="nc" id="L307">            .collect(Collectors.joining(&quot;, &quot;));</span>

<span class="nc" id="L309">        return String.format(&quot;INSERT INTO %s (%s) VALUES (%s) RETURNING %s&quot;,</span>
<span class="nc" id="L310">                           tableName, columns, placeholders, metadata.getIdField().getColumnName());</span>
    }

    private String generatePostgreSQLBatchInsert(String tableName, EntityMetadata&lt;?&gt; metadata, int batchSize) {
        // PostgreSQL uses same syntax as MySQL for multi-row VALUES
<span class="nc" id="L315">        return generateMySQLBatchInsert(tableName, metadata, batchSize) +</span>
<span class="nc" id="L316">               &quot; RETURNING &quot; + metadata.getIdField().getColumnName();</span>
    }

    private String generatePostgreSQLUpdate(String tableName, EntityMetadata&lt;?&gt; metadata) {
        // Same as MySQL
<span class="nc" id="L321">        return generateMySQLUpdate(tableName, metadata);</span>
    }

    private String generatePostgreSQLDelete(String tableName, EntityMetadata&lt;?&gt; metadata) {
        // Same as MySQL
<span class="nc" id="L326">        return generateMySQLDelete(tableName, metadata);</span>
    }

    private String generatePostgreSQLSelectById(String tableName, EntityMetadata&lt;?&gt; metadata) {
        // Same as MySQL
<span class="nc" id="L331">        return generateMySQLSelectById(tableName, metadata);</span>
    }

    // ============= Oracle SQL Generation Methods =============

    private String generateOracleInsert(String tableName, EntityMetadata&lt;?&gt; metadata) {
<span class="nc" id="L337">        String columns = metadata.getFields().stream()</span>
<span class="nc" id="L338">            .map(FieldMetadata::getColumnName)</span>
<span class="nc" id="L339">            .collect(Collectors.joining(&quot;, &quot;));</span>

<span class="nc" id="L341">        String placeholders = metadata.getFields().stream()</span>
<span class="nc" id="L342">            .map(f -&gt; &quot;?&quot;)</span>
<span class="nc" id="L343">            .collect(Collectors.joining(&quot;, &quot;));</span>

<span class="nc" id="L345">        return String.format(&quot;INSERT INTO %s (%s) VALUES (%s)&quot;, tableName, columns, placeholders);</span>
    }

    private String generateOracleBatchInsert(String tableName, EntityMetadata&lt;?&gt; metadata, int batchSize) {
        // Oracle uses INSERT ALL syntax
<span class="nc" id="L350">        StringBuilder sql = new StringBuilder(&quot;INSERT ALL\n&quot;);</span>

<span class="nc" id="L352">        String columns = metadata.getFields().stream()</span>
<span class="nc" id="L353">            .map(FieldMetadata::getColumnName)</span>
<span class="nc" id="L354">            .collect(Collectors.joining(&quot;, &quot;));</span>

<span class="nc" id="L356">        String placeholders = metadata.getFields().stream()</span>
<span class="nc" id="L357">            .map(f -&gt; &quot;?&quot;)</span>
<span class="nc" id="L358">            .collect(Collectors.joining(&quot;, &quot;));</span>

<span class="nc bnc" id="L360" title="All 2 branches missed.">        for (int i = 0; i &lt; batchSize; i++) {</span>
<span class="nc" id="L361">            sql.append(String.format(&quot;  INTO %s (%s) VALUES (%s)\n&quot;, tableName, columns, placeholders));</span>
        }
<span class="nc" id="L363">        sql.append(&quot;SELECT * FROM dual&quot;);</span>

<span class="nc" id="L365">        return sql.toString();</span>
    }

    private String generateOracleUpdate(String tableName, EntityMetadata&lt;?&gt; metadata) {
        // Same as MySQL
<span class="nc" id="L370">        return generateMySQLUpdate(tableName, metadata);</span>
    }

    private String generateOracleDelete(String tableName, EntityMetadata&lt;?&gt; metadata) {
        // Same as MySQL
<span class="nc" id="L375">        return generateMySQLDelete(tableName, metadata);</span>
    }

    private String generateOracleSelectById(String tableName, EntityMetadata&lt;?&gt; metadata) {
        // Same as MySQL
<span class="nc" id="L380">        return generateMySQLSelectById(tableName, metadata);</span>
    }

    // ============= SQL Server SQL Generation Methods =============

    private String generateSQLServerInsert(String tableName, EntityMetadata&lt;?&gt; metadata) {
<span class="nc" id="L386">        String columns = metadata.getFields().stream()</span>
<span class="nc" id="L387">            .map(FieldMetadata::getColumnName)</span>
<span class="nc" id="L388">            .collect(Collectors.joining(&quot;, &quot;));</span>

<span class="nc" id="L390">        String placeholders = metadata.getFields().stream()</span>
<span class="nc" id="L391">            .map(f -&gt; &quot;?&quot;)</span>
<span class="nc" id="L392">            .collect(Collectors.joining(&quot;, &quot;));</span>

<span class="nc" id="L394">        return String.format(&quot;INSERT INTO %s (%s) VALUES (%s)&quot;, tableName, columns, placeholders);</span>
    }

    private String generateSQLServerBatchInsert(String tableName, EntityMetadata&lt;?&gt; metadata, int batchSize) {
        // SQL Server 2008+ supports multi-row VALUES like MySQL
<span class="nc" id="L399">        return generateMySQLBatchInsert(tableName, metadata, batchSize);</span>
    }

    private String generateSQLServerUpdate(String tableName, EntityMetadata&lt;?&gt; metadata) {
        // Same as MySQL
<span class="nc" id="L404">        return generateMySQLUpdate(tableName, metadata);</span>
    }

    private String generateSQLServerDelete(String tableName, EntityMetadata&lt;?&gt; metadata) {
        // Same as MySQL
<span class="nc" id="L409">        return generateMySQLDelete(tableName, metadata);</span>
    }

    private String generateSQLServerSelectById(String tableName, EntityMetadata&lt;?&gt; metadata) {
        // Same as MySQL
<span class="nc" id="L414">        return generateMySQLSelectById(tableName, metadata);</span>
    }

    // ============= Retrieval Methods =============

    /**
     * Get cached SQL statement
     */
    public String getCachedSQL(PersistenceProvider.DatabaseType dbType,
                               Class&lt;?&gt; entityClass,
                               String tableName,
                               SqlStatementCache.StatementType statementType) {
<span class="nc" id="L426">        SqlStatementCache cache = cacheByDatabase.get(dbType);</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">        if (cache == null) return null;</span>

<span class="nc" id="L429">        return cache.get(entityClass, tableName, statementType);</span>
    }

    /**
     * Get appropriate batch statement type based on entity count
     */
    public SqlStatementCache.StatementType getBatchStatementType(int entityCount) {
<span class="nc bnc" id="L436" title="All 2 branches missed.">        if (entityCount &lt;= 10) {</span>
<span class="nc" id="L437">            return SqlStatementCache.StatementType.INSERT_BATCH_10;</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">        } else if (entityCount &lt;= 100) {</span>
<span class="nc" id="L439">            return SqlStatementCache.StatementType.INSERT_BATCH_100;</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">        } else if (entityCount &lt;= 1000) {</span>
<span class="nc" id="L441">            return SqlStatementCache.StatementType.INSERT_BATCH_1000;</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">        } else if (entityCount &lt;= 5000) {</span>
<span class="nc" id="L443">            return SqlStatementCache.StatementType.INSERT_BATCH_5000;</span>
        } else {
            // For larger batches, return null to generate at runtime
<span class="nc" id="L446">            return null;</span>
        }
    }

    /**
     * Clear all caches
     */
    public void clearAllCaches() {
<span class="nc" id="L454">        cacheByDatabase.values().forEach(SqlStatementCache::clearAll);</span>
<span class="nc" id="L455">        cacheByDatabase.clear();</span>
<span class="nc" id="L456">        entityMetadataMap.clear();</span>
<span class="nc" id="L457">    }</span>

    /**
     * Get cache statistics for all databases
     */
    public Map&lt;PersistenceProvider.DatabaseType, SqlStatementCache.CacheStatistics&gt; getAllStatistics() {
<span class="nc" id="L463">        Map&lt;PersistenceProvider.DatabaseType, SqlStatementCache.CacheStatistics&gt; stats = new HashMap&lt;&gt;();</span>
<span class="nc" id="L464">        cacheByDatabase.forEach((dbType, cache) -&gt; stats.put(dbType, cache.getStatistics()));</span>
<span class="nc" id="L465">        return stats;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>