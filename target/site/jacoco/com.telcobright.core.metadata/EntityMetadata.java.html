<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EntityMetadata.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Generic Sharding-Aware Repository Framework</a> &gt; <a href="index.source.html" class="el_package">com.telcobright.core.metadata</a> &gt; <span class="el_source">EntityMetadata.java</span></div><h1>EntityMetadata.java</h1><pre class="source lang-java linenums">package com.telcobright.core.metadata;

import com.telcobright.core.annotation.*;
import com.telcobright.core.entity.ShardingEntity;
import java.lang.reflect.Field;
import java.math.BigDecimal;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.util.*;

/**
 * Metadata holder for entity class information, parsed once at startup
 */
public class EntityMetadata&lt;T&gt; {
    private final Class&lt;T&gt; entityClass;
    private final String tableName;
    private final List&lt;FieldMetadata&gt; fields;
    private final FieldMetadata idField;
    private final FieldMetadata shardingKeyField;
    private final String partitionColumnName;  // Cached partition column name
    private final String insertSQL;
    private final String selectByIdSQL;
    private final String updateByIdSQL;
    private final String createTableSQL;
    private final Map&lt;String, Integer&gt; insertParameterIndex;
    private final Map&lt;String, Integer&gt; updateParameterIndex;

<span class="fc" id="L31">    public EntityMetadata(Class&lt;T&gt; entityClass) {</span>
<span class="fc" id="L32">        this.entityClass = entityClass;</span>
<span class="fc" id="L33">        this.fields = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L34">        this.insertParameterIndex = new HashMap&lt;&gt;();</span>
<span class="fc" id="L35">        this.updateParameterIndex = new HashMap&lt;&gt;();</span>
        
        // Parse class annotations
<span class="fc" id="L38">        Table tableAnnotation = entityClass.getAnnotation(Table.class);</span>
<span class="pc bpc" id="L39" title="1 of 2 branches missed.">        if (tableAnnotation == null) {</span>
            // Use simple class name if no annotation
<span class="nc" id="L41">            this.tableName = entityClass.getSimpleName().toLowerCase().replace(&quot;entity&quot;, &quot;&quot;);</span>
        } else {
<span class="fc" id="L43">            this.tableName = tableAnnotation.name();</span>
        }
        
        // Parse fields
<span class="fc" id="L47">        FieldMetadata tempIdField = null;</span>
<span class="fc" id="L48">        FieldMetadata tempShardingField = null;</span>
<span class="fc" id="L49">        int idFieldCount = 0;</span>
<span class="fc" id="L50">        int shardingKeyCount = 0;</span>
<span class="fc" id="L51">        int paramIndex = 1;</span>
        
<span class="fc bfc" id="L53" title="All 2 branches covered.">        for (Field field : entityClass.getDeclaredFields()) {</span>
<span class="fc" id="L54">            field.setAccessible(true);</span>
            
            // Skip static or transient fields
<span class="pc bpc" id="L57" title="1 of 2 branches missed.">            if (java.lang.reflect.Modifier.isStatic(field.getModifiers()) || </span>
<span class="pc bpc" id="L58" title="1 of 2 branches missed.">                java.lang.reflect.Modifier.isTransient(field.getModifiers())) {</span>
<span class="nc" id="L59">                continue;</span>
            }
            
<span class="fc" id="L62">            FieldMetadata fieldMeta = new FieldMetadata(field);</span>
<span class="fc" id="L63">            fields.add(fieldMeta);</span>
            
<span class="fc bfc" id="L65" title="All 2 branches covered.">            if (fieldMeta.isId()) {</span>
<span class="fc" id="L66">                idFieldCount++;</span>
<span class="fc" id="L67">                tempIdField = fieldMeta;</span>
            }
<span class="fc bfc" id="L69" title="All 2 branches covered.">            if (fieldMeta.isShardingKey()) {</span>
<span class="fc" id="L70">                shardingKeyCount++;</span>
<span class="fc" id="L71">                tempShardingField = fieldMeta;</span>
            }
            
            // Build parameter index for insert
<span class="pc bpc" id="L75" title="1 of 4 branches missed.">            if (fieldMeta.isInsertable() &amp;&amp; !fieldMeta.isAutoGenerated()) {</span>
<span class="fc" id="L76">                insertParameterIndex.put(fieldMeta.getFieldName(), paramIndex++);</span>
            }
        }
        
<span class="fc" id="L80">        this.idField = tempIdField;</span>
<span class="fc" id="L81">        this.shardingKeyField = tempShardingField;</span>

        // Cache partition column name from @ShardingKey field
<span class="pc bpc" id="L84" title="1 of 2 branches missed.">        if (tempShardingField != null) {</span>
<span class="fc" id="L85">            this.partitionColumnName = tempShardingField.getColumnName();</span>
        } else {
<span class="nc" id="L87">            this.partitionColumnName = null;</span>
        }

        // Enforce required columns
<span class="fc" id="L91">        validateRequiredColumns();</span>
        
        // Generate SQL statements
<span class="fc" id="L94">        this.insertSQL = generateInsertSQL();</span>
<span class="fc" id="L95">        this.selectByIdSQL = generateSelectByIdSQL();</span>
<span class="fc" id="L96">        this.updateByIdSQL = generateUpdateByIdSQL();</span>
<span class="fc" id="L97">        this.createTableSQL = generateCreateTableSQL();</span>
<span class="fc" id="L98">    }</span>
    
    /**
     * Validates that the entity has required fields for repository operations
     */
    private void validateRequiredColumns() {
        // Count annotations for validation
<span class="fc" id="L105">        int idCount = 0;</span>
<span class="fc" id="L106">        int shardingCount = 0;</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">        for (FieldMetadata field : fields) {</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">            if (field.isId()) idCount++;</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">            if (field.isShardingKey()) shardingCount++;</span>
<span class="fc" id="L110">        }</span>
        
        // Validate exactly ONE @Id field
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">        if (idField == null) {</span>
<span class="nc" id="L114">            throw new IllegalArgumentException(</span>
<span class="nc" id="L115">                String.format(&quot;Entity %s must have exactly ONE field annotated with @Id&quot;, entityClass.getSimpleName())</span>
            );
        }
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">        if (idCount &gt; 1) {</span>
<span class="nc" id="L119">            throw new IllegalArgumentException(</span>
<span class="nc" id="L120">                String.format(&quot;Entity %s has %d fields annotated with @Id, but only ONE is allowed&quot;, </span>
<span class="nc" id="L121">                    entityClass.getSimpleName(), idCount)</span>
            );
        }
        
        // Validate ID field is String type
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">        if (!String.class.equals(idField.getType())) {</span>
<span class="nc" id="L127">            throw new IllegalArgumentException(</span>
<span class="nc" id="L128">                String.format(&quot;Entity %s @Id field '%s' must be of type String for Split-Verse (found: %s). &quot; +</span>
                    &quot;Split-Verse requires String IDs for consistent hash-based sharding.&quot;, 
<span class="nc" id="L130">                    entityClass.getSimpleName(), idField.getFieldName(), idField.getType().getSimpleName())</span>
            );
        }
        
        // Validate exactly ONE @ShardingKey field
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">        if (shardingKeyField == null) {</span>
<span class="nc" id="L136">            throw new IllegalArgumentException(</span>
<span class="nc" id="L137">                String.format(&quot;Entity %s must have exactly ONE field annotated with @ShardingKey for date-based partitioning&quot;, </span>
<span class="nc" id="L138">                    entityClass.getSimpleName())</span>
            );
        }
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">        if (shardingCount &gt; 1) {</span>
<span class="nc" id="L142">            throw new IllegalArgumentException(</span>
<span class="nc" id="L143">                String.format(&quot;Entity %s has %d fields annotated with @ShardingKey, but only ONE is allowed&quot;, </span>
<span class="nc" id="L144">                    entityClass.getSimpleName(), shardingCount)</span>
            );
        }
        
        // Validate sharding key is a Comparable type for range queries
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">        if (!Comparable.class.isAssignableFrom(shardingKeyField.getType())) {</span>
<span class="nc" id="L150">            throw new IllegalArgumentException(</span>
<span class="nc" id="L151">                String.format(&quot;Entity %s @ShardingKey field '%s' must implement Comparable for range partitioning (found: %s)&quot;,</span>
<span class="nc" id="L152">                    entityClass.getSimpleName(), shardingKeyField.getFieldName(), shardingKeyField.getType().getSimpleName())</span>
            );
        }
        
        // Validate that @Id is not auto-generated
<span class="fc bfc" id="L157" title="All 2 branches covered.">        if (idField.isAutoGenerated()) {</span>
<span class="fc" id="L158">            throw new IllegalArgumentException(</span>
<span class="fc" id="L159">                String.format(&quot;Entity %s @Id field '%s' must have autoGenerated=false. &quot; +</span>
                    &quot;Split-Verse requires externally generated String IDs (UUID, ULID, etc.)&quot;, 
<span class="fc" id="L161">                    entityClass.getSimpleName(), idField.getFieldName())</span>
            );
        }
<span class="fc" id="L164">    }</span>
    
    private String generateInsertSQL() {
<span class="fc" id="L167">        StringBuilder columns = new StringBuilder();</span>
<span class="fc" id="L168">        StringBuilder values = new StringBuilder();</span>
<span class="fc" id="L169">        boolean first = true;</span>
        
<span class="fc bfc" id="L171" title="All 2 branches covered.">        for (FieldMetadata field : fields) {</span>
<span class="pc bpc" id="L172" title="2 of 4 branches missed.">            if (field.isInsertable() &amp;&amp; !field.isAutoGenerated()) {</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">                if (!first) {</span>
<span class="fc" id="L174">                    columns.append(&quot;, &quot;);</span>
<span class="fc" id="L175">                    values.append(&quot;, &quot;);</span>
                }
<span class="fc" id="L177">                columns.append(field.getColumnName());</span>
<span class="fc" id="L178">                values.append(&quot;?&quot;);</span>
<span class="fc" id="L179">                first = false;</span>
            }
<span class="fc" id="L181">        }</span>
        
<span class="fc" id="L183">        return String.format(&quot;INSERT INTO %%s (%s) VALUES (%s)&quot;, </span>
<span class="fc" id="L184">            columns.toString(), values.toString());</span>
    }
    
    private String generateSelectByIdSQL() {
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">        if (idField == null) {</span>
<span class="nc" id="L189">            return null;</span>
        }
        
<span class="fc" id="L192">        StringBuilder columns = new StringBuilder();</span>
<span class="fc" id="L193">        boolean first = true;</span>
        
<span class="fc bfc" id="L195" title="All 2 branches covered.">        for (FieldMetadata field : fields) {</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">            if (!first) {</span>
<span class="fc" id="L197">                columns.append(&quot;, &quot;);</span>
            }
<span class="fc" id="L199">            columns.append(field.getColumnName());</span>
<span class="fc" id="L200">            first = false;</span>
<span class="fc" id="L201">        }</span>
        
<span class="fc" id="L203">        return String.format(&quot;SELECT %s FROM %%s WHERE %s = ?&quot;, </span>
<span class="fc" id="L204">            columns.toString(), idField.getColumnName());</span>
    }
    
    private String generateUpdateByIdSQL() {
<span class="fc" id="L208">        StringBuilder setClause = new StringBuilder();</span>
<span class="fc" id="L209">        boolean first = true;</span>
<span class="fc" id="L210">        int paramIndex = 1;</span>
        
<span class="fc bfc" id="L212" title="All 2 branches covered.">        for (FieldMetadata field : fields) {</span>
            // Skip ID field and non-updatable fields
<span class="pc bpc" id="L214" title="1 of 4 branches missed.">            if (field.isId() || !field.isUpdatable()) {</span>
<span class="nc" id="L215">                continue;</span>
            }
            
<span class="fc bfc" id="L218" title="All 2 branches covered.">            if (!first) {</span>
<span class="fc" id="L219">                setClause.append(&quot;, &quot;);</span>
            }
<span class="fc" id="L221">            setClause.append(field.getColumnName()).append(&quot; = ?&quot;);</span>
<span class="fc" id="L222">            updateParameterIndex.put(field.getFieldName(), paramIndex++);</span>
<span class="fc" id="L223">            first = false;</span>
<span class="fc" id="L224">        }</span>
        
        // ID field is the last parameter for WHERE clause
<span class="fc" id="L227">        updateParameterIndex.put(idField.getFieldName(), paramIndex);</span>
        
<span class="fc" id="L229">        return String.format(&quot;UPDATE %%s SET %s WHERE %s = ?&quot;,</span>
<span class="fc" id="L230">            setClause.toString(), idField.getColumnName());</span>
    }
    
    private String generateCreateTableSQL() {
<span class="fc" id="L234">        StringBuilder sql = new StringBuilder(&quot;CREATE TABLE IF NOT EXISTS %s (&quot;);</span>
<span class="fc" id="L235">        boolean first = true;</span>
        
<span class="fc bfc" id="L237" title="All 2 branches covered.">        for (FieldMetadata field : fields) {</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">            if (!first) {</span>
<span class="fc" id="L239">                sql.append(&quot;, &quot;);</span>
            }
<span class="fc" id="L241">            sql.append(field.getColumnName()).append(&quot; &quot;).append(field.getSqlType());</span>
            
<span class="fc bfc" id="L243" title="All 2 branches covered.">            if (field.isId()) {</span>
<span class="fc" id="L244">                sql.append(&quot; PRIMARY KEY&quot;);</span>
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">                if (field.isAutoGenerated()) {</span>
<span class="nc" id="L246">                    sql.append(&quot; AUTO_INCREMENT&quot;);</span>
                }
            }
            
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">            if (!field.isNullable()) {</span>
<span class="nc" id="L251">                sql.append(&quot; NOT NULL&quot;);</span>
            }
            
<span class="fc" id="L254">            first = false;</span>
<span class="fc" id="L255">        }</span>
        
        // Add automatic indexes - ID already has PRIMARY KEY, but add explicit index for sharding key
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">        if (shardingKeyField != null) {</span>
<span class="fc" id="L259">            sql.append(&quot;, KEY idx_&quot;).append(shardingKeyField.getColumnName())</span>
<span class="fc" id="L260">               .append(&quot; (&quot;).append(shardingKeyField.getColumnName()).append(&quot;)&quot;);</span>
        }
        
        // No composite index needed - single String ID only
        
        // Add custom indexes from @Index annotations
<span class="fc bfc" id="L266" title="All 2 branches covered.">        for (FieldMetadata field : fields) {</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">            if (field.hasIndex()) {</span>
<span class="pc bpc" id="L268" title="1 of 2 branches missed.">                String indexKeyword = field.getIndexAnnotation().unique() ? &quot;UNIQUE KEY&quot; : &quot;KEY&quot;;</span>
<span class="fc" id="L269">                String indexName = field.getIndexName();</span>
<span class="fc" id="L270">                String comment = field.getIndexAnnotation().comment();</span>
                
<span class="fc" id="L272">                sql.append(&quot;, &quot;).append(indexKeyword).append(&quot; &quot;).append(indexName)</span>
<span class="fc" id="L273">                   .append(&quot; (&quot;).append(field.getColumnName()).append(&quot;)&quot;);</span>
                
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">                if (!comment.isEmpty()) {</span>
<span class="nc" id="L276">                    sql.append(&quot; COMMENT '&quot;).append(comment).append(&quot;'&quot;);</span>
                }
            }
<span class="fc" id="L279">        }</span>
        
<span class="fc" id="L281">        sql.append(&quot;) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4&quot;);</span>
        
<span class="fc" id="L283">        return sql.toString();</span>
    }
    
    public void setInsertParameters(PreparedStatement stmt, T entity) throws SQLException {
<span class="fc bfc" id="L287" title="All 2 branches covered.">        for (FieldMetadata field : fields) {</span>
<span class="pc bpc" id="L288" title="2 of 4 branches missed.">            if (field.isInsertable() &amp;&amp; !field.isAutoGenerated()) {</span>
<span class="fc" id="L289">                Integer index = insertParameterIndex.get(field.getFieldName());</span>
<span class="pc bpc" id="L290" title="1 of 2 branches missed.">                if (index != null) {</span>
<span class="fc" id="L291">                    setParameter(stmt, index, field.getValue(entity), field.getType());</span>
                }
            }
<span class="fc" id="L294">        }</span>
<span class="fc" id="L295">    }</span>
    
    public void setUpdateParameters(PreparedStatement stmt, T entity, String id) throws SQLException {
        // Set all updatable field values
<span class="nc bnc" id="L299" title="All 2 branches missed.">        for (FieldMetadata field : fields) {</span>
<span class="nc bnc" id="L300" title="All 4 branches missed.">            if (!field.isId() &amp;&amp; field.isUpdatable()) {</span>
<span class="nc" id="L301">                Integer index = updateParameterIndex.get(field.getFieldName());</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">                if (index != null) {</span>
<span class="nc" id="L303">                    setParameter(stmt, index, field.getValue(entity), field.getType());</span>
                }
            }
<span class="nc" id="L306">        }</span>
        
        // Set ID value for WHERE clause (last parameter)
<span class="nc" id="L309">        Integer idIndex = updateParameterIndex.get(idField.getFieldName());</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">        if (idIndex != null) {</span>
<span class="nc" id="L311">            setParameter(stmt, idIndex, id, idField.getType());</span>
        }
<span class="nc" id="L313">    }</span>
    
    public T mapResultSet(ResultSet rs) throws SQLException {
        try {
<span class="fc" id="L317">            T entity = entityClass.getDeclaredConstructor().newInstance();</span>
            
<span class="fc bfc" id="L319" title="All 2 branches covered.">            for (FieldMetadata field : fields) {</span>
<span class="fc" id="L320">                Object value = getResultSetValue(rs, field.getColumnName(), field.getType());</span>
<span class="fc" id="L321">                field.setValue(entity, value);</span>
<span class="fc" id="L322">            }</span>
            
<span class="fc" id="L324">            return entity;</span>
<span class="nc" id="L325">        } catch (Exception e) {</span>
<span class="nc" id="L326">            throw new SQLException(&quot;Failed to map result set to entity&quot;, e);</span>
        }
    }
    
    private void setParameter(PreparedStatement stmt, int index, Object value, Class&lt;?&gt; type) throws SQLException {
<span class="fc bfc" id="L331" title="All 2 branches covered.">        if (value == null) {</span>
<span class="fc" id="L332">            stmt.setNull(index, java.sql.Types.NULL);</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">        } else if (type == String.class) {</span>
<span class="fc" id="L334">            stmt.setString(index, (String) value);</span>
<span class="pc bpc" id="L335" title="1 of 4 branches missed.">        } else if (type == Long.class || type == long.class) {</span>
<span class="fc" id="L336">            stmt.setLong(index, (Long) value);</span>
<span class="pc bpc" id="L337" title="1 of 4 branches missed.">        } else if (type == Integer.class || type == int.class) {</span>
<span class="fc" id="L338">            stmt.setInt(index, (Integer) value);</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">        } else if (type == LocalDateTime.class) {</span>
            // Create Timestamp from LocalDateTime and explicitly set with local Calendar
            // to prevent MySQL JDBC driver from applying timezone conversion
<span class="fc" id="L342">            Timestamp timestamp = Timestamp.valueOf((LocalDateTime) value);</span>
<span class="fc" id="L343">            stmt.setTimestamp(index, timestamp, java.util.Calendar.getInstance());</span>
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">        } else if (type == BigDecimal.class) {</span>
<span class="nc" id="L345">            stmt.setBigDecimal(index, (BigDecimal) value);</span>
<span class="pc bpc" id="L346" title="2 of 4 branches missed.">        } else if (type == Boolean.class || type == boolean.class) {</span>
<span class="nc" id="L347">            stmt.setBoolean(index, (Boolean) value);</span>
<span class="pc bpc" id="L348" title="3 of 4 branches missed.">        } else if (type == Double.class || type == double.class) {</span>
<span class="fc" id="L349">            stmt.setDouble(index, (Double) value);</span>
        } else {
<span class="nc" id="L351">            stmt.setObject(index, value);</span>
        }
<span class="fc" id="L353">    }</span>
    
    private Object getResultSetValue(ResultSet rs, String columnName, Class&lt;?&gt; type) throws SQLException {
<span class="fc bfc" id="L356" title="All 2 branches covered.">        if (type == String.class) {</span>
<span class="fc" id="L357">            return rs.getString(columnName);</span>
<span class="pc bpc" id="L358" title="1 of 4 branches missed.">        } else if (type == Long.class || type == long.class) {</span>
<span class="fc" id="L359">            long value = rs.getLong(columnName);</span>
<span class="pc bpc" id="L360" title="1 of 2 branches missed.">            return rs.wasNull() ? null : value;</span>
<span class="pc bpc" id="L361" title="1 of 4 branches missed.">        } else if (type == Integer.class || type == int.class) {</span>
<span class="fc" id="L362">            int value = rs.getInt(columnName);</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">            return rs.wasNull() ? null : value;</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">        } else if (type == LocalDateTime.class) {</span>
            // Get timestamp with local Calendar to prevent timezone conversion
<span class="fc" id="L366">            Timestamp ts = rs.getTimestamp(columnName, java.util.Calendar.getInstance());</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">            return ts != null ? ts.toLocalDateTime() : null;</span>
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">        } else if (type == BigDecimal.class) {</span>
<span class="nc" id="L369">            return rs.getBigDecimal(columnName);</span>
<span class="pc bpc" id="L370" title="2 of 4 branches missed.">        } else if (type == Boolean.class || type == boolean.class) {</span>
<span class="nc" id="L371">            return rs.getBoolean(columnName);</span>
<span class="pc bpc" id="L372" title="3 of 4 branches missed.">        } else if (type == Double.class || type == double.class) {</span>
<span class="fc" id="L373">            double value = rs.getDouble(columnName);</span>
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">            return rs.wasNull() ? null : value;</span>
        } else {
<span class="nc" id="L376">            return rs.getObject(columnName);</span>
        }
    }
    
    // Getters
<span class="nc" id="L381">    public String getTableName() { return tableName; }</span>
<span class="fc" id="L382">    public String getInsertSQL() { return insertSQL; }</span>
<span class="fc" id="L383">    public String getSelectByIdSQL() { return selectByIdSQL; }</span>
<span class="nc" id="L384">    public String getUpdateByIdSQL() { return updateByIdSQL; }</span>
<span class="fc" id="L385">    public String getCreateTableSQL() { return createTableSQL; }</span>
<span class="fc" id="L386">    public FieldMetadata getIdField() { return idField; }</span>
<span class="fc" id="L387">    public FieldMetadata getShardingKeyField() { return shardingKeyField; }</span>
<span class="fc" id="L388">    public List&lt;FieldMetadata&gt; getFields() { return fields; }</span>
<span class="nc" id="L389">    public String getPartitionColumnName() { return partitionColumnName; }</span>
    
    public String getId(T entity) {
<span class="nc bnc" id="L392" title="All 2 branches missed.">        if (idField == null) {</span>
<span class="nc" id="L393">            return null;</span>
        }
<span class="nc" id="L395">        return (String) idField.getValue(entity);</span>
    }
    
    public void setId(T entity, String id) {
<span class="nc bnc" id="L399" title="All 2 branches missed.">        if (idField != null) {</span>
<span class="nc" id="L400">            idField.setValue(entity, id);</span>
        }
<span class="nc" id="L402">    }</span>
    
    public LocalDateTime getShardingKeyValue(T entity) {
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">        if (shardingKeyField == null) {</span>
<span class="nc" id="L406">            throw new IllegalStateException(&quot;No sharding key field found in entity&quot;);</span>
        }
<span class="fc" id="L408">        Object value = shardingKeyField.getValue(entity);</span>
<span class="pc bpc" id="L409" title="1 of 2 branches missed.">        if (value instanceof LocalDateTime) {</span>
<span class="fc" id="L410">            return (LocalDateTime) value;</span>
        }
        // Use the interface method if available
<span class="nc bnc" id="L413" title="All 2 branches missed.">        if (entity instanceof ShardingEntity) {</span>
<span class="nc" id="L414">            Object partitionValue = ((ShardingEntity) entity).getPartitionColValue();</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">            if (partitionValue instanceof LocalDateTime) {</span>
<span class="nc" id="L416">                return (LocalDateTime) partitionValue;</span>
            }
        }
<span class="nc" id="L419">        throw new ClassCastException(&quot;Sharding key value is not LocalDateTime: &quot; + value.getClass());</span>
    }

    /**
     * Get the partition column value from the entity (generic type support).
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;V extends Comparable&lt;V&gt;&gt; V getPartitionColValue(T entity) {
<span class="pc bpc" id="L427" title="1 of 2 branches missed.">        if (shardingKeyField == null) {</span>
<span class="nc" id="L428">            throw new IllegalStateException(&quot;No sharding key field found in entity&quot;);</span>
        }
<span class="fc" id="L430">        Object value = shardingKeyField.getValue(entity);</span>
<span class="pc bpc" id="L431" title="1 of 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L432">            return null;</span>
        }
<span class="pc bpc" id="L434" title="1 of 2 branches missed.">        if (!Comparable.class.isAssignableFrom(value.getClass())) {</span>
<span class="nc" id="L435">            throw new ClassCastException(&quot;Partition column value must be Comparable: &quot; + value.getClass());</span>
        }
<span class="fc" id="L437">        return (V) value;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>