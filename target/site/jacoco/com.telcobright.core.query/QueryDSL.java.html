<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>QueryDSL.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Generic Sharding-Aware Repository Framework</a> &gt; <a href="index.source.html" class="el_package">com.telcobright.core.query</a> &gt; <span class="el_source">QueryDSL.java</span></div><h1>QueryDSL.java</h1><pre class="source lang-java linenums">package com.telcobright.core.query;

import com.telcobright.core.repository.PartitionedQueryBuilder;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Type-safe DSL for building partitioned queries
 * 
 * Example usage:
 * &lt;pre&gt;
 * String query = QueryDSL.select()
 *     .column(&quot;user_id&quot;)
 *     .count(&quot;*&quot;, &quot;count&quot;)
 *     .max(&quot;created_at&quot;, &quot;max_created_at&quot;)
 *     .min(&quot;created_at&quot;, &quot;min_created_at&quot;)
 *     .from(&quot;sms&quot;)
 *     .where(w -&gt; w
 *         .dateRange(&quot;created_at&quot;, startDate, endDate)
 *         .and(&quot;status&quot;, Operator.EQUALS, &quot;SENT&quot;))
 *     .groupBy(&quot;user_id&quot;)
 *     .orderBy(&quot;count&quot;, Order.DESC)
 *     .build();
 * &lt;/pre&gt;
 */
public class QueryDSL {
    
    private QueryDSL() {} // Static factory methods only
    
    /**
     * Start building a SELECT query
     */
    public static SelectBuilder select() {
<span class="nc" id="L36">        return new SelectBuilder();</span>
    }
    
    /**
     * Operator types for WHERE conditions
     */
<span class="nc" id="L42">    public enum Operator {</span>
<span class="nc" id="L43">        EQUALS(&quot;=&quot;),</span>
<span class="nc" id="L44">        NOT_EQUALS(&quot;!=&quot;),</span>
<span class="nc" id="L45">        GREATER_THAN(&quot;&gt;&quot;),</span>
<span class="nc" id="L46">        GREATER_THAN_OR_EQUALS(&quot;&gt;=&quot;),</span>
<span class="nc" id="L47">        LESS_THAN(&quot;&lt;&quot;),</span>
<span class="nc" id="L48">        LESS_THAN_OR_EQUALS(&quot;&lt;=&quot;),</span>
<span class="nc" id="L49">        LIKE(&quot;LIKE&quot;),</span>
<span class="nc" id="L50">        IN(&quot;IN&quot;),</span>
<span class="nc" id="L51">        NOT_IN(&quot;NOT IN&quot;),</span>
<span class="nc" id="L52">        IS_NULL(&quot;IS NULL&quot;),</span>
<span class="nc" id="L53">        IS_NOT_NULL(&quot;IS NOT NULL&quot;);</span>
        
        private final String sql;
        
<span class="nc" id="L57">        Operator(String sql) {</span>
<span class="nc" id="L58">            this.sql = sql;</span>
<span class="nc" id="L59">        }</span>
        
        public String toSql() {
<span class="nc" id="L62">            return sql;</span>
        }
    }
    
    /**
     * Order direction for ORDER BY
     */
<span class="nc" id="L69">    public enum Order {</span>
<span class="nc" id="L70">        ASC(&quot;ASC&quot;),</span>
<span class="nc" id="L71">        DESC(&quot;DESC&quot;);</span>
        
        private final String sql;
        
<span class="nc" id="L75">        Order(String sql) {</span>
<span class="nc" id="L76">            this.sql = sql;</span>
<span class="nc" id="L77">        }</span>
        
        public String toSql() {
<span class="nc" id="L80">            return sql;</span>
        }
    }
    
    /**
     * Aggregate function types
     */
<span class="nc" id="L87">    public enum AggregateFunction {</span>
<span class="nc" id="L88">        COUNT(&quot;COUNT&quot;),</span>
<span class="nc" id="L89">        SUM(&quot;SUM&quot;),</span>
<span class="nc" id="L90">        AVG(&quot;AVG&quot;),</span>
<span class="nc" id="L91">        MAX(&quot;MAX&quot;),</span>
<span class="nc" id="L92">        MIN(&quot;MIN&quot;);</span>
        
        private final String sql;
        
<span class="nc" id="L96">        AggregateFunction(String sql) {</span>
<span class="nc" id="L97">            this.sql = sql;</span>
<span class="nc" id="L98">        }</span>
        
        public String toSql() {
<span class="nc" id="L101">            return sql;</span>
        }
    }
    
    /**
     * Builder for SELECT clause
     */
<span class="nc" id="L108">    public static class SelectBuilder {</span>
<span class="nc" id="L109">        private final List&lt;SelectColumn&gt; columns = new ArrayList&lt;&gt;();</span>
        
        /**
         * Add a regular column
         */
        public SelectBuilder column(String name) {
<span class="nc" id="L115">            columns.add(new SelectColumn(name, null, null, null));</span>
<span class="nc" id="L116">            return this;</span>
        }
        
        /**
         * Add a column with alias
         */
        public SelectBuilder column(String name, String alias) {
<span class="nc" id="L123">            columns.add(new SelectColumn(name, null, null, alias));</span>
<span class="nc" id="L124">            return this;</span>
        }
        
        /**
         * Add COUNT aggregate
         */
        public SelectBuilder count(String expression, String alias) {
<span class="nc" id="L131">            columns.add(new SelectColumn(expression, AggregateFunction.COUNT, null, alias));</span>
<span class="nc" id="L132">            return this;</span>
        }
        
        /**
         * Add COUNT(*) 
         */
        public SelectBuilder countAll(String alias) {
<span class="nc" id="L139">            return count(&quot;*&quot;, alias);</span>
        }
        
        /**
         * Add SUM aggregate
         */
        public SelectBuilder sum(String column, String alias) {
<span class="nc" id="L146">            columns.add(new SelectColumn(column, AggregateFunction.SUM, null, alias));</span>
<span class="nc" id="L147">            return this;</span>
        }
        
        /**
         * Add AVG aggregate
         */
        public SelectBuilder avg(String column, String alias) {
<span class="nc" id="L154">            columns.add(new SelectColumn(column, AggregateFunction.AVG, null, alias));</span>
<span class="nc" id="L155">            return this;</span>
        }
        
        /**
         * Add MAX aggregate
         */
        public SelectBuilder max(String column, String alias) {
<span class="nc" id="L162">            columns.add(new SelectColumn(column, AggregateFunction.MAX, null, alias));</span>
<span class="nc" id="L163">            return this;</span>
        }
        
        /**
         * Add MIN aggregate
         */
        public SelectBuilder min(String column, String alias) {
<span class="nc" id="L170">            columns.add(new SelectColumn(column, AggregateFunction.MIN, null, alias));</span>
<span class="nc" id="L171">            return this;</span>
        }
        
        /**
         * Add custom aggregate with DISTINCT
         */
        public SelectBuilder aggregate(AggregateFunction func, String expression, String alias, boolean distinct) {
<span class="nc" id="L178">            columns.add(new SelectColumn(expression, func, distinct, alias));</span>
<span class="nc" id="L179">            return this;</span>
        }
        
        /**
         * Specify FROM table
         */
        public FromBuilder from(String tableName) {
<span class="nc" id="L186">            return new FromBuilder(columns, tableName);</span>
        }
    }
    
    /**
     * Builder for FROM clause and subsequent query parts
     */
    public static class FromBuilder {
        private final List&lt;SelectColumn&gt; columns;
        private final String tableName;
        private WhereClause whereClause;
<span class="nc" id="L197">        private final List&lt;String&gt; groupByColumns = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L198">        private final List&lt;OrderByColumn&gt; orderByColumns = new ArrayList&lt;&gt;();</span>
        private Integer limit;
        
<span class="nc" id="L201">        FromBuilder(List&lt;SelectColumn&gt; columns, String tableName) {</span>
<span class="nc" id="L202">            this.columns = columns;</span>
<span class="nc" id="L203">            this.tableName = tableName;</span>
<span class="nc" id="L204">        }</span>
        
        /**
         * Add WHERE conditions
         */
        public FromBuilder where(java.util.function.Function&lt;WhereBuilder, WhereBuilder&gt; whereFunc) {
<span class="nc" id="L210">            WhereBuilder whereBuilder = new WhereBuilder();</span>
<span class="nc" id="L211">            whereBuilder = whereFunc.apply(whereBuilder);</span>
<span class="nc" id="L212">            this.whereClause = whereBuilder.build();</span>
<span class="nc" id="L213">            return this;</span>
        }
        
        /**
         * Add GROUP BY columns
         */
        public FromBuilder groupBy(String... columns) {
<span class="nc" id="L220">            groupByColumns.addAll(Arrays.asList(columns));</span>
<span class="nc" id="L221">            return this;</span>
        }
        
        /**
         * Add ORDER BY
         */
        public FromBuilder orderBy(String column, Order order) {
<span class="nc" id="L228">            orderByColumns.add(new OrderByColumn(column, order));</span>
<span class="nc" id="L229">            return this;</span>
        }
        
        /**
         * Add ORDER BY ascending
         */
        public FromBuilder orderByAsc(String column) {
<span class="nc" id="L236">            return orderBy(column, Order.ASC);</span>
        }
        
        /**
         * Add ORDER BY descending
         */
        public FromBuilder orderByDesc(String column) {
<span class="nc" id="L243">            return orderBy(column, Order.DESC);</span>
        }
        
        /**
         * Add LIMIT
         */
        public FromBuilder limit(int limit) {
<span class="nc" id="L250">            this.limit = limit;</span>
<span class="nc" id="L251">            return this;</span>
        }
        
        /**
         * Build the final SQL query
         */
        public String build() {
<span class="nc" id="L258">            return buildQuery(false);</span>
        }
        
        /**
         * Build as partitioned query with UNION ALL
         */
        public String buildPartitioned(String database, LocalDateTime startDate, LocalDateTime endDate) {
            // Validate that we have a date range in WHERE clause
<span class="nc bnc" id="L266" title="All 4 branches missed.">            if (whereClause == null || whereClause.dateRangeField == null) {</span>
<span class="nc" id="L267">                throw new IllegalStateException(&quot;Partitioned query requires a date range in WHERE clause&quot;);</span>
            }
            
<span class="nc" id="L270">            return PartitionedQueryBuilder.getQuery(buildQuery(true), tableName, database, whereClause.dateRangeField);</span>
        }
        
        private String buildQuery(boolean includeTrailingSemicolon) {
<span class="nc" id="L274">            StringBuilder sql = new StringBuilder(&quot;SELECT &quot;);</span>
            
            // Build SELECT clause
<span class="nc" id="L277">            sql.append(columns.stream()</span>
<span class="nc" id="L278">                .map(this::formatSelectColumn)</span>
<span class="nc" id="L279">                .collect(Collectors.joining(&quot;, &quot;)));</span>
            
            // FROM clause
<span class="nc" id="L282">            sql.append(&quot;\nFROM &quot;).append(tableName);</span>
            
            // WHERE clause
<span class="nc bnc" id="L285" title="All 2 branches missed.">            if (whereClause != null) {</span>
<span class="nc" id="L286">                sql.append(&quot;\nWHERE &quot;).append(whereClause.toSql());</span>
            }
            
            // GROUP BY clause
<span class="nc bnc" id="L290" title="All 2 branches missed.">            if (!groupByColumns.isEmpty()) {</span>
<span class="nc" id="L291">                sql.append(&quot;\nGROUP BY &quot;).append(String.join(&quot;, &quot;, groupByColumns));</span>
            }
            
            // ORDER BY clause
<span class="nc bnc" id="L295" title="All 2 branches missed.">            if (!orderByColumns.isEmpty()) {</span>
<span class="nc" id="L296">                sql.append(&quot;\nORDER BY &quot;);</span>
<span class="nc" id="L297">                sql.append(orderByColumns.stream()</span>
<span class="nc" id="L298">                    .map(o -&gt; o.column + &quot; &quot; + o.order.toSql())</span>
<span class="nc" id="L299">                    .collect(Collectors.joining(&quot;, &quot;)));</span>
            }
            
            // LIMIT clause
<span class="nc bnc" id="L303" title="All 2 branches missed.">            if (limit != null) {</span>
<span class="nc" id="L304">                sql.append(&quot;\nLIMIT &quot;).append(limit);</span>
            }
            
<span class="nc bnc" id="L307" title="All 2 branches missed.">            if (includeTrailingSemicolon) {</span>
<span class="nc" id="L308">                sql.append(&quot;;&quot;);</span>
            }
            
<span class="nc" id="L311">            return sql.toString();</span>
        }
        
        private String formatSelectColumn(SelectColumn col) {
<span class="nc bnc" id="L315" title="All 2 branches missed.">            if (col.function == null) {</span>
                // Regular column
<span class="nc bnc" id="L317" title="All 2 branches missed.">                return col.alias != null ? col.name + &quot; AS &quot; + col.alias : col.name;</span>
            } else {
                // Aggregate function
<span class="nc" id="L320">                String expr = col.function.toSql() + &quot;(&quot;;</span>
<span class="nc bnc" id="L321" title="All 4 branches missed.">                if (col.distinct != null &amp;&amp; col.distinct) {</span>
<span class="nc" id="L322">                    expr += &quot;DISTINCT &quot;;</span>
                }
<span class="nc" id="L324">                expr += col.name + &quot;)&quot;;</span>
                
<span class="nc bnc" id="L326" title="All 2 branches missed.">                return col.alias != null ? expr + &quot; AS &quot; + col.alias : expr;</span>
            }
        }
    }
    
    /**
     * Builder for WHERE conditions
     */
<span class="nc" id="L334">    public static class WhereBuilder {</span>
<span class="nc" id="L335">        private final List&lt;WhereCondition&gt; conditions = new ArrayList&lt;&gt;();</span>
        private String dateRangeField;
        private LocalDateTime startDate;
        private LocalDateTime endDate;
        
        /**
         * Add a date range condition
         */
        public WhereBuilder dateRange(String field, LocalDateTime start, LocalDateTime end) {
<span class="nc" id="L344">            this.dateRangeField = field;</span>
<span class="nc" id="L345">            this.startDate = start;</span>
<span class="nc" id="L346">            this.endDate = end;</span>
<span class="nc" id="L347">            conditions.add(new WhereCondition(field, Operator.GREATER_THAN_OR_EQUALS, </span>
<span class="nc" id="L348">                &quot;'&quot; + formatDateTime(start) + &quot;'&quot;, &quot;AND&quot;));</span>
<span class="nc" id="L349">            conditions.add(new WhereCondition(field, Operator.LESS_THAN_OR_EQUALS, </span>
<span class="nc" id="L350">                &quot;'&quot; + formatDateTime(end) + &quot;'&quot;, &quot;AND&quot;));</span>
<span class="nc" id="L351">            return this;</span>
        }
        
        /**
         * Add an equals condition
         */
        public WhereBuilder equals(String field, Object value) {
<span class="nc" id="L358">            return and(field, Operator.EQUALS, value);</span>
        }
        
        /**
         * Add a NOT equals condition
         */
        public WhereBuilder notEquals(String field, Object value) {
<span class="nc" id="L365">            return and(field, Operator.NOT_EQUALS, value);</span>
        }
        
        /**
         * Add an IN condition
         */
        public WhereBuilder in(String field, Object... values) {
<span class="nc" id="L372">            String valueList = Arrays.stream(values)</span>
<span class="nc" id="L373">                .map(this::formatValue)</span>
<span class="nc" id="L374">                .collect(Collectors.joining(&quot;, &quot;, &quot;(&quot;, &quot;)&quot;));</span>
<span class="nc" id="L375">            conditions.add(new WhereCondition(field, Operator.IN, valueList, &quot;AND&quot;));</span>
<span class="nc" id="L376">            return this;</span>
        }
        
        /**
         * Add an IS NULL condition
         */
        public WhereBuilder isNull(String field) {
<span class="nc" id="L383">            conditions.add(new WhereCondition(field, Operator.IS_NULL, &quot;&quot;, &quot;AND&quot;));</span>
<span class="nc" id="L384">            return this;</span>
        }
        
        /**
         * Add an IS NOT NULL condition
         */
        public WhereBuilder isNotNull(String field) {
<span class="nc" id="L391">            conditions.add(new WhereCondition(field, Operator.IS_NOT_NULL, &quot;&quot;, &quot;AND&quot;));</span>
<span class="nc" id="L392">            return this;</span>
        }
        
        /**
         * Add a LIKE condition
         */
        public WhereBuilder like(String field, String pattern) {
<span class="nc" id="L399">            return and(field, Operator.LIKE, pattern);</span>
        }
        
        /**
         * Add an AND condition
         */
        public WhereBuilder and(String field, Operator operator, Object value) {
<span class="nc" id="L406">            conditions.add(new WhereCondition(field, operator, formatValue(value), &quot;AND&quot;));</span>
<span class="nc" id="L407">            return this;</span>
        }
        
        /**
         * Add an OR condition
         */
        public WhereBuilder or(String field, Operator operator, Object value) {
<span class="nc" id="L414">            conditions.add(new WhereCondition(field, operator, formatValue(value), &quot;OR&quot;));</span>
<span class="nc" id="L415">            return this;</span>
        }
        
        private String formatValue(Object value) {
<span class="nc bnc" id="L419" title="All 2 branches missed.">            if (value == null) {</span>
<span class="nc" id="L420">                return &quot;NULL&quot;;</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">            } else if (value instanceof String) {</span>
<span class="nc" id="L422">                return &quot;'&quot; + value + &quot;'&quot;;</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">            } else if (value instanceof LocalDateTime) {</span>
<span class="nc" id="L424">                return &quot;'&quot; + formatDateTime((LocalDateTime) value) + &quot;'&quot;;</span>
            } else {
<span class="nc" id="L426">                return value.toString();</span>
            }
        }
        
        private String formatDateTime(LocalDateTime dateTime) {
<span class="nc" id="L431">            return dateTime.format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;));</span>
        }
        
        WhereClause build() {
<span class="nc" id="L435">            WhereClause clause = new WhereClause();</span>
<span class="nc" id="L436">            clause.conditions = new ArrayList&lt;&gt;(conditions);</span>
<span class="nc" id="L437">            clause.dateRangeField = dateRangeField;</span>
<span class="nc" id="L438">            clause.startDate = startDate;</span>
<span class="nc" id="L439">            clause.endDate = endDate;</span>
<span class="nc" id="L440">            return clause;</span>
        }
    }
    
    // Internal data structures
    
    private static class SelectColumn {
        final String name;
        final AggregateFunction function;
        final Boolean distinct;
        final String alias;
        
<span class="nc" id="L452">        SelectColumn(String name, AggregateFunction function, Boolean distinct, String alias) {</span>
<span class="nc" id="L453">            this.name = name;</span>
<span class="nc" id="L454">            this.function = function;</span>
<span class="nc" id="L455">            this.distinct = distinct;</span>
<span class="nc" id="L456">            this.alias = alias;</span>
<span class="nc" id="L457">        }</span>
    }
    
    private static class WhereCondition {
        final String field;
        final Operator operator;
        final String value;
        final String connector; // AND/OR
        
<span class="nc" id="L466">        WhereCondition(String field, Operator operator, String value, String connector) {</span>
<span class="nc" id="L467">            this.field = field;</span>
<span class="nc" id="L468">            this.operator = operator;</span>
<span class="nc" id="L469">            this.value = value;</span>
<span class="nc" id="L470">            this.connector = connector;</span>
<span class="nc" id="L471">        }</span>
    }
    
    private static class WhereClause {
        List&lt;WhereCondition&gt; conditions;
        String dateRangeField;
        LocalDateTime startDate;
        LocalDateTime endDate;
        
        String toSql() {
<span class="nc bnc" id="L481" title="All 2 branches missed.">            if (conditions.isEmpty()) {</span>
<span class="nc" id="L482">                return &quot;&quot;;</span>
            }
            
<span class="nc" id="L485">            StringBuilder sql = new StringBuilder();</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">            for (int i = 0; i &lt; conditions.size(); i++) {</span>
<span class="nc" id="L487">                WhereCondition cond = conditions.get(i);</span>
                
<span class="nc bnc" id="L489" title="All 2 branches missed.">                if (i &gt; 0) {</span>
<span class="nc" id="L490">                    sql.append(&quot; &quot;).append(cond.connector).append(&quot; &quot;);</span>
                }
                
<span class="nc" id="L493">                sql.append(cond.field).append(&quot; &quot;).append(cond.operator.toSql());</span>
                
                // Handle operators that don't need values
<span class="nc bnc" id="L496" title="All 4 branches missed.">                if (cond.operator != Operator.IS_NULL &amp;&amp; cond.operator != Operator.IS_NOT_NULL) {</span>
<span class="nc" id="L497">                    sql.append(&quot; &quot;).append(cond.value);</span>
                }
            }
            
<span class="nc" id="L501">            return sql.toString();</span>
        }
    }
    
    private static class OrderByColumn {
        final String column;
        final Order order;
        
<span class="nc" id="L509">        OrderByColumn(String column, Order order) {</span>
<span class="nc" id="L510">            this.column = column;</span>
<span class="nc" id="L511">            this.order = order;</span>
<span class="nc" id="L512">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>