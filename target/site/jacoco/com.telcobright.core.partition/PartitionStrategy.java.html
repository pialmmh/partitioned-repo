<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PartitionStrategy.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Generic Sharding-Aware Repository Framework</a> &gt; <a href="index.source.html" class="el_package">com.telcobright.core.partition</a> &gt; <span class="el_source">PartitionStrategy.java</span></div><h1>PartitionStrategy.java</h1><pre class="source lang-java linenums">package com.telcobright.core.partition;

import com.telcobright.core.entity.ShardingEntity;
import java.sql.Connection;
import java.sql.SQLException;
import java.time.LocalDateTime;
import java.util.List;

/**
 * Interface for different partitioning strategies.
 * 
 * Implementations define how data is partitioned within a single shard/table.
 * This is different from sharding (distributing across databases) - this is
 * about partitioning within a single database table.
 * 
 * @param &lt;T&gt; Entity type that implements ShardingEntity
 */
public interface PartitionStrategy&lt;T extends ShardingEntity&gt; {
    
    /**
     * Get the partition type this strategy implements.
     */
    PartitionType getType();
    
    /**
     * Generate the PARTITION BY clause for CREATE TABLE statement.
     * 
     * @param partitionKeyColumn The column to partition by
     * @return SQL partition clause (e.g., &quot;PARTITION BY RANGE (TO_DAYS(created_at))&quot;)
     */
    String generatePartitionByClause(String partitionKeyColumn);
    
    /**
     * Generate initial partition definitions for CREATE TABLE.
     * 
     * @param startValue Starting value for partitions
     * @param endValue Ending value for partitions
     * @return SQL partition definitions
     */
    String generateInitialPartitions(Object startValue, Object endValue);
    
    /**
     * Create a new partition.
     * 
     * @param connection Database connection
     * @param tableName Full table name (database.table)
     * @param partitionName Name of the partition to create
     * @param partitionValue Value/boundary for the partition
     * @throws SQLException if partition creation fails
     */
    void createPartition(Connection connection, String tableName, 
                        String partitionName, Object partitionValue) throws SQLException;
    
    /**
     * Drop an old partition.
     * 
     * @param connection Database connection
     * @param tableName Full table name (database.table)
     * @param partitionName Name of the partition to drop
     * @throws SQLException if partition drop fails
     */
    void dropPartition(Connection connection, String tableName, 
                      String partitionName) throws SQLException;
    
    /**
     * Get list of existing partitions.
     * 
     * @param connection Database connection
     * @param database Database name
     * @param tableName Table name (without database prefix)
     * @return List of partition names
     * @throws SQLException if query fails
     */
    List&lt;String&gt; getPartitions(Connection connection, String database, 
                               String tableName) throws SQLException;
    
    /**
     * Check if a partition exists.
     * 
     * @param connection Database connection
     * @param database Database name
     * @param tableName Table name
     * @param partitionName Partition name to check
     * @return true if partition exists
     * @throws SQLException if query fails
     */
    boolean partitionExists(Connection connection, String database, 
                           String tableName, String partitionName) throws SQLException;
    
    /**
     * Generate partition name based on value.
     * 
     * @param value Value to generate partition name from
     * @return Partition name (e.g., &quot;p20250912&quot; for date-based)
     */
    String generatePartitionName(Object value);
    
    /**
     * Get the partition key column name for this strategy.
     * 
     * @return Column name used for partitioning
     */
    String getPartitionKeyColumn();
    
    /**
     * Validate that the entity is compatible with this partition strategy.
     * 
     * @param entityClass Entity class to validate
     * @throws IllegalArgumentException if entity is not compatible
     */
    void validateEntity(Class&lt;T&gt; entityClass);
    
    /**
     * Get partitions that should be created for a retention period.
     * 
     * @param retentionDays Number of days to retain data
     * @return List of partition definitions
     */
    List&lt;PartitionDefinition&gt; getPartitionsForRetentionPeriod(int retentionDays);
    
    /**
     * Get partitions that are older than the cutoff and should be dropped.
     * 
     * @param connection Database connection
     * @param database Database name
     * @param tableName Table name
     * @param cutoffValue Cutoff value (e.g., LocalDateTime for date-based)
     * @return List of partition names to drop
     * @throws SQLException if query fails
     */
    List&lt;String&gt; getPartitionsToDropp(Connection connection, String database, 
                                     String tableName, Object cutoffValue) throws SQLException;
    
    /**
     * Inner class to define a partition.
     */
    class PartitionDefinition {
        private final String name;
        private final Object lessThanValue;
        
<span class="nc" id="L141">        public PartitionDefinition(String name, Object lessThanValue) {</span>
<span class="nc" id="L142">            this.name = name;</span>
<span class="nc" id="L143">            this.lessThanValue = lessThanValue;</span>
<span class="nc" id="L144">        }</span>
        
<span class="nc" id="L146">        public String getName() { return name; }</span>
<span class="nc" id="L147">        public Object getLessThanValue() { return lessThanValue; }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>