<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MySQLPersistenceProvider.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Generic Sharding-Aware Repository Framework</a> &gt; <a href="index.source.html" class="el_package">com.telcobright.core.persistence</a> &gt; <span class="el_source">MySQLPersistenceProvider.java</span></div><h1>MySQLPersistenceProvider.java</h1><pre class="source lang-java linenums">package com.telcobright.core.persistence;

import com.telcobright.core.entity.ShardingEntity;
import com.telcobright.core.metadata.EntityMetadata;
import com.telcobright.core.metadata.FieldMetadata;
import com.telcobright.core.sql.SqlStatementCache;
import java.sql.*;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.StringJoiner;
import java.util.stream.Collectors;

/**
 * MySQL-specific persistence provider implementation.
 * Optimized for MySQL with features like extended INSERT syntax for bulk operations.
 *
 * @author Split-Verse Framework
 */
public class MySQLPersistenceProvider implements PersistenceProvider {

    private static final String JDBC_PREFIX = &quot;jdbc:mysql://&quot;;
    private static final int DEFAULT_PORT = 3306;
    private final SqlStatementCache sqlCache;

<span class="nc" id="L26">    public MySQLPersistenceProvider() {</span>
<span class="nc" id="L27">        this.sqlCache = null;</span>
<span class="nc" id="L28">    }</span>

<span class="fc" id="L30">    public MySQLPersistenceProvider(SqlStatementCache cache) {</span>
<span class="fc" id="L31">        this.sqlCache = cache;</span>
<span class="fc" id="L32">    }</span>

    @Override
    public DatabaseType getDatabaseType() {
<span class="nc" id="L36">        return DatabaseType.MYSQL;</span>
    }

    @Override
    public String generateCreateTableSQL(String tableName, EntityMetadata&lt;?&gt; metadata,
                                        String charset, String collation) {
<span class="fc" id="L42">        StringBuilder sql = new StringBuilder(&quot;CREATE TABLE IF NOT EXISTS &quot;).append(tableName).append(&quot; (&quot;);</span>

        // Add columns
<span class="fc" id="L45">        metadata.getFields().forEach(field -&gt; {</span>
<span class="fc" id="L46">            sql.append(&quot;\n  &quot;).append(field.getColumnName()).append(&quot; &quot;);</span>

            // Map Java types to MySQL types
<span class="fc" id="L49">            Class&lt;?&gt; type = field.getType();</span>
<span class="fc bfc" id="L50" title="All 2 branches covered.">            if (type == String.class) {</span>
<span class="fc bfc" id="L51" title="All 2 branches covered.">                if (field.isId()) {</span>
<span class="fc" id="L52">                    sql.append(&quot;VARCHAR(255)&quot;);</span>
                } else {
<span class="fc" id="L54">                    sql.append(&quot;TEXT&quot;);</span>
                }
<span class="pc bpc" id="L56" title="1 of 4 branches missed.">            } else if (type == Long.class || type == long.class) {</span>
<span class="fc" id="L57">                sql.append(&quot;BIGINT&quot;);</span>
<span class="pc bpc" id="L58" title="1 of 4 branches missed.">            } else if (type == Integer.class || type == int.class) {</span>
<span class="fc" id="L59">                sql.append(&quot;INT&quot;);</span>
<span class="pc bpc" id="L60" title="1 of 4 branches missed.">            } else if (type == Double.class || type == double.class) {</span>
<span class="fc" id="L61">                sql.append(&quot;DOUBLE&quot;);</span>
<span class="pc bpc" id="L62" title="2 of 4 branches missed.">            } else if (type == Float.class || type == float.class) {</span>
<span class="nc" id="L63">                sql.append(&quot;FLOAT&quot;);</span>
<span class="pc bpc" id="L64" title="2 of 4 branches missed.">            } else if (type == Boolean.class || type == boolean.class) {</span>
<span class="nc" id="L65">                sql.append(&quot;BOOLEAN&quot;);</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">            } else if (type == LocalDateTime.class) {</span>
<span class="fc" id="L67">                sql.append(&quot;DATETIME(6)&quot;);</span>
<span class="pc bpc" id="L68" title="1 of 2 branches missed.">            } else if (type == java.time.LocalDate.class) {</span>
<span class="nc" id="L69">                sql.append(&quot;DATE&quot;);</span>
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">            } else if (type == java.time.LocalTime.class) {</span>
<span class="nc" id="L71">                sql.append(&quot;TIME&quot;);</span>
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">            } else if (type == java.math.BigDecimal.class) {</span>
<span class="nc" id="L73">                sql.append(&quot;DECIMAL(19,4)&quot;);</span>
            } else {
<span class="fc" id="L75">                sql.append(&quot;TEXT&quot;);</span>
            }

            // Add constraints
<span class="fc bfc" id="L79" title="All 2 branches covered.">            if (field.isId()) {</span>
<span class="fc" id="L80">                sql.append(&quot; PRIMARY KEY&quot;);</span>
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">            } else if (!field.isNullable()) {</span>
<span class="nc" id="L82">                sql.append(&quot; NOT NULL&quot;);</span>
            }

<span class="fc" id="L85">            sql.append(&quot;,&quot;);</span>
<span class="fc" id="L86">        });</span>

        // Add indexes for sharding key
<span class="pc bpc" id="L89" title="1 of 2 branches missed.">        if (metadata.getShardingKeyField() != null) {</span>
<span class="fc" id="L90">            sql.append(&quot;\n  INDEX idx_&quot;).append(metadata.getShardingKeyField().getColumnName())</span>
<span class="fc" id="L91">               .append(&quot; (&quot;).append(metadata.getShardingKeyField().getColumnName()).append(&quot;),&quot;);</span>
        }

        // Remove trailing comma
<span class="pc bpc" id="L95" title="1 of 2 branches missed.">        if (sql.charAt(sql.length() - 1) == ',') {</span>
<span class="fc" id="L96">            sql.setLength(sql.length() - 1);</span>
        }

<span class="fc" id="L99">        sql.append(&quot;\n) ENGINE=InnoDB&quot;);</span>

        // Add charset and collation
<span class="pc bpc" id="L102" title="2 of 4 branches missed.">        if (charset != null &amp;&amp; !charset.isEmpty()) {</span>
<span class="fc" id="L103">            sql.append(&quot; DEFAULT CHARSET=&quot;).append(charset);</span>
        }
<span class="pc bpc" id="L105" title="2 of 4 branches missed.">        if (collation != null &amp;&amp; !collation.isEmpty()) {</span>
<span class="fc" id="L106">            sql.append(&quot; COLLATE=&quot;).append(collation);</span>
        }

<span class="fc" id="L109">        return sql.toString();</span>
    }

    @Override
    public String generateInsertSQL(String tableName, EntityMetadata&lt;?&gt; metadata) {
<span class="fc" id="L114">        StringBuilder sql = new StringBuilder(&quot;INSERT INTO &quot;).append(tableName).append(&quot; (&quot;);</span>
<span class="fc" id="L115">        StringBuilder values = new StringBuilder(&quot; VALUES (&quot;);</span>

<span class="fc" id="L117">        metadata.getFields().forEach(field -&gt; {</span>
<span class="fc" id="L118">            sql.append(field.getColumnName()).append(&quot;, &quot;);</span>
<span class="fc" id="L119">            values.append(&quot;?, &quot;);</span>
<span class="fc" id="L120">        });</span>

        // Remove trailing commas
<span class="fc" id="L123">        sql.setLength(sql.length() - 2);</span>
<span class="fc" id="L124">        values.setLength(values.length() - 2);</span>

<span class="fc" id="L126">        sql.append(&quot;)&quot;).append(values).append(&quot;)&quot;);</span>
<span class="fc" id="L127">        return sql.toString();</span>
    }

    @Override
    public String generateBulkInsertSQL(String tableName, EntityMetadata&lt;?&gt; metadata, int entityCount) {
<span class="nc bnc" id="L132" title="All 2 branches missed.">        if (entityCount &lt;= 0) {</span>
<span class="nc" id="L133">            throw new IllegalArgumentException(&quot;Entity count must be positive&quot;);</span>
        }

        // Check cache first if available
<span class="nc bnc" id="L137" title="All 2 branches missed.">        if (sqlCache != null) {</span>
<span class="nc" id="L138">            SqlStatementCache.StatementType cacheType = getCacheTypeForBatchSize(entityCount);</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">            if (cacheType != null) {</span>
<span class="nc" id="L140">                Class&lt;?&gt; entityClass = metadata.getClass();</span>
                // Extract entity class from metadata - need to get the actual entity class, not metadata class
                // This is a workaround - in production, we'd pass the entity class explicitly
<span class="nc" id="L143">                String cachedSql = sqlCache.get(entityClass, tableName, cacheType);</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">                if (cachedSql != null) {</span>
<span class="nc" id="L145">                    return cachedSql;</span>
                }
            }
        }

<span class="nc" id="L150">        StringBuilder sql = new StringBuilder(&quot;INSERT INTO &quot;).append(tableName).append(&quot; (&quot;);</span>

        // Add column names
<span class="nc" id="L153">        String columns = metadata.getFields().stream()</span>
<span class="nc" id="L154">            .map(FieldMetadata::getColumnName)</span>
<span class="nc" id="L155">            .collect(Collectors.joining(&quot;, &quot;));</span>
<span class="nc" id="L156">        sql.append(columns).append(&quot;) VALUES &quot;);</span>

        // Add value placeholders for each entity
        // MySQL extended INSERT syntax: INSERT INTO table (cols) VALUES (?,?), (?,?), (?,?)
<span class="nc" id="L160">        StringJoiner valueGroups = new StringJoiner(&quot;, &quot;);</span>
<span class="nc" id="L161">        String singleValueGroup = &quot;(&quot; +</span>
<span class="nc" id="L162">            metadata.getFields().stream()</span>
<span class="nc" id="L163">                .map(f -&gt; &quot;?&quot;)</span>
<span class="nc" id="L164">                .collect(Collectors.joining(&quot;, &quot;)) + &quot;)&quot;;</span>

<span class="nc bnc" id="L166" title="All 2 branches missed.">        for (int i = 0; i &lt; entityCount; i++) {</span>
<span class="nc" id="L167">            valueGroups.add(singleValueGroup);</span>
        }

<span class="nc" id="L170">        sql.append(valueGroups.toString());</span>
<span class="nc" id="L171">        String sqlString = sql.toString();</span>

        // Store in cache if available and if it's a standard batch size
<span class="nc bnc" id="L174" title="All 2 branches missed.">        if (sqlCache != null) {</span>
<span class="nc" id="L175">            SqlStatementCache.StatementType cacheType = getCacheTypeForBatchSize(entityCount);</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">            if (cacheType != null) {</span>
                // We need the actual entity class - this is a limitation we'd fix in production
                // For now, we won't cache here as we don't have the entity class
                // The SqlGeneratorByEntityRegistry will handle pre-generation instead
            }
        }

<span class="nc" id="L183">        return sqlString;</span>
    }

    private SqlStatementCache.StatementType getCacheTypeForBatchSize(int size) {
<span class="nc bnc" id="L187" title="All 2 branches missed.">        if (size == 1) return SqlStatementCache.StatementType.INSERT_SINGLE;</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">        if (size == 10) return SqlStatementCache.StatementType.INSERT_BATCH_10;</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">        if (size == 100) return SqlStatementCache.StatementType.INSERT_BATCH_100;</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">        if (size == 1000) return SqlStatementCache.StatementType.INSERT_BATCH_1000;</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">        if (size == 5000) return SqlStatementCache.StatementType.INSERT_BATCH_5000;</span>
<span class="nc" id="L192">        return null; // Don't cache other sizes</span>
    }

    @Override
    public String generateUpdateSQL(String tableName, EntityMetadata&lt;?&gt; metadata) {
<span class="nc" id="L197">        StringBuilder sql = new StringBuilder(&quot;UPDATE &quot;).append(tableName).append(&quot; SET &quot;);</span>

<span class="nc" id="L199">        metadata.getFields().stream()</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">            .filter(field -&gt; !field.isId())</span>
<span class="nc" id="L201">            .forEach(field -&gt; sql.append(field.getColumnName()).append(&quot; = ?, &quot;));</span>

        // Remove trailing comma
<span class="nc" id="L204">        sql.setLength(sql.length() - 2);</span>

        // Add WHERE clause for ID
<span class="nc" id="L207">        sql.append(&quot; WHERE &quot;).append(metadata.getIdField().getColumnName()).append(&quot; = ?&quot;);</span>

<span class="nc" id="L209">        return sql.toString();</span>
    }

    @Override
    public String generateDeleteSQL(String tableName, String idColumn) {
<span class="nc" id="L214">        return &quot;DELETE FROM &quot; + tableName + &quot; WHERE &quot; + idColumn + &quot; = ?&quot;;</span>
    }

    @Override
    public String generateSelectByIdSQL(String tableName, EntityMetadata&lt;?&gt; metadata) {
<span class="nc" id="L219">        String columns = metadata.getFields().stream()</span>
<span class="nc" id="L220">            .map(FieldMetadata::getColumnName)</span>
<span class="nc" id="L221">            .collect(Collectors.joining(&quot;, &quot;));</span>

<span class="nc" id="L223">        return &quot;SELECT &quot; + columns + &quot; FROM &quot; + tableName +</span>
<span class="nc" id="L224">               &quot; WHERE &quot; + metadata.getIdField().getColumnName() + &quot; = ?&quot;;</span>
    }

    @Override
    public String generateSelectByDateRangeSQL(String tableName, EntityMetadata&lt;?&gt; metadata,
                                              String dateColumn) {
<span class="nc" id="L230">        String columns = metadata.getFields().stream()</span>
<span class="nc" id="L231">            .map(FieldMetadata::getColumnName)</span>
<span class="nc" id="L232">            .collect(Collectors.joining(&quot;, &quot;));</span>

<span class="nc" id="L234">        return &quot;SELECT &quot; + columns + &quot; FROM &quot; + tableName +</span>
               &quot; WHERE &quot; + dateColumn + &quot; &gt;= ? AND &quot; + dateColumn + &quot; &lt;= ?&quot; +
               &quot; ORDER BY &quot; + dateColumn;
    }

    @Override
    public String generateSelectWithPaginationSQL(String tableName, EntityMetadata&lt;?&gt; metadata,
                                                 String orderByColumn, boolean ascending,
                                                 int limit, int offset) {
<span class="nc" id="L243">        String columns = metadata.getFields().stream()</span>
<span class="nc" id="L244">            .map(FieldMetadata::getColumnName)</span>
<span class="nc" id="L245">            .collect(Collectors.joining(&quot;, &quot;));</span>

<span class="nc bnc" id="L247" title="All 2 branches missed.">        String orderDirection = ascending ? &quot;ASC&quot; : &quot;DESC&quot;;</span>

<span class="nc" id="L249">        return &quot;SELECT &quot; + columns + &quot; FROM &quot; + tableName +</span>
               &quot; ORDER BY &quot; + orderByColumn + &quot; &quot; + orderDirection +
               &quot; LIMIT &quot; + limit + &quot; OFFSET &quot; + offset;
    }

    @Override
    public &lt;T extends ShardingEntity&gt; int executeBulkInsert(Connection connection, List&lt;T&gt; entities,
                                                           String tableName, EntityMetadata&lt;T&gt; metadata)
                                                           throws SQLException {
<span class="nc bnc" id="L258" title="All 4 branches missed.">        if (entities == null || entities.isEmpty()) {</span>
<span class="nc" id="L259">            return 0;</span>
        }

        // Use MySQL extended INSERT syntax for optimal performance
        // INSERT INTO table (cols) VALUES (row1), (row2), (row3)...
<span class="nc" id="L264">        String sql = generateBulkInsertSQL(tableName, metadata, entities.size());</span>

<span class="nc" id="L266">        try (PreparedStatement stmt = connection.prepareStatement(sql)) {</span>
<span class="nc" id="L267">            int paramIndex = 1;</span>

            // Set parameters for all entities
<span class="nc bnc" id="L270" title="All 2 branches missed.">            for (T entity : entities) {</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">                for (FieldMetadata field : metadata.getFields()) {</span>
<span class="nc" id="L272">                    Object value = field.getValue(entity);</span>
<span class="nc" id="L273">                    setParameter(stmt, paramIndex++, value);</span>
<span class="nc" id="L274">                }</span>
<span class="nc" id="L275">            }</span>

<span class="nc" id="L277">            return stmt.executeUpdate();</span>
        }
    }

    @Override
    public &lt;T extends ShardingEntity&gt; String executeInsert(Connection connection, T entity,
                                                          String tableName, EntityMetadata&lt;T&gt; metadata)
                                                          throws SQLException {
<span class="fc" id="L285">        String sql = generateInsertSQL(tableName, metadata);</span>

<span class="fc" id="L287">        try (PreparedStatement stmt = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {</span>
            // Set parameters
<span class="fc" id="L289">            metadata.setInsertParameters(stmt, entity);</span>

<span class="fc" id="L291">            int affectedRows = stmt.executeUpdate();</span>
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">            if (affectedRows == 0) {</span>
<span class="nc" id="L293">                throw new SQLException(&quot;Creating entity failed, no rows affected.&quot;);</span>
            }

            // Return the ID (which should already be set on the entity for String IDs)
<span class="fc" id="L297">            return entity.getId();</span>
        }
    }

    @Override
    public &lt;T extends ShardingEntity&gt; int executeUpdate(Connection connection, T entity,
                                                       String tableName, EntityMetadata&lt;T&gt; metadata)
                                                       throws SQLException {
<span class="nc" id="L305">        String sql = generateUpdateSQL(tableName, metadata);</span>

<span class="nc" id="L307">        try (PreparedStatement stmt = connection.prepareStatement(sql)) {</span>
<span class="nc" id="L308">            int paramIndex = 1;</span>

            // Set non-ID field values
<span class="nc bnc" id="L311" title="All 2 branches missed.">            for (FieldMetadata field : metadata.getFields()) {</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">                if (!field.isId()) {</span>
<span class="nc" id="L313">                    Object value = field.getValue(entity);</span>
<span class="nc" id="L314">                    setParameter(stmt, paramIndex++, value);</span>
                }
<span class="nc" id="L316">            }</span>

            // Set ID for WHERE clause
<span class="nc" id="L319">            stmt.setString(paramIndex, entity.getId());</span>

<span class="nc" id="L321">            return stmt.executeUpdate();</span>
        }
    }

    @Override
    public int executeDelete(Connection connection, String id, String tableName, String idColumn)
                            throws SQLException {
<span class="nc" id="L328">        String sql = generateDeleteSQL(tableName, idColumn);</span>

<span class="nc" id="L330">        try (PreparedStatement stmt = connection.prepareStatement(sql)) {</span>
<span class="nc" id="L331">            stmt.setString(1, id);</span>
<span class="nc" id="L332">            return stmt.executeUpdate();</span>
        }
    }

    @Override
    public &lt;T extends ShardingEntity&gt; T mapResultSetToEntity(ResultSet rs, EntityMetadata&lt;T&gt; metadata)
                                                            throws SQLException {
<span class="nc" id="L339">        return metadata.mapResultSet(rs);</span>
    }

    @Override
    public boolean tableExists(Connection connection, String schema, String tableName) throws SQLException {
<span class="nc" id="L344">        String sql = &quot;SELECT 1 FROM information_schema.tables WHERE table_schema = ? AND table_name = ?&quot;;</span>

<span class="nc" id="L346">        try (PreparedStatement stmt = connection.prepareStatement(sql)) {</span>
<span class="nc" id="L347">            stmt.setString(1, schema);</span>
<span class="nc" id="L348">            stmt.setString(2, tableName);</span>

<span class="nc" id="L350">            try (ResultSet rs = stmt.executeQuery()) {</span>
<span class="nc" id="L351">                return rs.next();</span>
            }
        }
    }

    @Override
    public void dropTableIfExists(Connection connection, String tableName) throws SQLException {
<span class="nc" id="L358">        String sql = &quot;DROP TABLE IF EXISTS &quot; + tableName;</span>

<span class="nc" id="L360">        try (Statement stmt = connection.createStatement()) {</span>
<span class="nc" id="L361">            stmt.execute(sql);</span>
        }
<span class="nc" id="L363">    }</span>

    @Override
    public String getCurrentTimestampFunction() {
<span class="nc" id="L367">        return &quot;NOW(6)&quot;; // MySQL with microsecond precision</span>
    }

    @Override
    public String getConcatenationOperator() {
<span class="nc" id="L372">        return &quot;CONCAT&quot;;</span>
    }

    @Override
    public String getLimitOffsetClause(int limit, int offset) {
<span class="nc bnc" id="L377" title="All 2 branches missed.">        if (offset &gt; 0) {</span>
<span class="nc" id="L378">            return &quot; LIMIT &quot; + limit + &quot; OFFSET &quot; + offset;</span>
        }
<span class="nc" id="L380">        return &quot; LIMIT &quot; + limit;</span>
    }

    @Override
    public boolean isConnectionValid(Connection connection) throws SQLException {
<span class="nc bnc" id="L385" title="All 6 branches missed.">        return connection != null &amp;&amp; !connection.isClosed() &amp;&amp; connection.isValid(1);</span>
    }

    @Override
    public String getConnectionUrl(String host, int port, String database, Map&lt;String, String&gt; additionalParams) {
<span class="nc" id="L390">        StringBuilder url = new StringBuilder(JDBC_PREFIX);</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">        url.append(host).append(&quot;:&quot;).append(port &gt; 0 ? port : DEFAULT_PORT);</span>
<span class="nc" id="L392">        url.append(&quot;/&quot;).append(database);</span>

        // Add default parameters
<span class="nc" id="L395">        url.append(&quot;?useSSL=false&quot;);</span>
<span class="nc" id="L396">        url.append(&quot;&amp;serverTimezone=UTC&quot;);</span>
<span class="nc" id="L397">        url.append(&quot;&amp;useLegacyDatetimeCode=false&quot;);</span>
<span class="nc" id="L398">        url.append(&quot;&amp;preserveInstants=true&quot;);</span>
<span class="nc" id="L399">        url.append(&quot;&amp;rewriteBatchedStatements=true&quot;); // Important for bulk insert performance</span>
<span class="nc" id="L400">        url.append(&quot;&amp;useServerPrepStmts=true&quot;);</span>
<span class="nc" id="L401">        url.append(&quot;&amp;cachePrepStmts=true&quot;);</span>

        // Add additional parameters
<span class="nc bnc" id="L404" title="All 4 branches missed.">        if (additionalParams != null &amp;&amp; !additionalParams.isEmpty()) {</span>
<span class="nc" id="L405">            additionalParams.forEach((key, value) -&gt;</span>
<span class="nc" id="L406">                url.append(&quot;&amp;&quot;).append(key).append(&quot;=&quot;).append(value)</span>
            );
        }

<span class="nc" id="L410">        return url.toString();</span>
    }

    /**
     * Helper method to set parameter values with proper type handling
     */
    private void setParameter(PreparedStatement stmt, int index, Object value) throws SQLException {
<span class="nc bnc" id="L417" title="All 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L418">            stmt.setNull(index, Types.NULL);</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">        } else if (value instanceof String) {</span>
<span class="nc" id="L420">            stmt.setString(index, (String) value);</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">        } else if (value instanceof Long) {</span>
<span class="nc" id="L422">            stmt.setLong(index, (Long) value);</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">        } else if (value instanceof Integer) {</span>
<span class="nc" id="L424">            stmt.setInt(index, (Integer) value);</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">        } else if (value instanceof Double) {</span>
<span class="nc" id="L426">            stmt.setDouble(index, (Double) value);</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">        } else if (value instanceof Float) {</span>
<span class="nc" id="L428">            stmt.setFloat(index, (Float) value);</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">        } else if (value instanceof Boolean) {</span>
<span class="nc" id="L430">            stmt.setBoolean(index, (Boolean) value);</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">        } else if (value instanceof LocalDateTime) {</span>
<span class="nc" id="L432">            stmt.setTimestamp(index, Timestamp.valueOf((LocalDateTime) value));</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">        } else if (value instanceof java.time.LocalDate) {</span>
<span class="nc" id="L434">            stmt.setDate(index, Date.valueOf((java.time.LocalDate) value));</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">        } else if (value instanceof java.time.LocalTime) {</span>
<span class="nc" id="L436">            stmt.setTime(index, Time.valueOf((java.time.LocalTime) value));</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">        } else if (value instanceof java.math.BigDecimal) {</span>
<span class="nc" id="L438">            stmt.setBigDecimal(index, (java.math.BigDecimal) value);</span>
        } else {
<span class="nc" id="L440">            stmt.setObject(index, value);</span>
        }
<span class="nc" id="L442">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>