<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SimpleSequentialRepository.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Generic Sharding-Aware Repository Framework</a> &gt; <a href="index.source.html" class="el_package">com.telcobright.core.repository</a> &gt; <span class="el_source">SimpleSequentialRepository.java</span></div><h1>SimpleSequentialRepository.java</h1><pre class="source lang-java linenums">package com.telcobright.core.repository;

import com.telcobright.api.ShardingRepository;
import com.telcobright.core.entity.ShardingEntity;
import com.telcobright.core.connection.ConnectionProvider;
import com.telcobright.core.metadata.EntityMetadata;
import com.telcobright.core.metadata.FieldMetadata;
import com.telcobright.core.enums.PartitionRange;
import com.telcobright.core.logging.Logger;
import com.telcobright.core.logging.ConsoleLogger;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Simple Sequential Repository with automatic ID management.
 *
 * Features:
 * - Integer/Long based sequential IDs only (no String IDs)
 * - Built-in ID generation with getNextId() and getNextN()
 * - Automatic state management and persistence
 * - Wraparound support when max value exceeded
 * - Date-based partitioning for log rotation
 * - Thread-safe ID generation
 *
 * Use Case: High-performance sequential log storage with guaranteed ordering
 *
 * @param &lt;T&gt; Entity type that implements ShardingEntity&lt;LocalDateTime&gt;
 */
public class SimpleSequentialRepository&lt;T extends ShardingEntity&lt;LocalDateTime&gt;&gt; {

    private final Logger logger;
    private final ShardingRepository&lt;T, LocalDateTime&gt; delegateRepo;
    private final ConnectionProvider connectionProvider;
    private final String database;
    private final String tableName;
    private final String stateTableName;
    private final long maxId;
    private final boolean wrapAround;
    private final boolean allowClientIds;

    // State management
<span class="fc" id="L49">    private final AtomicLong currentId = new AtomicLong(0);</span>
<span class="fc" id="L50">    private final ReentrantLock idLock = new ReentrantLock();</span>
<span class="fc" id="L51">    private volatile long lastPersistedId = 0;</span>
    private static final long PERSIST_THRESHOLD = 1000; // Persist state every 1000 IDs

<span class="fc" id="L54">    private SimpleSequentialRepository(Builder&lt;T&gt; builder) {</span>
<span class="fc" id="L55">        this.database = builder.database;</span>
<span class="fc" id="L56">        this.tableName = builder.tableName;</span>
<span class="fc" id="L57">        this.stateTableName = tableName + &quot;_seq_state&quot;;</span>
<span class="fc" id="L58">        this.maxId = builder.maxId;</span>
<span class="fc" id="L59">        this.wrapAround = builder.wrapAround;</span>
<span class="fc" id="L60">        this.allowClientIds = builder.allowClientIds;</span>

<span class="fc" id="L62">        String loggerName = String.format(&quot;SimpleSeqRepo.%s&quot;, tableName);</span>
<span class="fc" id="L63">        this.logger = new ConsoleLogger(loggerName);</span>

        // Initialize connection provider
<span class="fc" id="L66">        this.connectionProvider = new ConnectionProvider(</span>
            builder.host, builder.port, database,
            builder.username, builder.password
        );

        // Create delegate repository using GenericPartitionedTableRepository
<span class="fc" id="L72">        this.delegateRepo = GenericPartitionedTableRepository.&lt;T, LocalDateTime&gt;builder(builder.entityClass)</span>
<span class="fc" id="L73">            .host(builder.host)</span>
<span class="fc" id="L74">            .port(builder.port)</span>
<span class="fc" id="L75">            .database(database)</span>
<span class="fc" id="L76">            .username(builder.username)</span>
<span class="fc" id="L77">            .password(builder.password)</span>
<span class="fc" id="L78">            .tableName(tableName)</span>
<span class="fc" id="L79">            .partitionRetentionPeriod(builder.retentionDays)</span>
<span class="fc" id="L80">            .autoManagePartitions(builder.autoMaintenance)</span>
<span class="fc" id="L81">            .partitionAdjustmentTime(builder.maintenanceTime)</span>
<span class="fc" id="L82">            .initializePartitionsOnStart(true)</span>
<span class="fc" id="L83">            .charset(&quot;utf8mb4&quot;)</span>
<span class="fc" id="L84">            .collation(&quot;utf8mb4_bin&quot;)</span>
<span class="fc" id="L85">            .build();</span>

<span class="fc" id="L87">        logger.info(String.format(</span>
            &quot;Initializing SimpleSequentialRepository: table=%s, maxId=%d, wrapAround=%s&quot;,
<span class="fc" id="L89">            tableName, maxId, wrapAround</span>
        ));

        // Initialize state management
<span class="fc" id="L93">        initializeStateManagement();</span>
<span class="fc" id="L94">    }</span>

    private void initializeStateManagement() {
<span class="fc" id="L97">        try (Connection conn = connectionProvider.getConnection()) {</span>
            // Create state table if not exists
<span class="fc" id="L99">            createStateTable(conn);</span>

            // Load last ID from state table
<span class="fc" id="L102">            loadLastId(conn);</span>

<span class="fc" id="L104">            logger.info(&quot;State management initialized, starting from ID: &quot; + currentId.get());</span>
<span class="nc" id="L105">        } catch (SQLException e) {</span>
<span class="nc" id="L106">            throw new RuntimeException(&quot;Failed to initialize state management: &quot; + e.getMessage(), e);</span>
<span class="fc" id="L107">        }</span>
<span class="fc" id="L108">    }</span>

    private void createStateTable(Connection conn) throws SQLException {
<span class="fc" id="L111">        String sql = String.format(</span>
            &quot;CREATE TABLE IF NOT EXISTS %s.%s (&quot; +
            &quot;  table_name VARCHAR(255) PRIMARY KEY,&quot; +
            &quot;  last_id BIGINT NOT NULL DEFAULT 0,&quot; +
            &quot;  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP&quot; +
            &quot;) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4&quot;,
            database, stateTableName
        );

<span class="fc" id="L120">        try (Statement stmt = conn.createStatement()) {</span>
<span class="fc" id="L121">            stmt.execute(sql);</span>
        }

        // Insert initial record if not exists
<span class="fc" id="L125">        String insertSql = String.format(</span>
            &quot;INSERT IGNORE INTO %s.%s (table_name, last_id) VALUES (?, 0)&quot;,
            database, stateTableName
        );

<span class="fc" id="L130">        try (PreparedStatement stmt = conn.prepareStatement(insertSql)) {</span>
<span class="fc" id="L131">            stmt.setString(1, tableName);</span>
<span class="fc" id="L132">            stmt.executeUpdate();</span>
        }
<span class="fc" id="L134">    }</span>

    private void loadLastId(Connection conn) throws SQLException {
<span class="fc" id="L137">        String sql = String.format(</span>
            &quot;SELECT last_id FROM %s.%s WHERE table_name = ?&quot;,
            database, stateTableName
        );

<span class="fc" id="L142">        try (PreparedStatement stmt = conn.prepareStatement(sql)) {</span>
<span class="fc" id="L143">            stmt.setString(1, tableName);</span>

<span class="fc" id="L145">            try (ResultSet rs = stmt.executeQuery()) {</span>
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">                if (rs.next()) {</span>
<span class="fc" id="L147">                    long lastId = rs.getLong(&quot;last_id&quot;);</span>
<span class="fc" id="L148">                    currentId.set(lastId);</span>
<span class="fc" id="L149">                    lastPersistedId = lastId;</span>
                }
            }
        }
<span class="fc" id="L153">    }</span>

    private void persistCurrentId() {
<span class="fc" id="L156">        try (Connection conn = connectionProvider.getConnection()) {</span>
<span class="fc" id="L157">            String sql = String.format(</span>
                &quot;UPDATE %s.%s SET last_id = ?, updated_at = CURRENT_TIMESTAMP WHERE table_name = ?&quot;,
                database, stateTableName
            );

<span class="fc" id="L162">            try (PreparedStatement stmt = conn.prepareStatement(sql)) {</span>
<span class="fc" id="L163">                long idToPersist = currentId.get();</span>
<span class="fc" id="L164">                stmt.setLong(1, idToPersist);</span>
<span class="fc" id="L165">                stmt.setString(2, tableName);</span>
<span class="fc" id="L166">                stmt.executeUpdate();</span>
<span class="fc" id="L167">                lastPersistedId = idToPersist;</span>

<span class="fc" id="L169">                logger.debug(&quot;Persisted current ID: &quot; + idToPersist);</span>
            }
<span class="nc" id="L171">        } catch (SQLException e) {</span>
<span class="nc" id="L172">            logger.error(&quot;Failed to persist current ID: &quot; + e.getMessage(), e);</span>
<span class="fc" id="L173">        }</span>
<span class="fc" id="L174">    }</span>

    /**
     * Get the next sequential ID.
     * Thread-safe and automatically handles wraparound if configured.
     *
     * @return The next sequential ID
     * @throws IllegalStateException if max ID reached and wraparound disabled
     */
    public long getNextId() {
<span class="fc" id="L184">        idLock.lock();</span>
        try {
<span class="fc" id="L186">            long nextId = currentId.incrementAndGet();</span>

            // Check for max ID
<span class="fc bfc" id="L189" title="All 2 branches covered.">            if (nextId &gt; maxId) {</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">                if (wrapAround) {</span>
<span class="fc" id="L191">                    currentId.set(1);</span>
<span class="fc" id="L192">                    nextId = 1;</span>
<span class="fc" id="L193">                    logger.info(&quot;ID wrapped around to 1 (max &quot; + maxId + &quot; reached)&quot;);</span>
                } else {
<span class="fc" id="L195">                    currentId.decrementAndGet(); // Revert increment</span>
<span class="fc" id="L196">                    throw new IllegalStateException(&quot;Maximum ID &quot; + maxId + &quot; reached&quot;);</span>
                }
            }

            // Persist state periodically
<span class="fc bfc" id="L201" title="All 2 branches covered.">            if (nextId - lastPersistedId &gt;= PERSIST_THRESHOLD) {</span>
<span class="fc" id="L202">                persistCurrentId();</span>
            }

<span class="fc" id="L205">            return nextId;</span>
        } finally {
<span class="fc" id="L207">            idLock.unlock();</span>
        }
    }

    /**
     * Get the next N sequential IDs.
     * Thread-safe and automatically handles wraparound if configured.
     *
     * @param count Number of IDs to generate
     * @return List of sequential IDs
     * @throws IllegalArgumentException if count &lt;= 0 or count &gt; maxId
     * @throws IllegalStateException if not enough IDs available and wraparound disabled
     */
    public List&lt;Long&gt; getNextN(int count) {
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">        if (count &lt;= 0) {</span>
<span class="nc" id="L222">            throw new IllegalArgumentException(&quot;Count must be positive&quot;);</span>
        }
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">        if (count &gt; maxId) {</span>
<span class="nc" id="L225">            throw new IllegalArgumentException(&quot;Count exceeds maximum ID value&quot;);</span>
        }

<span class="fc" id="L228">        idLock.lock();</span>
        try {
<span class="fc" id="L230">            List&lt;Long&gt; ids = new ArrayList&lt;&gt;(count);</span>
<span class="fc" id="L231">            long startId = currentId.get();</span>

<span class="fc bfc" id="L233" title="All 2 branches covered.">            for (int i = 0; i &lt; count; i++) {</span>
<span class="fc" id="L234">                long nextId = currentId.incrementAndGet();</span>

                // Check for max ID
<span class="fc bfc" id="L237" title="All 2 branches covered.">                if (nextId &gt; maxId) {</span>
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">                    if (wrapAround) {</span>
<span class="nc" id="L239">                        currentId.set(1);</span>
<span class="nc" id="L240">                        nextId = 1;</span>
<span class="nc" id="L241">                        logger.info(&quot;ID wrapped around to 1 (max &quot; + maxId + &quot; reached)&quot;);</span>
                    } else {
                        // Revert all increments
<span class="fc" id="L244">                        currentId.set(startId);</span>
<span class="fc" id="L245">                        throw new IllegalStateException(</span>
                            &quot;Not enough IDs available (need &quot; + count + &quot;, have &quot; + (maxId - startId) + &quot;)&quot;
                        );
                    }
                }

<span class="fc" id="L251">                ids.add(nextId);</span>
            }

            // Persist state after bulk generation
<span class="fc bfc" id="L255" title="All 2 branches covered.">            if (currentId.get() - lastPersistedId &gt;= PERSIST_THRESHOLD) {</span>
<span class="fc" id="L256">                persistCurrentId();</span>
            }

<span class="fc" id="L259">            return ids;</span>
        } finally {
<span class="fc" id="L261">            idLock.unlock();</span>
        }
    }

    /**
     * Get current ID without incrementing.
     *
     * @return Current ID value
     */
    public long getCurrentId() {
<span class="fc" id="L271">        return currentId.get();</span>
    }

    /**
     * Reset ID counter to a specific value.
     * Use with caution - may cause duplicate IDs if not careful.
     *
     * @param newId The new starting ID
     * @throws IllegalArgumentException if newId &lt; 0 or newId &gt; maxId
     */
    public void resetId(long newId) {
<span class="fc bfc" id="L282" title="All 4 branches covered.">        if (newId &lt; 0 || newId &gt; maxId) {</span>
<span class="fc" id="L283">            throw new IllegalArgumentException(&quot;Invalid ID: &quot; + newId);</span>
        }

<span class="fc" id="L286">        idLock.lock();</span>
        try {
<span class="fc" id="L288">            currentId.set(newId);</span>
<span class="fc" id="L289">            persistCurrentId();</span>
<span class="fc" id="L290">            logger.info(&quot;ID counter reset to: &quot; + newId);</span>
        } finally {
<span class="fc" id="L292">            idLock.unlock();</span>
        }
<span class="fc" id="L294">    }</span>

    /**
     * Insert entity with auto-generated sequential ID.
     * The entity's ID will be set automatically.
     *
     * @param entity Entity to insert (ID will be overwritten)
     * @return The assigned ID
     */
    public long insertWithAutoId(T entity) throws SQLException {
<span class="fc" id="L304">        long id = getNextId();</span>
<span class="fc" id="L305">        entity.setId(String.valueOf(id));</span>
<span class="fc" id="L306">        delegateRepo.insert(entity);</span>
<span class="fc" id="L307">        return id;</span>
    }

    /**
     * Insert entity with client-provided ID.
     * Only works if allowClientIds is enabled in builder.
     * Updates internal counter if provided ID is higher than current.
     *
     * @param entity Entity to insert
     * @param clientId Client-provided ID
     * @throws IllegalStateException if allowClientIds is false
     * @throws IllegalArgumentException if ID is invalid (negative or &gt; maxId)
     */
    public void insertWithClientId(T entity, long clientId) throws SQLException {
<span class="fc bfc" id="L321" title="All 2 branches covered.">        if (!allowClientIds) {</span>
<span class="fc" id="L322">            throw new IllegalStateException(&quot;Client IDs not allowed. Enable with allowClientIds(true) in builder&quot;);</span>
        }

<span class="fc bfc" id="L325" title="All 4 branches covered.">        if (clientId &lt;= 0 || clientId &gt; maxId) {</span>
<span class="fc" id="L326">            throw new IllegalArgumentException(&quot;Invalid client ID: &quot; + clientId + &quot; (must be 1-&quot; + maxId + &quot;)&quot;);</span>
        }

        // Update internal counter if client ID is higher
<span class="fc" id="L330">        idLock.lock();</span>
        try {
<span class="pc bpc" id="L332" title="1 of 2 branches missed.">            if (clientId &gt; currentId.get()) {</span>
<span class="fc" id="L333">                currentId.set(clientId);</span>
                // Persist if threshold reached
<span class="fc bfc" id="L335" title="All 2 branches covered.">                if (clientId - lastPersistedId &gt;= PERSIST_THRESHOLD) {</span>
<span class="fc" id="L336">                    persistCurrentId();</span>
                }
            }
        } finally {
<span class="fc" id="L340">            idLock.unlock();</span>
        }

<span class="fc" id="L343">        entity.setId(String.valueOf(clientId));</span>
<span class="fc" id="L344">        delegateRepo.insert(entity);</span>
<span class="fc" id="L345">    }</span>

    /**
     * Insert multiple entities with client-provided IDs.
     * Only works if allowClientIds is enabled.
     * Updates internal counter to highest provided ID if greater than current.
     *
     * @param entities Entities to insert
     * @param clientIds Client-provided IDs (must match entities size)
     * @throws IllegalStateException if allowClientIds is false
     * @throws IllegalArgumentException if IDs are invalid or sizes don't match
     */
    public void insertMultipleWithClientIds(List&lt;T&gt; entities, List&lt;Long&gt; clientIds) throws SQLException {
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">        if (!allowClientIds) {</span>
<span class="nc" id="L359">            throw new IllegalStateException(&quot;Client IDs not allowed. Enable with allowClientIds(true) in builder&quot;);</span>
        }

<span class="pc bpc" id="L362" title="1 of 2 branches missed.">        if (entities.size() != clientIds.size()) {</span>
<span class="nc" id="L363">            throw new IllegalArgumentException(&quot;Entity count must match ID count&quot;);</span>
        }

        // Validate all IDs and find max
<span class="fc" id="L367">        long maxClientId = 0;</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">        for (Long id : clientIds) {</span>
<span class="pc bpc" id="L369" title="3 of 6 branches missed.">            if (id == null || id &lt;= 0 || id &gt; maxId) {</span>
<span class="nc" id="L370">                throw new IllegalArgumentException(&quot;Invalid client ID: &quot; + id);</span>
            }
<span class="fc" id="L372">            maxClientId = Math.max(maxClientId, id);</span>
<span class="fc" id="L373">        }</span>

        // Update internal counter if needed
<span class="fc" id="L376">        idLock.lock();</span>
        try {
<span class="pc bpc" id="L378" title="1 of 2 branches missed.">            if (maxClientId &gt; currentId.get()) {</span>
<span class="fc" id="L379">                currentId.set(maxClientId);</span>
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">                if (maxClientId - lastPersistedId &gt;= PERSIST_THRESHOLD) {</span>
<span class="nc" id="L381">                    persistCurrentId();</span>
                }
            }
        } finally {
<span class="fc" id="L385">            idLock.unlock();</span>
        }

        // Set IDs and insert
<span class="fc bfc" id="L389" title="All 2 branches covered.">        for (int i = 0; i &lt; entities.size(); i++) {</span>
<span class="fc" id="L390">            entities.get(i).setId(String.valueOf(clientIds.get(i)));</span>
        }

<span class="fc" id="L393">        delegateRepo.insertMultiple(entities);</span>
<span class="fc" id="L394">    }</span>

    /**
     * Insert multiple entities with auto-generated sequential IDs.
     *
     * @param entities Entities to insert (IDs will be overwritten)
     * @return List of assigned IDs
     */
    public List&lt;Long&gt; insertMultipleWithAutoId(List&lt;T&gt; entities) throws SQLException {
<span class="fc" id="L403">        List&lt;Long&gt; ids = getNextN(entities.size());</span>

<span class="fc bfc" id="L405" title="All 2 branches covered.">        for (int i = 0; i &lt; entities.size(); i++) {</span>
<span class="fc" id="L406">            entities.get(i).setId(String.valueOf(ids.get(i)));</span>
        }

<span class="fc" id="L409">        delegateRepo.insertMultiple(entities);</span>
<span class="fc" id="L410">        return ids;</span>
    }

    /**
     * Reserve a range of IDs for future use.
     * Advances the internal counter to the end of the range.
     * Useful for pre-allocating ID blocks for distributed systems.
     *
     * @param count Number of IDs to reserve
     * @return Range object containing start and end IDs (inclusive)
     * @throws IllegalArgumentException if count &lt;= 0 or exceeds available IDs
     */
    public IdRange reserveIdRange(int count) {
<span class="fc bfc" id="L423" title="All 2 branches covered.">        if (count &lt;= 0) {</span>
<span class="fc" id="L424">            throw new IllegalArgumentException(&quot;Count must be positive&quot;);</span>
        }

<span class="fc" id="L427">        idLock.lock();</span>
        try {
<span class="fc" id="L429">            long startId = currentId.get() + 1;</span>
<span class="fc" id="L430">            long endId = startId + count - 1;</span>

            // Check for max ID
<span class="fc bfc" id="L433" title="All 2 branches covered.">            if (endId &gt; maxId) {</span>
<span class="pc bpc" id="L434" title="1 of 2 branches missed.">                if (wrapAround) {</span>
                    // Handle wraparound for range
<span class="fc" id="L436">                    currentId.set(count);</span>
<span class="fc" id="L437">                    startId = 1;</span>
<span class="fc" id="L438">                    endId = count;</span>
<span class="fc" id="L439">                    logger.info(&quot;ID range wrapped around (max &quot; + maxId + &quot; reached)&quot;);</span>
                } else {
<span class="nc" id="L441">                    throw new IllegalStateException(</span>
<span class="nc" id="L442">                        &quot;Not enough IDs available for range (need &quot; + count + &quot;, available &quot; + (maxId - currentId.get()) + &quot;)&quot;</span>
                    );
                }
            } else {
<span class="fc" id="L446">                currentId.set(endId);</span>
            }

            // Persist state after range reservation
<span class="fc bfc" id="L450" title="All 2 branches covered.">            if (endId - lastPersistedId &gt;= PERSIST_THRESHOLD) {</span>
<span class="fc" id="L451">                persistCurrentId();</span>
            }

<span class="fc" id="L454">            return new IdRange(startId, endId, count);</span>
        } finally {
<span class="fc" id="L456">            idLock.unlock();</span>
        }
    }

    /**
     * Insert entities with a specific ID range.
     * The range must have been previously reserved or you must use allowClientIds.
     * Entities count must match the range size.
     *
     * @param entities Entities to insert
     * @param range ID range to use
     * @throws IllegalArgumentException if entity count doesn't match range size
     * @throws SQLException on database error
     */
    public void insertWithIdRange(List&lt;T&gt; entities, IdRange range) throws SQLException {
<span class="pc bpc" id="L471" title="1 of 2 branches missed.">        if (entities.size() != range.getCount()) {</span>
<span class="nc" id="L472">            throw new IllegalArgumentException(</span>
<span class="nc" id="L473">                &quot;Entity count (&quot; + entities.size() + &quot;) must match range size (&quot; + range.getCount() + &quot;)&quot;</span>
            );
        }

        // Assign IDs from range
<span class="fc" id="L478">        long currentId = range.getStart();</span>
<span class="fc bfc" id="L479" title="All 2 branches covered.">        for (T entity : entities) {</span>
<span class="fc" id="L480">            entity.setId(String.valueOf(currentId++));</span>
<span class="fc" id="L481">        }</span>

<span class="fc" id="L483">        delegateRepo.insertMultiple(entities);</span>
<span class="fc" id="L484">    }</span>

    /**
     * Insert entities using IDs from a specific range.
     * Validates that all IDs fall within the specified range.
     * Only works if allowClientIds is enabled.
     *
     * @param entities Entities to insert
     * @param startId Start of ID range (inclusive)
     * @param endId End of ID range (inclusive)
     * @throws IllegalStateException if allowClientIds is false
     * @throws IllegalArgumentException if IDs would exceed range
     */
    public void insertWithinIdRange(List&lt;T&gt; entities, long startId, long endId) throws SQLException {
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">        if (!allowClientIds) {</span>
<span class="nc" id="L499">            throw new IllegalStateException(&quot;Client IDs not allowed. Enable with allowClientIds(true) in builder&quot;);</span>
        }

<span class="pc bpc" id="L502" title="3 of 6 branches missed.">        if (startId &lt;= 0 || endId &gt; maxId || startId &gt; endId) {</span>
<span class="nc" id="L503">            throw new IllegalArgumentException(&quot;Invalid ID range: &quot; + startId + &quot; to &quot; + endId);</span>
        }

<span class="fc" id="L506">        int rangeSize = (int)(endId - startId + 1);</span>
<span class="fc bfc" id="L507" title="All 2 branches covered.">        if (entities.size() &gt; rangeSize) {</span>
<span class="fc" id="L508">            throw new IllegalArgumentException(</span>
<span class="fc" id="L509">                &quot;Too many entities (&quot; + entities.size() + &quot;) for range size (&quot; + rangeSize + &quot;)&quot;</span>
            );
        }

        // Update internal counter if needed
<span class="fc" id="L514">        idLock.lock();</span>
        try {
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">            if (endId &gt; currentId.get()) {</span>
<span class="fc" id="L517">                currentId.set(endId);</span>
<span class="pc bpc" id="L518" title="1 of 2 branches missed.">                if (endId - lastPersistedId &gt;= PERSIST_THRESHOLD) {</span>
<span class="nc" id="L519">                    persistCurrentId();</span>
                }
            }
        } finally {
<span class="fc" id="L523">            idLock.unlock();</span>
        }

        // Assign IDs sequentially within range
<span class="fc" id="L527">        long id = startId;</span>
<span class="fc bfc" id="L528" title="All 2 branches covered.">        for (T entity : entities) {</span>
<span class="fc" id="L529">            entity.setId(String.valueOf(id++));</span>
<span class="fc" id="L530">        }</span>

<span class="fc" id="L532">        delegateRepo.insertMultiple(entities);</span>
<span class="fc" id="L533">    }</span>

    /**
     * Represents a reserved ID range.
     */
    public static class IdRange {
        private final long start;
        private final long end;
        private final int count;

<span class="fc" id="L543">        public IdRange(long start, long end, int count) {</span>
<span class="fc" id="L544">            this.start = start;</span>
<span class="fc" id="L545">            this.end = end;</span>
<span class="fc" id="L546">            this.count = count;</span>
<span class="fc" id="L547">        }</span>

        public long getStart() {
<span class="fc" id="L550">            return start;</span>
        }

        public long getEnd() {
<span class="fc" id="L554">            return end;</span>
        }

        public int getCount() {
<span class="fc" id="L558">            return count;</span>
        }

        public boolean contains(long id) {
<span class="nc bnc" id="L562" title="All 4 branches missed.">            return id &gt;= start &amp;&amp; id &lt;= end;</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L567">            return String.format(&quot;IdRange[%d-%d, count=%d]&quot;, start, end, count);</span>
        }
    }

    /**
     * Find entity by numeric ID.
     *
     * @param id Numeric ID
     * @return Entity or null if not found
     */
    public T findById(long id) throws SQLException {
<span class="fc" id="L578">        return delegateRepo.findById(String.valueOf(id));</span>
    }

    /**
     * Find batch of entities starting from ID.
     * IDs are numeric but stored as strings, so ordering is numeric.
     *
     * @param startId Starting ID (exclusive)
     * @param batchSize Number of entities to retrieve
     * @return List of entities
     */
    public List&lt;T&gt; findBatchFromId(long startId, int batchSize) throws SQLException {
        // Since IDs are numeric strings, we need to handle ordering properly
        // The delegate repository's findBatchByIdGreaterThan should work if IDs are zero-padded
<span class="nc" id="L592">        return delegateRepo.findBatchByIdGreaterThan(String.valueOf(startId), batchSize);</span>
    }

    /**
     * Get delegate repository for advanced operations.
     *
     * @return The underlying ShardingRepository
     */
    public ShardingRepository&lt;T, LocalDateTime&gt; getDelegate() {
<span class="fc" id="L601">        return delegateRepo;</span>
    }

    /**
     * Shutdown the repository and persist final state.
     */
    public void shutdown() {
<span class="fc" id="L608">        idLock.lock();</span>
        try {
            // Persist final state
<span class="fc bfc" id="L611" title="All 2 branches covered.">            if (currentId.get() != lastPersistedId) {</span>
<span class="fc" id="L612">                persistCurrentId();</span>
            }

            // Shutdown delegate
<span class="pc bpc" id="L616" title="1 of 2 branches missed.">            if (delegateRepo != null) {</span>
<span class="fc" id="L617">                delegateRepo.shutdown();</span>
            }

            // Shutdown connection provider
<span class="pc bpc" id="L621" title="1 of 2 branches missed.">            if (connectionProvider != null) {</span>
<span class="fc" id="L622">                connectionProvider.shutdown();</span>
            }

<span class="fc" id="L625">            logger.info(&quot;SimpleSequentialRepository shutdown completed&quot;);</span>
        } finally {
<span class="fc" id="L627">            idLock.unlock();</span>
        }
<span class="fc" id="L629">    }</span>

    /**
     * Builder for SimpleSequentialRepository
     */
    public static class Builder&lt;T extends ShardingEntity&lt;LocalDateTime&gt;&gt; {
        private final Class&lt;T&gt; entityClass;

        // Connection settings
<span class="fc" id="L638">        private String host = &quot;127.0.0.1&quot;;</span>
<span class="fc" id="L639">        private int port = 3306;</span>
        private String database;
        private String username;
        private String password;

        // Table settings
        private String tableName;

        // ID settings
<span class="fc" id="L648">        private long maxId = Long.MAX_VALUE;</span>
<span class="fc" id="L649">        private boolean wrapAround = true;</span>
<span class="fc" id="L650">        private boolean allowClientIds = false;</span>

        // Partition settings
<span class="fc" id="L653">        private int retentionDays = 30;</span>
<span class="fc" id="L654">        private boolean autoMaintenance = true;</span>
<span class="fc" id="L655">        private LocalTime maintenanceTime = LocalTime.of(2, 0);</span>

<span class="fc" id="L657">        public Builder(Class&lt;T&gt; entityClass) {</span>
<span class="fc" id="L658">            this.entityClass = entityClass;</span>
<span class="fc" id="L659">        }</span>

        public Builder&lt;T&gt; connection(String host, int port, String database, String username, String password) {
<span class="fc" id="L662">            this.host = host;</span>
<span class="fc" id="L663">            this.port = port;</span>
<span class="fc" id="L664">            this.database = database;</span>
<span class="fc" id="L665">            this.username = username;</span>
<span class="fc" id="L666">            this.password = password;</span>
<span class="fc" id="L667">            return this;</span>
        }

        public Builder&lt;T&gt; tableName(String tableName) {
<span class="fc" id="L671">            this.tableName = tableName;</span>
<span class="fc" id="L672">            return this;</span>
        }

        public Builder&lt;T&gt; maxId(long maxId) {
<span class="pc bpc" id="L676" title="1 of 2 branches missed.">            if (maxId &lt;= 0) {</span>
<span class="nc" id="L677">                throw new IllegalArgumentException(&quot;Max ID must be positive&quot;);</span>
            }
<span class="fc" id="L679">            this.maxId = maxId;</span>
<span class="fc" id="L680">            return this;</span>
        }

        public Builder&lt;T&gt; wrapAround(boolean wrapAround) {
<span class="fc" id="L684">            this.wrapAround = wrapAround;</span>
<span class="fc" id="L685">            return this;</span>
        }

        public Builder&lt;T&gt; allowClientIds(boolean allow) {
<span class="fc" id="L689">            this.allowClientIds = allow;</span>
<span class="fc" id="L690">            return this;</span>
        }

        public Builder&lt;T&gt; retentionDays(int days) {
<span class="fc" id="L694">            this.retentionDays = days;</span>
<span class="fc" id="L695">            return this;</span>
        }

        public Builder&lt;T&gt; autoMaintenance(boolean enabled) {
<span class="nc" id="L699">            this.autoMaintenance = enabled;</span>
<span class="nc" id="L700">            return this;</span>
        }

        public Builder&lt;T&gt; maintenanceTime(LocalTime time) {
<span class="nc" id="L704">            this.maintenanceTime = time;</span>
<span class="nc" id="L705">            return this;</span>
        }

        public SimpleSequentialRepository&lt;T&gt; build() {
            // Validate required fields
<span class="pc bpc" id="L710" title="2 of 4 branches missed.">            if (database == null || database.isEmpty()) {</span>
<span class="nc" id="L711">                throw new IllegalStateException(&quot;Database name is required&quot;);</span>
            }
<span class="pc bpc" id="L713" title="2 of 4 branches missed.">            if (username == null || password == null) {</span>
<span class="nc" id="L714">                throw new IllegalStateException(&quot;Database credentials are required&quot;);</span>
            }
<span class="pc bpc" id="L716" title="2 of 4 branches missed.">            if (tableName == null || tableName.isEmpty()) {</span>
<span class="nc" id="L717">                throw new IllegalStateException(&quot;Table name is required&quot;);</span>
            }

<span class="fc" id="L720">            return new SimpleSequentialRepository&lt;&gt;(this);</span>
        }
    }

    /**
     * Static factory method for easy instantiation
     */
    public static &lt;T extends ShardingEntity&lt;LocalDateTime&gt;&gt; Builder&lt;T&gt; builder(Class&lt;T&gt; entityClass) {
<span class="fc" id="L728">        return new Builder&lt;&gt;(entityClass);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>