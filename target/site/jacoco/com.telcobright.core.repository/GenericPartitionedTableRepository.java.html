<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GenericPartitionedTableRepository.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Generic Sharding-Aware Repository Framework</a> &gt; <a href="index.source.html" class="el_package">com.telcobright.core.repository</a> &gt; <span class="el_source">GenericPartitionedTableRepository.java</span></div><h1>GenericPartitionedTableRepository.java</h1><pre class="source lang-java linenums">package com.telcobright.core.repository;
import com.telcobright.api.ShardingRepository;

import com.telcobright.core.entity.ShardingEntity;
import com.telcobright.core.metadata.EntityMetadata;
import com.telcobright.core.metadata.FieldMetadata;
import com.telcobright.core.monitoring.*;
import com.telcobright.core.pagination.Page;
import com.telcobright.core.pagination.PageRequest;
import com.telcobright.core.query.QueryDSL;
import com.telcobright.core.connection.ConnectionProvider;
import com.telcobright.core.connection.ConnectionProvider.MaintenanceConnection;
import com.telcobright.core.partition.PartitionType;
import com.telcobright.core.partition.PartitionStrategy;
import com.telcobright.core.partition.PartitionStrategyFactory;
import java.sql.*;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import com.telcobright.core.logging.Logger;
import com.telcobright.core.logging.ConsoleLogger;

/**
 * Generic Partitioned Table Repository implementation
 * Uses MySQL native partitioning on a single table
 *
 * Entities must implement ShardingEntity to ensure they have
 * required getId/setId and partition value accessor methods.
 *
 * @param &lt;T&gt; Entity type that implements ShardingEntity
 * @param &lt;P&gt; Partition column value type (must be Comparable)
 */
public class GenericPartitionedTableRepository&lt;T extends ShardingEntity&lt;P&gt;, P extends Comparable&lt;? super P&gt;&gt; implements ShardingRepository&lt;T, P&gt; {
    private final Logger logger;
<span class="fc" id="L39">    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(&quot;yyyyMMdd&quot;);</span>
    
    private final ConnectionProvider connectionProvider;
    private final String database;
    private final String tableName;
    private final int partitionRetentionPeriod;
    private final boolean autoManagePartitions;
    private final LocalTime partitionAdjustmentTime;
    private final boolean initializePartitionsOnStart;
    private final EntityMetadata&lt;T&gt; metadata;
    private final Class&lt;T&gt; entityClass;
    private final MonitoringService monitoringService;
    private final String charset;
    private final String collation;
    
    private ScheduledExecutorService scheduler;
    
<span class="fc" id="L56">    private GenericPartitionedTableRepository(Builder&lt;T, P&gt; builder) {</span>
<span class="fc" id="L57">        this.database = builder.database;</span>
<span class="fc" id="L58">        this.partitionRetentionPeriod = builder.partitionRetentionPeriod;</span>
<span class="fc" id="L59">        this.autoManagePartitions = builder.autoManagePartitions;</span>
<span class="fc" id="L60">        this.partitionAdjustmentTime = builder.partitionAdjustmentTime;</span>
<span class="fc" id="L61">        this.initializePartitionsOnStart = builder.initializePartitionsOnStart;</span>
<span class="fc" id="L62">        this.entityClass = builder.entityClass;</span>
<span class="fc" id="L63">        this.charset = builder.charset;</span>
<span class="fc" id="L64">        this.collation = builder.collation;</span>
        
        // Initialize entity metadata (performs reflection once)
<span class="fc" id="L67">        this.metadata = new EntityMetadata&lt;&gt;(entityClass);</span>
        
        // Use provided table name or derive from entity
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">        this.tableName = builder.tableName != null ? builder.tableName : metadata.getTableName();</span>
        
        // Initialize logger
<span class="pc bpc" id="L73" title="1 of 2 branches missed.">        this.logger = builder.logger != null ? builder.logger : </span>
<span class="fc" id="L74">            new ConsoleLogger(&quot;PartitionedRepo.&quot; + tableName);</span>
        
        // Create ConnectionProvider
<span class="fc" id="L77">        this.connectionProvider = new ConnectionProvider.Builder()</span>
<span class="fc" id="L78">            .host(builder.host)</span>
<span class="fc" id="L79">            .port(builder.port)</span>
<span class="fc" id="L80">            .database(builder.database)</span>
<span class="fc" id="L81">            .username(builder.username)</span>
<span class="fc" id="L82">            .password(builder.password)</span>
<span class="fc" id="L83">            .build();</span>
        
        // Initialize monitoring if enabled
<span class="pc bpc" id="L86" title="3 of 4 branches missed.">        if (builder.monitoringConfig != null &amp;&amp; builder.monitoringConfig.isEnabled()) {</span>
<span class="nc" id="L87">            RepositoryMetrics metrics = new RepositoryMetrics(&quot;Partitioned&quot;, tableName, </span>
<span class="nc" id="L88">                    builder.monitoringConfig.getInstanceId());</span>
<span class="nc" id="L89">            MetricsCollector metricsCollector = new MetricsCollector(connectionProvider, database);</span>
<span class="nc" id="L90">            this.monitoringService = new DefaultMonitoringService(builder.monitoringConfig, metrics, metricsCollector);</span>
<span class="nc" id="L91">            this.monitoringService.start();</span>
<span class="nc" id="L92">        } else {</span>
<span class="fc" id="L93">            this.monitoringService = null;</span>
        }
        
        // Initialize table and partitions if needed
        // Initialize table and partitions for retention period on startup
<span class="pc bpc" id="L98" title="1 of 2 branches missed.">        if (initializePartitionsOnStart) {</span>
            try {
<span class="fc" id="L100">                logger.info(&quot;Initializing partitioned table and partitions for retention period...&quot;);</span>
<span class="fc" id="L101">                initializeTable();</span>
                // Partitions are now created in initializeTable(), no need for separate initialization
<span class="nc" id="L103">            } catch (SQLException e) {</span>
<span class="nc" id="L104">                logger.error(&quot;Failed to initialize partitioned table: &quot; + e.getMessage(), e);</span>
                // Try to create table without partitions as fallback
                try {
<span class="nc" id="L107">                    createSimpleTable();</span>
<span class="nc" id="L108">                    logger.warn(&quot;Created non-partitioned table as fallback. Performance may be impacted.&quot;);</span>
<span class="nc" id="L109">                } catch (SQLException fallbackError) {</span>
<span class="nc" id="L110">                    throw new RuntimeException(&quot;Failed to initialize table even without partitions&quot;, fallbackError);</span>
<span class="nc" id="L111">                }</span>
<span class="fc" id="L112">            }</span>
        }
        
        // Start scheduler if auto-management is enabled
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">        if (autoManagePartitions) {</span>
<span class="fc" id="L117">            startScheduler();</span>
        }
<span class="fc" id="L119">    }</span>
    
    /**
     * Insert entity into partitioned table (MySQL handles routing)
     * Note: Target partition must exist (created during startup), otherwise SQLException will be thrown
     */
    @Override
    public void insert(T entity) throws SQLException {
<span class="nc" id="L127">        String fullTableName = database + &quot;.&quot; + tableName;</span>
<span class="nc" id="L128">        String sql = String.format(metadata.getInsertSQL(), fullTableName);</span>
        
<span class="nc" id="L130">        try (Connection conn = connectionProvider.getConnection();</span>
<span class="nc" id="L131">             PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {</span>
            
<span class="nc" id="L133">            metadata.setInsertParameters(stmt, entity);</span>
<span class="nc" id="L134">            stmt.executeUpdate();</span>
            
            // Set generated ID if applicable
<span class="nc bnc" id="L137" title="All 4 branches missed.">            if (metadata.getIdField() != null &amp;&amp; metadata.getIdField().isAutoGenerated()) {</span>
<span class="nc" id="L138">                try (ResultSet keys = stmt.getGeneratedKeys()) {</span>
                    // Auto-generated IDs not supported - all IDs must be externally generated strings
<span class="nc bnc" id="L140" title="All 2 branches missed.">                }</span>
            }
        }
<span class="nc" id="L143">    }</span>
    
    /**
     * Insert multiple entities
     * Note: Target partitions must exist (created during startup), otherwise SQLException will be thrown
     */
    @Override
    public void insertMultiple(List&lt;T&gt; entities) throws SQLException {
<span class="nc bnc" id="L151" title="All 4 branches missed.">        if (entities == null || entities.isEmpty()) {</span>
<span class="nc" id="L152">            return;</span>
        }
        
<span class="nc" id="L155">        String fullTableName = database + &quot;.&quot; + tableName;</span>
<span class="nc" id="L156">        String sql = String.format(metadata.getInsertSQL(), fullTableName);</span>
        
<span class="nc" id="L158">        try (Connection conn = connectionProvider.getConnection();</span>
<span class="nc" id="L159">             PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {</span>
            
<span class="nc bnc" id="L161" title="All 2 branches missed.">            for (T entity : entities) {</span>
<span class="nc" id="L162">                metadata.setInsertParameters(stmt, entity);</span>
<span class="nc" id="L163">                stmt.addBatch();</span>
<span class="nc" id="L164">            }</span>
            
<span class="nc" id="L166">            stmt.executeBatch();</span>
            
            // Set generated IDs if applicable
<span class="nc bnc" id="L169" title="All 4 branches missed.">            if (metadata.getIdField() != null &amp;&amp; metadata.getIdField().isAutoGenerated()) {</span>
<span class="nc" id="L170">                try (ResultSet keys = stmt.getGeneratedKeys()) {</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">                    for (T entity : entities) {</span>
                        // Auto-generated IDs not supported - all IDs must be externally generated strings
<span class="nc" id="L173">                    }</span>
                }
            }
        }
<span class="nc" id="L177">    }</span>
    
    /**
     * Find all entities by date range (with partition pruning)
     */
    @Override
    public List&lt;T&gt; findAllByPartitionRange(P startValue, P endValue) throws SQLException {
<span class="nc" id="L184">        String shardingColumn = metadata.getShardingKeyField().getColumnName();</span>
<span class="nc" id="L185">        String fullTableName = database + &quot;.&quot; + tableName;</span>
        
<span class="nc" id="L187">        String sql = String.format(&quot;SELECT * FROM %s WHERE %s BETWEEN ? AND ?&quot;, </span>
            fullTableName, shardingColumn);
        
<span class="nc" id="L190">        List&lt;T&gt; results = new ArrayList&lt;&gt;();</span>
        
<span class="nc" id="L192">        try (Connection conn = connectionProvider.getConnection();</span>
<span class="nc" id="L193">             PreparedStatement stmt = conn.prepareStatement(sql)) {</span>

            // TODO: Handle generic partition value types
<span class="nc bnc" id="L196" title="All 2 branches missed.">            if (startValue instanceof LocalDateTime) {</span>
<span class="nc" id="L197">                stmt.setTimestamp(1, Timestamp.valueOf((LocalDateTime) startValue));</span>
<span class="nc" id="L198">                stmt.setTimestamp(2, Timestamp.valueOf((LocalDateTime) endValue));</span>
            } else {
<span class="nc" id="L200">                stmt.setObject(1, startValue);</span>
<span class="nc" id="L201">                stmt.setObject(2, endValue);</span>
            }
            
<span class="nc" id="L204">            try (ResultSet rs = stmt.executeQuery()) {</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">                while (rs.next()) {</span>
<span class="nc" id="L206">                    results.add(metadata.mapResultSet(rs));</span>
                }
            }
        }
        
<span class="nc" id="L211">        return results;</span>
    }
    
    /**
     * Find entity by ID (MySQL scans all partitions)
     */
    @Override
    public T findById(String id) throws SQLException {
<span class="nc" id="L219">        String fullTableName = database + &quot;.&quot; + tableName;</span>
<span class="nc" id="L220">        String sql = String.format(metadata.getSelectByIdSQL(), fullTableName);</span>
        
<span class="nc" id="L222">        try (Connection conn = connectionProvider.getConnection();</span>
<span class="nc" id="L223">             PreparedStatement stmt = conn.prepareStatement(sql)) {</span>
            
<span class="nc" id="L225">            setIdParameter(stmt, 1, id);</span>
            
<span class="nc" id="L227">            try (ResultSet rs = stmt.executeQuery()) {</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">                if (rs.next()) {</span>
<span class="nc" id="L229">                    return metadata.mapResultSet(rs);</span>
                }
<span class="nc bnc" id="L231" title="All 2 branches missed.">            }</span>
<span class="nc bnc" id="L232" title="All 4 branches missed.">        }</span>
        
<span class="nc" id="L234">        return null;</span>
    }
    
    /**
     * Find entity by ID within a date range
     */
    @Override
    public T findByIdAndPartitionColRange(String id, P startValue, P endValue) throws SQLException {
        // Returns the first entity found in the date range
<span class="nc" id="L243">        List&lt;T&gt; entities = findAllByPartitionRange(startValue, endValue);</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">        return entities.isEmpty() ? null : entities.get(0);</span>
    }
    
    /**
     * Find all entities by IDs within a date range
     */
    @Override
    public List&lt;T&gt; findAllByIdsAndPartitionColRange(List&lt;String&gt; ids, P startValue, P endValue) throws SQLException {
<span class="nc bnc" id="L252" title="All 4 branches missed.">        if (ids == null || ids.isEmpty()) {</span>
<span class="nc" id="L253">            return new ArrayList&lt;&gt;();</span>
        }
        
<span class="nc" id="L256">        String idColumn = metadata.getIdField().getColumnName();</span>
<span class="nc" id="L257">        String shardingColumn = metadata.getShardingKeyField().getColumnName();</span>
<span class="nc" id="L258">        String fullTableName = database + &quot;.&quot; + tableName;</span>
        
        // Create IN clause with placeholders
<span class="nc" id="L261">        String placeholders = String.join(&quot;,&quot;, Collections.nCopies(ids.size(), &quot;?&quot;));</span>
<span class="nc" id="L262">        String sql = String.format(&quot;SELECT * FROM %s WHERE %s IN (%s) AND %s &gt;= ? AND %s &lt;= ?&quot;, </span>
                                 fullTableName, idColumn, placeholders, shardingColumn, shardingColumn);
        
<span class="nc" id="L265">        List&lt;T&gt; results = new ArrayList&lt;&gt;();</span>
        
<span class="nc" id="L267">        try (Connection conn = connectionProvider.getConnection();</span>
<span class="nc" id="L268">             PreparedStatement stmt = conn.prepareStatement(sql)) {</span>
            
            // Set ID parameters
<span class="nc" id="L271">            int paramIndex = 1;</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">            for (String id : ids) {</span>
<span class="nc" id="L273">                setIdParameter(stmt, paramIndex++, id);</span>
<span class="nc" id="L274">            }</span>
            
            // Set date range parameters
            // TODO: Handle generic partition value types
<span class="nc bnc" id="L278" title="All 2 branches missed.">            if (startValue instanceof LocalDateTime) {</span>
<span class="nc" id="L279">                stmt.setTimestamp(paramIndex++, Timestamp.valueOf((LocalDateTime) startValue));</span>
<span class="nc" id="L280">                stmt.setTimestamp(paramIndex, Timestamp.valueOf((LocalDateTime) endValue));</span>
            } else {
<span class="nc" id="L282">                stmt.setObject(paramIndex++, startValue);</span>
<span class="nc" id="L283">                stmt.setObject(paramIndex, endValue);</span>
            }
            
<span class="nc" id="L286">            try (ResultSet rs = stmt.executeQuery()) {</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">                while (rs.next()) {</span>
<span class="nc" id="L288">                    results.add(metadata.mapResultSet(rs));</span>
                }
            }
        }
        
<span class="nc" id="L293">        return results;</span>
    }
    
    /**
     * Find all entities before a specific date
     */
    @Override
    public List&lt;T&gt; findAllBeforePartitionValue(P beforeValue) throws SQLException {
<span class="nc" id="L301">        String shardingColumn = metadata.getShardingKeyField().getColumnName();</span>
<span class="nc" id="L302">        String fullTableName = database + &quot;.&quot; + tableName;</span>
        
<span class="nc" id="L304">        String sql = String.format(&quot;SELECT * FROM %s WHERE %s &lt; ?&quot;, fullTableName, shardingColumn);</span>
        
<span class="nc" id="L306">        List&lt;T&gt; results = new ArrayList&lt;&gt;();</span>
        
<span class="nc" id="L308">        try (Connection conn = connectionProvider.getConnection();</span>
<span class="nc" id="L309">             PreparedStatement stmt = conn.prepareStatement(sql)) {</span>
            
            // TODO: Handle generic partition value types
<span class="nc bnc" id="L312" title="All 2 branches missed.">            if (beforeValue instanceof LocalDateTime) {</span>
<span class="nc" id="L313">                stmt.setTimestamp(1, Timestamp.valueOf((LocalDateTime) beforeValue));</span>
            } else {
<span class="nc" id="L315">                stmt.setObject(1, beforeValue);</span>
            }
            
<span class="nc" id="L318">            try (ResultSet rs = stmt.executeQuery()) {</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">                while (rs.next()) {</span>
<span class="nc" id="L320">                    results.add(metadata.mapResultSet(rs));</span>
                }
            }
        }
        
<span class="nc" id="L325">        return results;</span>
    }
    
    /**
     * Find all entities after a specific date
     */
    @Override
    public List&lt;T&gt; findAllAfterPartitionValue(P afterValue) throws SQLException {
<span class="nc" id="L333">        String shardingColumn = metadata.getShardingKeyField().getColumnName();</span>
<span class="nc" id="L334">        String fullTableName = database + &quot;.&quot; + tableName;</span>
        
<span class="nc" id="L336">        String sql = String.format(&quot;SELECT * FROM %s WHERE %s &gt; ?&quot;, fullTableName, shardingColumn);</span>
        
<span class="nc" id="L338">        List&lt;T&gt; results = new ArrayList&lt;&gt;();</span>
        
<span class="nc" id="L340">        try (Connection conn = connectionProvider.getConnection();</span>
<span class="nc" id="L341">             PreparedStatement stmt = conn.prepareStatement(sql)) {</span>
            
            // TODO: Handle generic partition value types
<span class="nc bnc" id="L344" title="All 2 branches missed.">            if (afterValue instanceof LocalDateTime) {</span>
<span class="nc" id="L345">                stmt.setTimestamp(1, Timestamp.valueOf((LocalDateTime) afterValue));</span>
            } else {
<span class="nc" id="L347">                stmt.setObject(1, afterValue);</span>
            }
            
<span class="nc" id="L350">            try (ResultSet rs = stmt.executeQuery()) {</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">                while (rs.next()) {</span>
<span class="nc" id="L352">                    results.add(metadata.mapResultSet(rs));</span>
                }
            }
        }
        
<span class="nc" id="L357">        return results;</span>
    }
    
    /**
     * Update entity by primary key in partitioned table
     */
    @Override
    public void updateById(String id, T entity) throws SQLException {
<span class="nc" id="L365">        String fullTableName = database + &quot;.&quot; + tableName;</span>
<span class="nc" id="L366">        String sql = String.format(metadata.getUpdateByIdSQL(), fullTableName);</span>
        
<span class="nc" id="L368">        try (Connection conn = connectionProvider.getConnection();</span>
<span class="nc" id="L369">             PreparedStatement stmt = conn.prepareStatement(sql)) {</span>
            
<span class="nc" id="L371">            metadata.setUpdateParameters(stmt, entity, id);</span>
            
<span class="nc" id="L373">            int rowsUpdated = stmt.executeUpdate();</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">            if (rowsUpdated == 0) {</span>
<span class="nc" id="L375">                throw new SQLException(&quot;Entity with ID &quot; + id + &quot; not found&quot;);</span>
            }
        }
<span class="nc" id="L378">    }</span>
    
    /**
     * Update entity by primary key within a specific date range
     */
    @Override
    public void updateByIdAndPartitionColRange(String id, T entity, P startValue, P endValue) throws SQLException {
<span class="nc" id="L385">        String fullTableName = database + &quot;.&quot; + tableName;</span>
<span class="nc" id="L386">        String shardingColumn = metadata.getShardingKeyField().getColumnName();</span>
<span class="nc" id="L387">        String idColumn = metadata.getIdField().getColumnName();</span>

        // Build UPDATE SQL with date range check
<span class="nc" id="L390">        StringBuilder sqlBuilder = new StringBuilder(&quot;UPDATE &quot;).append(fullTableName).append(&quot; SET &quot;);</span>
<span class="nc" id="L391">        List&lt;FieldMetadata&gt; fields = metadata.getFields();</span>
<span class="nc" id="L392">        boolean first = true;</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">        for (FieldMetadata field : fields) {</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">            if (!field.isId()) {</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">                if (!first) sqlBuilder.append(&quot;, &quot;);</span>
<span class="nc" id="L396">                sqlBuilder.append(field.getColumnName()).append(&quot; = ?&quot;);</span>
<span class="nc" id="L397">                first = false;</span>
            }
<span class="nc" id="L399">        }</span>
<span class="nc" id="L400">        sqlBuilder.append(&quot; WHERE &quot;).append(idColumn).append(&quot; = ?&quot;);</span>
<span class="nc" id="L401">        sqlBuilder.append(&quot; AND &quot;).append(shardingColumn).append(&quot; BETWEEN ? AND ?&quot;);</span>

<span class="nc" id="L403">        try (Connection conn = connectionProvider.getConnection();</span>
<span class="nc" id="L404">             PreparedStatement stmt = conn.prepareStatement(sqlBuilder.toString())) {</span>

            // Set field values
<span class="nc" id="L407">            int paramIndex = 1;</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">            for (FieldMetadata field : fields) {</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">                if (!field.isId()) {</span>
<span class="nc" id="L410">                    Object value = field.getValue(entity);</span>
<span class="nc" id="L411">                    stmt.setObject(paramIndex++, value);</span>
                }
<span class="nc" id="L413">            }</span>

            // Set WHERE clause parameters
<span class="nc" id="L416">            stmt.setString(paramIndex++, id);</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">            if (startValue instanceof LocalDateTime) {</span>
<span class="nc" id="L418">                stmt.setTimestamp(paramIndex++, Timestamp.valueOf((LocalDateTime) startValue));</span>
<span class="nc" id="L419">                stmt.setTimestamp(paramIndex, Timestamp.valueOf((LocalDateTime) endValue));</span>
            } else {
<span class="nc" id="L421">                stmt.setObject(paramIndex++, startValue);</span>
<span class="nc" id="L422">                stmt.setObject(paramIndex, endValue);</span>
            }

<span class="nc" id="L425">            int rowsUpdated = stmt.executeUpdate();</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">            if (rowsUpdated == 0) {</span>
<span class="nc" id="L427">                throw new SQLException(&quot;No rows updated for ID: &quot; + id);</span>
            }
        }
<span class="nc" id="L430">    }</span>
    
    /**
     * Find one entity with ID greater than the specified ID
     * Scans the full partitioned table across all partitions
     */
    @Override
    public T findOneByIdGreaterThan(String id) throws SQLException {
<span class="nc" id="L438">        String fullTableName = database + &quot;.&quot; + tableName;</span>
<span class="nc" id="L439">        String idColumn = metadata.getIdField().getColumnName();</span>
        
        // Build query to find one entity with ID &gt; specified ID
        // ORDER BY id ASC to get the smallest ID that is greater than the specified ID
<span class="nc" id="L443">        String sql = String.format(</span>
            &quot;SELECT * FROM %s WHERE %s &gt; ? ORDER BY %s ASC LIMIT 1&quot;,
            fullTableName, idColumn, idColumn
        );
        
<span class="nc" id="L448">        try (Connection conn = connectionProvider.getConnection();</span>
<span class="nc" id="L449">             PreparedStatement stmt = conn.prepareStatement(sql)) {</span>
            
<span class="nc" id="L451">            setIdParameter(stmt, 1, id);</span>
            
<span class="nc" id="L453">            try (ResultSet rs = stmt.executeQuery()) {</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">                if (rs.next()) {</span>
<span class="nc" id="L455">                    return metadata.mapResultSet(rs);</span>
                }
<span class="nc bnc" id="L457" title="All 2 branches missed.">            }</span>
<span class="nc bnc" id="L458" title="All 4 branches missed.">        }</span>
        
<span class="nc" id="L460">        return null; // No entity found with ID greater than specified ID</span>
    }
    
    /**
     * Find batch of entities with ID greater than the specified ID
     * Executes single query with LIMIT across all partitions
     */
    @Override
    public List&lt;T&gt; findBatchByIdGreaterThan(String id, int batchSize) throws SQLException {
<span class="nc" id="L469">        String fullTableName = database + &quot;.&quot; + tableName;</span>
<span class="nc" id="L470">        String idColumn = metadata.getIdField().getColumnName();</span>
<span class="nc" id="L471">        List&lt;T&gt; results = new ArrayList&lt;&gt;();</span>
        
        // Build query to find batch of entities with ID &gt; specified ID
        // ORDER BY id ASC to get results in increasing ID order
<span class="nc" id="L475">        String sql = String.format(</span>
            &quot;SELECT * FROM %s WHERE %s &gt; ? ORDER BY %s ASC LIMIT ?&quot;,
            fullTableName, idColumn, idColumn
        );
        
<span class="nc" id="L480">        try (Connection conn = connectionProvider.getConnection();</span>
<span class="nc" id="L481">             PreparedStatement stmt = conn.prepareStatement(sql)) {</span>
            
<span class="nc" id="L483">            setIdParameter(stmt, 1, id);</span>
<span class="nc" id="L484">            stmt.setInt(2, batchSize);</span>
            
<span class="nc" id="L486">            try (ResultSet rs = stmt.executeQuery()) {</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">                while (rs.next()) {</span>
<span class="nc" id="L488">                    results.add(metadata.mapResultSet(rs));</span>
                }
            }
        }
        
<span class="nc" id="L493">        return results;</span>
    }
    
    private void initializeTable() throws SQLException {
<span class="fc" id="L497">        String fullTableName = database + &quot;.&quot; + tableName;</span>
<span class="fc" id="L498">        String createSQL = String.format(metadata.getCreateTableSQL(), fullTableName);</span>

        // For partitioned tables, MySQL requires the partitioning column to be part of PRIMARY KEY
        // Modify PRIMARY KEY to include sharding column
<span class="fc" id="L502">        String idColumn = metadata.getIdField().getColumnName();</span>
<span class="fc" id="L503">        String shardingColumn = metadata.getShardingKeyField().getColumnName();</span>

        // Handle both VARCHAR and BIGINT primary keys
<span class="fc" id="L506">        createSQL = createSQL.replace(idColumn + &quot; VARCHAR(255) PRIMARY KEY&quot;,</span>
                                     idColumn + &quot; VARCHAR(255)&quot;);
<span class="fc" id="L508">        createSQL = createSQL.replace(idColumn + &quot; BIGINT PRIMARY KEY AUTO_INCREMENT&quot;,</span>
                                     idColumn + &quot; BIGINT AUTO_INCREMENT&quot;);

        // Add composite primary key with both ID and sharding column
<span class="fc" id="L512">        createSQL = createSQL.replace(&quot;, KEY idx_&quot; + shardingColumn,</span>
                                     &quot;, PRIMARY KEY (&quot; + idColumn + &quot;, &quot; + shardingColumn + &quot;), KEY idx_&quot; + shardingColumn);

        // Replace charset/collation with configured values
<span class="fc" id="L516">        createSQL = createSQL.replace(&quot;) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4&quot;,</span>
                &quot;) ENGINE=InnoDB DEFAULT CHARSET=&quot; + charset + &quot; COLLATE=&quot; + collation);

<span class="fc" id="L519">        try (Connection conn = connectionProvider.getConnection();</span>
<span class="fc" id="L520">             Statement stmt = conn.createStatement()) {</span>

            // Check if table exists
<span class="fc" id="L523">            DatabaseMetaData metaData = conn.getMetaData();</span>
<span class="fc" id="L524">            try (ResultSet rs = metaData.getTables(database, null, tableName, null)) {</span>
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">                if (!rs.next()) {</span>
                    // Table doesn't exist, create it with ALL partitions for the retention period
<span class="fc" id="L527">                    LocalDateTime now = LocalDateTime.now();</span>
<span class="fc" id="L528">                    LocalDateTime startDate = now.minusDays(partitionRetentionPeriod);</span>
<span class="fc" id="L529">                    LocalDateTime endDate = now.plusDays(partitionRetentionPeriod);</span>

                    // Build partition clause with ALL partitions for the retention period
                    // Use TO_DAYS function for simpler partition definition
<span class="fc" id="L533">                    StringBuilder partitionClause = new StringBuilder();</span>
<span class="fc" id="L534">                    partitionClause.append(&quot;\nPARTITION BY RANGE (TO_DAYS(&quot;).append(shardingColumn).append(&quot;))\n(&quot;);</span>

                    // Create all partitions from start date to end date
                    // This ensures all required partitions exist upfront
<span class="fc" id="L538">                    boolean first = true;</span>
<span class="fc" id="L539">                    int partitionCount = 0;</span>
<span class="fc bfc" id="L540" title="All 2 branches covered.">                    for (LocalDateTime date = startDate; date.isBefore(endDate); date = date.plusDays(1)) {</span>
<span class="fc" id="L541">                        String partitionName = &quot;p&quot; + date.format(DATE_FORMAT);</span>
<span class="fc" id="L542">                        LocalDateTime nextDay = date.plusDays(1);</span>

<span class="fc bfc" id="L544" title="All 2 branches covered.">                        if (!first) {</span>
<span class="fc" id="L545">                            partitionClause.append(&quot;,&quot;);</span>
                        }
<span class="fc" id="L547">                        first = false;</span>

<span class="fc" id="L549">                        partitionClause.append(&quot;\n  PARTITION &quot;).append(partitionName)</span>
<span class="fc" id="L550">                                      .append(&quot; VALUES LESS THAN (TO_DAYS('&quot;)</span>
<span class="fc" id="L551">                                      .append(nextDay.toLocalDate().toString())</span>
<span class="fc" id="L552">                                      .append(&quot;'))&quot;);</span>
<span class="fc" id="L553">                        partitionCount++;</span>
                    }

<span class="fc" id="L556">                    partitionClause.append(&quot;\n)&quot;);</span>
<span class="fc" id="L557">                    createSQL += partitionClause.toString();</span>

<span class="fc" id="L559">                    logger.info(&quot;Creating partitioned table with &quot; + partitionCount + &quot; partitions&quot;);</span>
<span class="fc" id="L560">                    logger.info(&quot;Executing CREATE TABLE SQL: &quot; + createSQL);</span>
<span class="fc" id="L561">                    stmt.execute(createSQL);</span>
<span class="fc" id="L562">                    logger.info(&quot;Created partitioned table: &quot; + fullTableName + &quot; with partitions from &quot; +</span>
<span class="fc" id="L563">                               startDate.toLocalDate() + &quot; to &quot; + endDate.toLocalDate());</span>
                }
            }
        }
<span class="fc" id="L567">    }</span>

    /**
     * Create a simple non-partitioned table as fallback
     */
    private void createSimpleTable() throws SQLException {
<span class="nc" id="L573">        String fullTableName = database + &quot;.&quot; + tableName;</span>
<span class="nc" id="L574">        String createSQL = String.format(metadata.getCreateTableSQL(), fullTableName);</span>

        // For non-partitioned tables, keep the simple PRIMARY KEY
<span class="nc" id="L577">        String idColumn = metadata.getIdField().getColumnName();</span>
<span class="nc" id="L578">        String shardingColumn = metadata.getShardingKeyField().getColumnName();</span>

        // Keep original PRIMARY KEY for non-partitioned table
        // Just add index on sharding column for query performance
<span class="nc bnc" id="L582" title="All 2 branches missed.">        if (!createSQL.contains(&quot;idx_&quot; + shardingColumn)) {</span>
<span class="nc" id="L583">            createSQL = createSQL.replace(&quot;) ENGINE=InnoDB&quot;,</span>
                &quot;, INDEX idx_&quot; + shardingColumn + &quot; (&quot; + shardingColumn + &quot;)) ENGINE=InnoDB&quot;);
        }

        // Replace charset/collation with configured values
<span class="nc" id="L588">        createSQL = createSQL.replace(&quot;DEFAULT CHARSET=utf8mb4&quot;,</span>
                &quot;DEFAULT CHARSET=&quot; + charset + &quot; COLLATE=&quot; + collation);

<span class="nc" id="L591">        try (Connection conn = connectionProvider.getConnection();</span>
<span class="nc" id="L592">             Statement stmt = conn.createStatement()) {</span>

            // Check if table exists
<span class="nc" id="L595">            DatabaseMetaData metaData = conn.getMetaData();</span>
<span class="nc" id="L596">            try (ResultSet rs = metaData.getTables(database, null, tableName, null)) {</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">                if (!rs.next()) {</span>
<span class="nc" id="L598">                    logger.info(&quot;Creating non-partitioned table: &quot; + fullTableName);</span>
<span class="nc" id="L599">                    stmt.execute(createSQL);</span>
<span class="nc" id="L600">                    logger.info(&quot;Created non-partitioned table: &quot; + fullTableName);</span>
                }
            }
        }
<span class="nc" id="L604">    }</span>


    private boolean partitionExists(String partitionName) throws SQLException {
<span class="nc" id="L608">        String sql = &quot;SELECT partition_name FROM information_schema.partitions &quot; +</span>
                    &quot;WHERE table_schema = ? AND table_name = ? AND partition_name = ?&quot;;
        
<span class="nc" id="L611">        try (Connection conn = connectionProvider.getConnection();</span>
<span class="nc" id="L612">             PreparedStatement stmt = conn.prepareStatement(sql)) {</span>
            
<span class="nc" id="L614">            stmt.setString(1, database);</span>
<span class="nc" id="L615">            stmt.setString(2, tableName);</span>
<span class="nc" id="L616">            stmt.setString(3, partitionName);</span>
            
<span class="nc" id="L618">            try (ResultSet rs = stmt.executeQuery()) {</span>
<span class="nc" id="L619">                return rs.next();</span>
            }
        }
    }
    
    private void createPartition(String partitionName, LocalDateTime date) throws SQLException {
        // Create single partition - kept for backward compatibility
<span class="nc" id="L626">        Map&lt;String, LocalDateTime&gt; singlePartition = new LinkedHashMap&lt;&gt;();</span>
<span class="nc" id="L627">        singlePartition.put(partitionName, date);</span>
<span class="nc" id="L628">        createMultiplePartitions(singlePartition);</span>
<span class="nc" id="L629">    }</span>

    private void createMultiplePartitions(Map&lt;String, LocalDateTime&gt; partitions) throws SQLException {
<span class="nc bnc" id="L632" title="All 2 branches missed.">        if (partitions.isEmpty()) {</span>
<span class="nc" id="L633">            return;</span>
        }

<span class="nc" id="L636">        StringBuilder sql = new StringBuilder();</span>
<span class="nc" id="L637">        sql.append(&quot;ALTER TABLE &quot;).append(database).append(&quot;.&quot;).append(tableName)</span>
<span class="nc" id="L638">           .append(&quot; ADD PARTITION (&quot;);</span>

<span class="nc" id="L640">        boolean first = true;</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">        for (Map.Entry&lt;String, LocalDateTime&gt; entry : partitions.entrySet()) {</span>
<span class="nc" id="L642">            String partitionName = entry.getKey();</span>
<span class="nc" id="L643">            LocalDateTime date = entry.getValue();</span>
<span class="nc" id="L644">            LocalDateTime nextDay = date.plusDays(1);</span>

<span class="nc bnc" id="L646" title="All 2 branches missed.">            if (!first) {</span>
<span class="nc" id="L647">                sql.append(&quot;,&quot;);</span>
            }
<span class="nc" id="L649">            sql.append(&quot;\n    PARTITION &quot;).append(partitionName)</span>
<span class="nc" id="L650">               .append(&quot; VALUES LESS THAN (TO_DAYS('&quot;)</span>
<span class="nc" id="L651">               .append(nextDay.toLocalDate().toString()).append(&quot;'))&quot;);</span>
<span class="nc" id="L652">            first = false;</span>
<span class="nc" id="L653">        }</span>
<span class="nc" id="L654">        sql.append(&quot;\n)&quot;);</span>

<span class="nc" id="L656">        try (Connection conn = connectionProvider.getConnection();</span>
<span class="nc" id="L657">             Statement stmt = conn.createStatement()) {</span>
<span class="nc" id="L658">            logger.info(&quot;Creating &quot; + partitions.size() + &quot; partitions in single ALTER TABLE command&quot;);</span>
<span class="nc" id="L659">            stmt.execute(sql.toString());</span>
<span class="nc" id="L660">            logger.info(&quot;Successfully created &quot; + partitions.size() + &quot; partitions: &quot; + partitions.keySet());</span>
<span class="nc" id="L661">        } catch (SQLException e) {</span>
<span class="nc" id="L662">            logger.error(&quot;Failed to create partitions. SQL: &quot; + sql.toString(), e);</span>
<span class="nc" id="L663">            throw e;</span>
<span class="nc" id="L664">        }</span>
<span class="nc" id="L665">    }</span>

    private void dropPartition(String partitionName) throws SQLException {
        // Drop single partition - kept for backward compatibility
<span class="nc" id="L669">        dropMultiplePartitions(Arrays.asList(partitionName));</span>
<span class="nc" id="L670">    }</span>

    private void dropMultiplePartitions(List&lt;String&gt; partitionNames) throws SQLException {
<span class="nc bnc" id="L673" title="All 2 branches missed.">        if (partitionNames.isEmpty()) {</span>
<span class="nc" id="L674">            return;</span>
        }

<span class="nc" id="L677">        String partitionList = String.join(&quot;, &quot;, partitionNames);</span>
<span class="nc" id="L678">        String sql = String.format(&quot;ALTER TABLE %s.%s DROP PARTITION %s&quot;,</span>
            database, tableName, partitionList);

<span class="nc" id="L681">        try (Connection conn = connectionProvider.getConnection();</span>
<span class="nc" id="L682">             Statement stmt = conn.createStatement()) {</span>
<span class="nc" id="L683">            logger.info(&quot;Dropping &quot; + partitionNames.size() + &quot; partitions in single ALTER TABLE command&quot;);</span>
<span class="nc" id="L684">            stmt.execute(sql);</span>
<span class="nc" id="L685">            logger.info(&quot;Successfully dropped partitions: &quot; + partitionNames);</span>
<span class="nc" id="L686">        } catch (SQLException e) {</span>
<span class="nc" id="L687">            logger.error(&quot;Failed to drop partitions. SQL: &quot; + sql, e);</span>
<span class="nc" id="L688">            throw e;</span>
<span class="nc" id="L689">        }</span>
<span class="nc" id="L690">    }</span>
    
    private List&lt;String&gt; getPartitions() throws SQLException {
<span class="nc" id="L693">        String sql = &quot;SELECT partition_name FROM information_schema.partitions &quot; +</span>
                    &quot;WHERE table_schema = ? AND table_name = ? AND partition_name IS NOT NULL &quot; +
                    &quot;ORDER BY partition_ordinal_position&quot;;
        
<span class="nc" id="L697">        List&lt;String&gt; partitions = new ArrayList&lt;&gt;();</span>
        
<span class="nc" id="L699">        try (Connection conn = connectionProvider.getConnection();</span>
<span class="nc" id="L700">             PreparedStatement stmt = conn.prepareStatement(sql)) {</span>
            
<span class="nc" id="L702">            stmt.setString(1, database);</span>
<span class="nc" id="L703">            stmt.setString(2, tableName);</span>
            
<span class="nc" id="L705">            try (ResultSet rs = stmt.executeQuery()) {</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">                while (rs.next()) {</span>
<span class="nc" id="L707">                    partitions.add(rs.getString(&quot;partition_name&quot;));</span>
                }
            }
        }
        
<span class="nc" id="L712">        return partitions;</span>
    }
    
    private void setIdParameter(PreparedStatement stmt, int index, String id) throws SQLException {
<span class="nc" id="L716">        stmt.setString(index, id);</span>
<span class="nc" id="L717">    }</span>
    
    private &lt;R&gt; List&lt;R&gt; executeQuery(String sql, Map&lt;String, Object&gt; parameters, 
                                    ResultSetMapper&lt;R&gt; mapper) throws SQLException {
<span class="nc" id="L721">        List&lt;R&gt; results = new ArrayList&lt;&gt;();</span>
        
<span class="nc" id="L723">        try (Connection conn = connectionProvider.getConnection();</span>
<span class="nc" id="L724">             PreparedStatement stmt = conn.prepareStatement(sql)) {</span>
            
<span class="nc bnc" id="L726" title="All 2 branches missed.">            if (parameters != null) {</span>
<span class="nc" id="L727">                int index = 1;</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">                for (Object value : parameters.values()) {</span>
<span class="nc" id="L729">                    stmt.setObject(index++, value);</span>
<span class="nc" id="L730">                }</span>
            }
            
<span class="nc" id="L733">            try (ResultSet rs = stmt.executeQuery()) {</span>
<span class="nc bnc" id="L734" title="All 2 branches missed.">                while (rs.next()) {</span>
<span class="nc" id="L735">                    results.add(mapper.map(rs));</span>
                }
            }
        }
        
<span class="nc" id="L740">        return results;</span>
    }
    
    private void performAutomaticMaintenance(LocalDateTime referenceDate) throws SQLException {
        // Use MaintenanceConnection to get exclusive access during maintenance
<span class="nc" id="L745">        try (MaintenanceConnection maintenanceConn = connectionProvider.getMaintenanceConnection(</span>
                &quot;Automatic partition maintenance for &quot; + tableName)) {
            
<span class="nc" id="L748">            logger.info(&quot;Starting automatic partition maintenance for &quot; + tableName);</span>
            
<span class="nc" id="L750">            LocalDateTime startDate = referenceDate.minusDays(partitionRetentionPeriod);</span>
<span class="nc" id="L751">            LocalDateTime endDate = referenceDate.plusDays(partitionRetentionPeriod);</span>
            
<span class="nc" id="L753">            createPartitionsForDateRange(startDate, endDate);</span>
            
<span class="nc" id="L755">            LocalDateTime cutoffDate = referenceDate.minusDays(partitionRetentionPeriod);</span>
<span class="nc" id="L756">            dropOldPartitions(cutoffDate);</span>
            
<span class="nc" id="L758">            logger.info(&quot;Partition maintenance completed for &quot; + tableName);</span>
        }
<span class="nc" id="L760">    }</span>
    
    public void createPartitionsForDateRange(LocalDateTime startDate, LocalDateTime endDate) throws SQLException {
        // Collect all partitions that need to be created
<span class="nc" id="L764">        Map&lt;String, LocalDateTime&gt; partitionsToCreate = new LinkedHashMap&lt;&gt;();</span>
<span class="nc" id="L765">        LocalDateTime current = startDate;</span>

<span class="nc bnc" id="L767" title="All 2 branches missed.">        while (!current.isAfter(endDate)) {</span>
<span class="nc" id="L768">            String partitionName = &quot;p&quot; + current.format(DATE_FORMAT);</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">            if (!partitionExists(partitionName)) {</span>
<span class="nc" id="L770">                partitionsToCreate.put(partitionName, current);</span>
            }
<span class="nc" id="L772">            current = current.plusDays(1);</span>
<span class="nc" id="L773">        }</span>

        // Create all partitions in a single ALTER TABLE command
<span class="nc bnc" id="L776" title="All 2 branches missed.">        if (!partitionsToCreate.isEmpty()) {</span>
<span class="nc" id="L777">            createMultiplePartitions(partitionsToCreate);</span>
        }
<span class="nc" id="L779">    }</span>
    
    public void dropOldPartitions(LocalDateTime cutoffDate) throws SQLException {
<span class="nc bnc" id="L782" title="All 2 branches missed.">        if (!autoManagePartitions) {</span>
<span class="nc" id="L783">            return;</span>
        }

<span class="nc" id="L786">        String cutoffDateStr = cutoffDate.format(DATE_FORMAT);</span>
<span class="nc" id="L787">        List&lt;String&gt; partitions = getPartitions();</span>
<span class="nc" id="L788">        List&lt;String&gt; partitionsToDrop = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L790" title="All 2 branches missed.">        for (String partitionName : partitions) {</span>
<span class="nc bnc" id="L791" title="All 4 branches missed.">            if (partitionName.startsWith(&quot;p&quot;) &amp;&amp; partitionName.length() &gt; 1) {</span>
<span class="nc" id="L792">                String dateStr = partitionName.substring(1);</span>
<span class="nc bnc" id="L793" title="All 2 branches missed.">                if (dateStr.compareTo(cutoffDateStr) &lt; 0) {</span>
<span class="nc" id="L794">                    partitionsToDrop.add(partitionName);</span>
                }
            }
<span class="nc" id="L797">        }</span>

        // Drop all old partitions in a single ALTER TABLE command
<span class="nc bnc" id="L800" title="All 2 branches missed.">        if (!partitionsToDrop.isEmpty()) {</span>
<span class="nc" id="L801">            dropMultiplePartitions(partitionsToDrop);</span>
        }
<span class="nc" id="L803">    }</span>
    
    /**
     * Initialize all partitions needed for the retention period at startup.
     * NOTE: This is now done in initializeTable() to avoid partition ordering issues.
     * Kept for backward compatibility but does nothing.
     */
    private void initializePartitionsForRetentionPeriod() throws SQLException {
        // Partitions are now created during table creation in initializeTable()
        // This method is kept for backward compatibility but does nothing
<span class="nc" id="L813">        logger.info(&quot;Partition initialization is now handled during table creation&quot;);</span>
<span class="nc" id="L814">    }</span>
    
    private void startScheduler() {
<span class="fc" id="L817">        scheduler = Executors.newSingleThreadScheduledExecutor(r -&gt; {</span>
<span class="fc" id="L818">            Thread thread = new Thread(r, &quot;PartitionedTableRepository-Scheduler-&quot; + tableName);</span>
<span class="fc" id="L819">            thread.setDaemon(true);</span>
<span class="fc" id="L820">            return thread;</span>
        });
        
<span class="fc" id="L823">        scheduleNextRun();</span>
<span class="fc" id="L824">    }</span>
    
    private void scheduleNextRun() {
<span class="fc" id="L827">        LocalDateTime now = LocalDateTime.now();</span>
<span class="fc" id="L828">        LocalDateTime nextRun = now.toLocalDate().plusDays(1).atTime(partitionAdjustmentTime);</span>
        
<span class="pc bpc" id="L830" title="1 of 2 branches missed.">        if (nextRun.isBefore(now)) {</span>
<span class="nc" id="L831">            nextRun = nextRun.plusDays(1);</span>
        }
        
<span class="fc" id="L834">        long delay = java.time.Duration.between(now, nextRun).toMillis();</span>
        
<span class="fc" id="L836">        scheduler.schedule(() -&gt; {</span>
            try {
<span class="nc" id="L838">                performScheduledMaintenance();</span>
<span class="nc" id="L839">                scheduleNextRun();</span>
<span class="nc" id="L840">            } catch (Exception e) {</span>
<span class="nc" id="L841">                logger.error(&quot;Failed to perform scheduled maintenance: &quot; + e.getMessage());</span>
<span class="nc" id="L842">                scheduleNextRun();</span>
<span class="nc" id="L843">            }</span>
<span class="nc" id="L844">        }, delay, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L845">    }</span>
    
    private void performScheduledMaintenance() throws SQLException {
<span class="nc" id="L848">        LocalDateTime now = LocalDateTime.now();</span>
<span class="nc" id="L849">        performAutomaticMaintenance(now);</span>
<span class="nc" id="L850">    }</span>
    
    @Override
    public void deleteById(String id) throws SQLException {
<span class="nc" id="L854">        String idColumn = metadata.getIdField().getColumnName();</span>
<span class="nc" id="L855">        String fullTableName = database + &quot;.&quot; + tableName;</span>
<span class="nc" id="L856">        String sql = &quot;DELETE FROM &quot; + fullTableName + &quot; WHERE &quot; + idColumn + &quot; = ?&quot;;</span>

<span class="nc" id="L858">        try (Connection conn = connectionProvider.getConnection();</span>
<span class="nc" id="L859">             PreparedStatement stmt = conn.prepareStatement(sql)) {</span>
<span class="nc" id="L860">            setIdParameter(stmt, 1, id);</span>
<span class="nc" id="L861">            stmt.executeUpdate();</span>
        }
<span class="nc" id="L863">    }</span>

    @Override
    public void deleteByIdAndPartitionColRange(String id, P startValue, P endValue) throws SQLException {
<span class="nc" id="L867">        String idColumn = metadata.getIdField().getColumnName();</span>
<span class="nc" id="L868">        String shardingColumn = metadata.getShardingKeyField().getColumnName();</span>
<span class="nc" id="L869">        String fullTableName = database + &quot;.&quot; + tableName;</span>
<span class="nc" id="L870">        String sql = &quot;DELETE FROM &quot; + fullTableName + &quot; WHERE &quot; + idColumn + &quot; = ? AND &quot; +</span>
                     shardingColumn + &quot; BETWEEN ? AND ?&quot;;

<span class="nc" id="L873">        try (Connection conn = connectionProvider.getConnection();</span>
<span class="nc" id="L874">             PreparedStatement stmt = conn.prepareStatement(sql)) {</span>
<span class="nc" id="L875">            setIdParameter(stmt, 1, id);</span>
            // TODO: Handle generic partition value types
<span class="nc bnc" id="L877" title="All 2 branches missed.">            if (startValue instanceof LocalDateTime) {</span>
<span class="nc" id="L878">                stmt.setTimestamp(2, Timestamp.valueOf((LocalDateTime) startValue));</span>
<span class="nc" id="L879">                stmt.setTimestamp(3, Timestamp.valueOf((LocalDateTime) endValue));</span>
            } else {
<span class="nc" id="L881">                stmt.setObject(2, startValue);</span>
<span class="nc" id="L882">                stmt.setObject(3, endValue);</span>
            }
<span class="nc" id="L884">            stmt.executeUpdate();</span>
        }
<span class="nc" id="L886">    }</span>

    @Override
    public void deleteAllByPartitionRange(P startValue, P endValue) throws SQLException {
<span class="nc" id="L890">        String shardingColumn = metadata.getShardingKeyField().getColumnName();</span>
<span class="nc" id="L891">        String fullTableName = database + &quot;.&quot; + tableName;</span>
<span class="nc" id="L892">        String sql = &quot;DELETE FROM &quot; + fullTableName + &quot; WHERE &quot; +</span>
                     shardingColumn + &quot; BETWEEN ? AND ?&quot;;

<span class="nc" id="L895">        try (Connection conn = connectionProvider.getConnection();</span>
<span class="nc" id="L896">             PreparedStatement stmt = conn.prepareStatement(sql)) {</span>
            // TODO: Handle generic partition value types
<span class="nc bnc" id="L898" title="All 2 branches missed.">            if (startValue instanceof LocalDateTime) {</span>
<span class="nc" id="L899">                stmt.setTimestamp(1, Timestamp.valueOf((LocalDateTime) startValue));</span>
<span class="nc" id="L900">                stmt.setTimestamp(2, Timestamp.valueOf((LocalDateTime) endValue));</span>
            } else {
<span class="nc" id="L902">                stmt.setObject(1, startValue);</span>
<span class="nc" id="L903">                stmt.setObject(2, endValue);</span>
            }
<span class="nc" id="L905">            stmt.executeUpdate();</span>
        }
<span class="nc" id="L907">    }</span>

    @Override
    public void shutdown() {
        // Shutdown scheduler immediately
<span class="pc bpc" id="L912" title="2 of 4 branches missed.">        if (scheduler != null &amp;&amp; !scheduler.isShutdown()) {</span>
<span class="fc" id="L913">            scheduler.shutdownNow(); // Use shutdownNow() for immediate termination</span>
            try {
                // Wait only 2 seconds for termination
<span class="pc bpc" id="L916" title="1 of 2 branches missed.">                if (!scheduler.awaitTermination(2, TimeUnit.SECONDS)) {</span>
                    // Force shutdown if still not terminated
<span class="nc" id="L918">                    scheduler.shutdownNow();</span>
                }
<span class="nc" id="L920">            } catch (InterruptedException e) {</span>
<span class="nc" id="L921">                scheduler.shutdownNow();</span>
<span class="nc" id="L922">                Thread.currentThread().interrupt();</span>
<span class="fc" id="L923">            }</span>
        }

        // Shutdown ConnectionProvider
<span class="pc bpc" id="L927" title="1 of 2 branches missed.">        if (connectionProvider != null) {</span>
<span class="fc" id="L928">            connectionProvider.shutdown();</span>
<span class="fc" id="L929">            logger.info(&quot;ConnectionProvider shutdown&quot;);</span>
        }
<span class="fc" id="L931">    }</span>
    
    
    /**
     * Functional interface for mapping ResultSet to entity
     */
    @FunctionalInterface
    public interface ResultSetMapper&lt;R&gt; {
        R map(ResultSet rs) throws SQLException;
    }
    
    /**
     * Builder for GenericPartitionedTableRepository
     */
    public static class Builder&lt;T extends ShardingEntity&lt;P&gt;, P extends Comparable&lt;? super P&gt;&gt; {
        private final Class&lt;T&gt; entityClass;
<span class="fc" id="L947">        private String host = &quot;localhost&quot;;</span>
<span class="fc" id="L948">        private int port = 3306;</span>
        private String database;
        private String username;
        private String password;
        private String tableName;
<span class="fc" id="L953">        private int partitionRetentionPeriod = 7;</span>
<span class="fc" id="L954">        private boolean autoManagePartitions = true;</span>
<span class="fc" id="L955">        private LocalTime partitionAdjustmentTime = LocalTime.of(4, 0);</span>
<span class="fc" id="L956">        private boolean initializePartitionsOnStart = true;</span>
        private MonitoringConfig monitoringConfig;
        private Logger logger;
<span class="fc" id="L959">        private PartitionType partitionType = PartitionType.DATE_BASED;</span>
<span class="fc" id="L960">        private String partitionKeyColumn = &quot;created_at&quot;;</span>
<span class="fc" id="L961">        private String charset = &quot;utf8mb4&quot;;</span>
<span class="fc" id="L962">        private String collation = &quot;utf8mb4_bin&quot;;</span>
        
        
<span class="fc" id="L965">        Builder(Class&lt;T&gt; entityClass) {</span>
<span class="fc" id="L966">            this.entityClass = entityClass;</span>
<span class="fc" id="L967">        }</span>
        
        public Builder&lt;T, P&gt; host(String host) {
<span class="fc" id="L970">            this.host = host;</span>
<span class="fc" id="L971">            return this;</span>
        }
        
        public Builder&lt;T, P&gt; port(int port) {
<span class="fc" id="L975">            this.port = port;</span>
<span class="fc" id="L976">            return this;</span>
        }
        
        public Builder&lt;T, P&gt; database(String database) {
<span class="fc" id="L980">            this.database = database;</span>
<span class="fc" id="L981">            return this;</span>
        }
        
        public Builder&lt;T, P&gt; username(String username) {
<span class="fc" id="L985">            this.username = username;</span>
<span class="fc" id="L986">            return this;</span>
        }
        
        public Builder&lt;T, P&gt; password(String password) {
<span class="fc" id="L990">            this.password = password;</span>
<span class="fc" id="L991">            return this;</span>
        }
        
        public Builder&lt;T, P&gt; tableName(String tableName) {
<span class="fc" id="L995">            this.tableName = tableName;</span>
<span class="fc" id="L996">            return this;</span>
        }
        
        public Builder&lt;T, P&gt; partitionRetentionPeriod(int days) {
<span class="nc" id="L1000">            this.partitionRetentionPeriod = days;</span>
<span class="nc" id="L1001">            return this;</span>
        }
        
        public Builder&lt;T, P&gt; autoManagePartitions(boolean enable) {
<span class="nc" id="L1005">            this.autoManagePartitions = enable;</span>
<span class="nc" id="L1006">            return this;</span>
        }
        
        public Builder&lt;T, P&gt; partitionAdjustmentTime(int hour, int minute) {
<span class="nc" id="L1010">            this.partitionAdjustmentTime = LocalTime.of(hour, minute);</span>
<span class="nc" id="L1011">            return this;</span>
        }
        
        public Builder&lt;T, P&gt; partitionAdjustmentTime(LocalTime time) {
<span class="nc" id="L1015">            this.partitionAdjustmentTime = time;</span>
<span class="nc" id="L1016">            return this;</span>
        }
        
        public Builder&lt;T, P&gt; initializePartitionsOnStart(boolean initialize) {
<span class="nc" id="L1020">            this.initializePartitionsOnStart = initialize;</span>
<span class="nc" id="L1021">            return this;</span>
        }
        
        public Builder&lt;T, P&gt; withPartitionType(PartitionType partitionType) {
<span class="nc bnc" id="L1025" title="All 2 branches missed.">            if (partitionType != null) {</span>
<span class="nc" id="L1026">                partitionType.validateSupported();</span>
<span class="nc" id="L1027">                this.partitionType = partitionType;</span>
            }
<span class="nc" id="L1029">            return this;</span>
        }
        
        public Builder&lt;T, P&gt; withPartitionKeyColumn(String partitionKeyColumn) {
<span class="nc bnc" id="L1033" title="All 4 branches missed.">            if (partitionKeyColumn != null &amp;&amp; !partitionKeyColumn.trim().isEmpty()) {</span>
<span class="nc" id="L1034">                this.partitionKeyColumn = partitionKeyColumn;</span>
            }
<span class="nc" id="L1036">            return this;</span>
        }

        public Builder&lt;T, P&gt; charset(String charset) {
<span class="nc bnc" id="L1040" title="All 4 branches missed.">            if (charset != null &amp;&amp; !charset.trim().isEmpty()) {</span>
<span class="nc" id="L1041">                this.charset = charset;</span>
            }
<span class="nc" id="L1043">            return this;</span>
        }

        public Builder&lt;T, P&gt; collation(String collation) {
<span class="nc bnc" id="L1047" title="All 4 branches missed.">            if (collation != null &amp;&amp; !collation.trim().isEmpty()) {</span>
<span class="nc" id="L1048">                this.collation = collation;</span>
            }
<span class="nc" id="L1050">            return this;</span>
        }
        
        public Builder&lt;T, P&gt; monitoring(MonitoringConfig monitoringConfig) {
<span class="nc" id="L1054">            this.monitoringConfig = monitoringConfig;</span>
<span class="nc" id="L1055">            return this;</span>
        }
        
        public Builder&lt;T, P&gt; logger(Logger logger) {
<span class="nc" id="L1059">            this.logger = logger;</span>
<span class="nc" id="L1060">            return this;</span>
        }
        
        
        public GenericPartitionedTableRepository&lt;T, P&gt; build() {
<span class="pc bpc" id="L1065" title="3 of 6 branches missed.">            if (database == null || username == null || password == null) {</span>
<span class="nc" id="L1066">                throw new IllegalStateException(&quot;Database, username, and password are required&quot;);</span>
            }
<span class="fc" id="L1068">            return new GenericPartitionedTableRepository&lt;T, P&gt;(this);</span>
        }
    }
    
    /**
     * Create a new builder
     */
    // Package-private factory method - only SplitVerseRepository can use this
    public static &lt;T extends ShardingEntity&lt;P&gt;, P extends Comparable&lt;? super P&gt;&gt; Builder&lt;T, P&gt; builder(Class&lt;T&gt; entityClass) {
<span class="fc" id="L1077">        return new Builder&lt;T, P&gt;(entityClass);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>