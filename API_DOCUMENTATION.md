# Split-Verse API Documentation

## Overview
Split-Verse is a sharding and partitioning framework that provides transparent data distribution across multiple shards and time-based partitions.

## Repository Modes

Split-Verse supports **2 distinct modes**:

### 1. PARTITIONED Mode (Native Database Partitioning)
- Uses MySQL's native `PARTITION BY RANGE` feature
- Single table with multiple partitions (p20250914, p20250915, etc.)
- Requires composite primary key (id, created_at)
- Better for queries spanning multiple days
- All partitions defined in CREATE TABLE statement

```java
ShardingRepository<User> repository = SplitVerseRepository.<User>builder()
    .withEntityClass(User.class)
    .withTableName("users")
    .withRepositoryMode(RepositoryMode.PARTITIONED)  // Native partitioning
    .withPartitionRange(PartitionRange.DAILY)
    .withDataSources(dataSources)
    .build();
```

### 2. MULTI_TABLE Mode (Separate Tables)
- Creates separate physical tables for each time period
- Each day/hour/month gets its own table (users_20250914, users_20250915, etc.)
- Simple primary key (id only)
- Better for complete isolation and archival
- Tables created on-demand or during initialization

```java
ShardingRepository<User> repository = SplitVerseRepository.<User>builder()
    .withEntityClass(User.class)
    .withTableName("users")
    .withRepositoryMode(RepositoryMode.MULTI_TABLE)  // Separate tables
    .withPartitionRange(PartitionRange.DAILY)
    .withDataSources(dataSources)
    .build();
```

## Core APIs

### 1. Repository Builder
```java
SplitVerseRepository.<T>builder()
    .withEntityClass(Class<T> entityClass)
    .withTableName(String tableName)
    .withShardingStrategy(ShardingStrategy strategy)
    .withRepositoryMode(RepositoryMode mode)
    .withPartitionColumn(String column, PartitionColumnType type)
    .withPartitionRange(PartitionRange range)
    .withRetentionDays(int days)
    .withIdSize(int size)
    .withDataSources(List<DataSourceConfig> sources)
    .build()
```

### 2. Insert Operations
```java
// Single insert
void insert(T entity) throws SQLException

// Batch insert
void insertMultiple(List<T> entities) throws SQLException
```

### 3. Query Operations
```java
// By ID
T findById(String id) throws SQLException

// By date range
List<T> findAllByDateRange(LocalDateTime start, LocalDateTime end) throws SQLException
List<T> findAllBeforeDate(LocalDateTime beforeDate) throws SQLException
List<T> findAllAfterDate(LocalDateTime afterDate) throws SQLException

// By ID and date
T findOneByIdAndDateRange(String id, LocalDateTime start, LocalDateTime end) throws SQLException
List<T> findAllByIdsAndDateRange(List<String> ids, LocalDateTime start, LocalDateTime end) throws SQLException

// Cursor-based pagination
T findOneByIdGreaterThan(String id) throws SQLException
List<T> findBatchByIdGreaterThan(String lastId, int batchSize) throws SQLException

// Page-based pagination
Page<T> findPage(PageRequest pageRequest) throws SQLException
```

### 4. Update Operations
```java
// Update by ID
void updateById(String id, T entity) throws SQLException
```

### 5. Delete Operations
```java
// Delete by ID
void deleteById(String id) throws SQLException

// Delete by ID and date range
void deleteByIdAndDateRange(String id, LocalDateTime start, LocalDateTime end) throws SQLException
```

### 6. Management Operations
```java
// Cleanup old partitions/tables
void performMaintenance() throws SQLException

// Graceful shutdown
void shutdown()
```

## Entity Requirements

Entities must implement `ShardingEntity` interface:

```java
@Table(name = "users")
public class User implements ShardingEntity {
    @Id(autoGenerated = false)
    @Column(name = "id")
    private String id;

    @ShardingKey
    @Column(name = "created_at")
    private LocalDateTime createdAt;

    @Column(name = "name")
    private String name;

    // Required by ShardingEntity
    @Override
    public String getId() { return id; }

    @Override
    public void setId(String id) { this.id = id; }

    @Override
    public LocalDateTime getCreatedAt() { return createdAt; }

    @Override
    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }
}
```

## Configuration Options

### Sharding Strategies
- `SINGLE_KEY_HASH` - Hash-based sharding on ID only
- `DUAL_KEY_HASH_RANGE` - Hash sharding on ID + range partitioning on date
- `DUAL_KEY_HASH_HASH` - Hash sharding on both ID and secondary key
- `CUSTOM` - User-defined sharding logic

### Partition Ranges
**Time-based:**
- `HOURLY` - New partition/table every hour
- `DAILY` - New partition/table every day
- `MONTHLY` - New partition/table every month
- `YEARLY` - New partition/table every year

**Hash-based:**
- `HASH_4`, `HASH_8`, `HASH_16`, `HASH_32` - Fixed number of hash buckets

**Value-based:**
- `VALUE_RANGE_1K` - Partitions for every 1,000 values
- `VALUE_RANGE_10K` - Partitions for every 10,000 values
- `VALUE_RANGE_100K` - Partitions for every 100,000 values
- `VALUE_RANGE_1M` - Partitions for every 1,000,000 values

### Partition Column Types
- `LOCAL_DATE_TIME` - Java LocalDateTime
- `LOCAL_DATE` - Java LocalDate
- `STRING` - String values
- `INTEGER` - Integer values
- `LONG` - Long values
- `DOUBLE` - Double values

## Usage Examples

### Example 1: Daily Partitioned Mode
```java
// Native MySQL partitioning with daily partitions
ShardingRepository<Order> repository = SplitVerseRepository.<Order>builder()
    .withEntityClass(Order.class)
    .withTableName("orders")
    .withShardingStrategy(ShardingStrategy.DUAL_KEY_HASH_RANGE)
    .withRepositoryMode(RepositoryMode.PARTITIONED)
    .withPartitionColumn("created_at", PartitionColumnType.LOCAL_DATE_TIME)
    .withPartitionRange(PartitionRange.DAILY)
    .withRetentionDays(90)
    .withDataSources(Arrays.asList(
        DataSourceConfig.create("127.0.0.1", 3306, "orders_db", "root", "password")
    ))
    .build();
```

### Example 2: Multi-Table Mode with Multiple Shards
```java
// Separate tables per day across 3 shards
ShardingRepository<Event> repository = SplitVerseRepository.<Event>builder()
    .withEntityClass(Event.class)
    .withTableName("events")
    .withShardingStrategy(ShardingStrategy.DUAL_KEY_HASH_RANGE)
    .withRepositoryMode(RepositoryMode.MULTI_TABLE)
    .withPartitionColumn("timestamp", PartitionColumnType.LOCAL_DATE_TIME)
    .withPartitionRange(PartitionRange.DAILY)
    .withRetentionDays(30)
    .withDataSources(Arrays.asList(
        DataSourceConfig.create("shard1.db.com", 3306, "events_shard_1", "user", "pass"),
        DataSourceConfig.create("shard2.db.com", 3306, "events_shard_2", "user", "pass"),
        DataSourceConfig.create("shard3.db.com", 3306, "events_shard_3", "user", "pass")
    ))
    .build();
```

### Example 3: Hash-Based Partitioning
```java
// Fixed 16 hash buckets for user data
ShardingRepository<User> repository = SplitVerseRepository.<User>builder()
    .withEntityClass(User.class)
    .withTableName("users")
    .withShardingStrategy(ShardingStrategy.DUAL_KEY_HASH_HASH)
    .withRepositoryMode(RepositoryMode.MULTI_TABLE)
    .withPartitionColumn("user_id", PartitionColumnType.STRING)
    .withPartitionRange(PartitionRange.HASH_16)
    .withDataSources(dataSources)
    .build();
```

## Performance Considerations

### PARTITIONED Mode
- ✅ Better for range queries across multiple days
- ✅ Single table statistics for optimizer
- ✅ Simpler backup/restore
- ❌ Requires composite primary key
- ❌ All partitions must be defined upfront

### MULTI_TABLE Mode
- ✅ Complete isolation between periods
- ✅ Easy to archive/drop old data
- ✅ Simple primary key
- ✅ Tables created on-demand
- ❌ Cross-day queries require UNION
- ❌ More complex query planning

## Best Practices

1. **Choose the right mode:**
   - Use `PARTITIONED` for queries that often span multiple days
   - Use `MULTI_TABLE` for complete day isolation and easier archival

2. **Set appropriate retention:**
   - Configure `withRetentionDays()` to automatically clean old data

3. **Use cursor-based pagination for large datasets:**
   - `findBatchByIdGreaterThan()` is more efficient than offset-based pagination

4. **Leverage sharding for horizontal scaling:**
   - Distribute data across multiple database instances using `withDataSources()`

5. **Monitor partition/table growth:**
   - Use maintenance operations to manage partition lifecycle