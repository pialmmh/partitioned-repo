# Split-Verse Entity Requirements & Enforcement

## Mandatory Requirements

All entities used with Split-Verse MUST meet the following requirements. **These are enforced at startup** - any violation will throw an `IllegalArgumentException` preventing the application from starting.

### 1. Must Implement ShardingEntity Interface
```java
public class MyEntity implements ShardingEntity {
    // Required interface methods
    String getId();
    void setId(String id);
    LocalDateTime getCreatedAt();
    void setCreatedAt(LocalDateTime createdAt);
}
```

### 2. Exactly ONE @Id Field (String Type)
- **Must have**: Exactly ONE field annotated with `@Id`
- **Type**: Must be `String` (not Long, Integer, UUID, etc.)
- **Auto-generation**: Must have `autoGenerated = false`
- **Purpose**: External ID generation for consistent hash-based sharding

```java
@Id(autoGenerated = false)  // ✅ CORRECT
@Column(name = "user_id")
private String id;

// ❌ WRONG - Multiple @Id
@Id private String id1;
@Id private String id2;  // Will throw: "Entity has 2 fields annotated with @Id"

// ❌ WRONG - Wrong type
@Id private Long id;  // Will throw: "@Id field must be of type String"

// ❌ WRONG - Auto-generated
@Id(autoGenerated = true)  // Will throw: "@Id must have autoGenerated=false"
```

### 3. Exactly ONE @ShardingKey Field (LocalDateTime Type)
- **Must have**: Exactly ONE field annotated with `@ShardingKey`
- **Type**: Must be `LocalDateTime`
- **Purpose**: Date-based partitioning and shard routing

```java
@ShardingKey  // ✅ CORRECT
@Column(name = "created_at")
private LocalDateTime createdAt;

// ❌ WRONG - Multiple @ShardingKey
@ShardingKey private LocalDateTime createdAt;
@ShardingKey private LocalDateTime updatedAt;  // Will throw: "Entity has 2 fields annotated with @ShardingKey"

// ❌ WRONG - Wrong type
@ShardingKey private Date createdAt;  // Will throw: "@ShardingKey field must be of type LocalDateTime"
@ShardingKey private String createdAt;  // Will throw: "@ShardingKey field must be of type LocalDateTime"
```

## Enforcement Timing

These validations occur at **repository initialization time** (application startup):

```java
// This will validate the entity during construction
SplitVerseRepository<MyEntity> repository = 
    SplitVerseRepository.<MyEntity>builder()
        .withSingleShard(config)
        .withEntityClass(MyEntity.class)  // Validation happens here
        .build();
```

## Complete Valid Entity Example

```java
package com.example.entities;

import com.telcobright.core.annotation.*;
import com.telcobright.core.entity.ShardingEntity;
import java.time.LocalDateTime;

@Table(name = "users")
public class User implements ShardingEntity {
    
    @Id(autoGenerated = false)  // ✅ Exactly one, String type, not auto-generated
    @Column(name = "user_id")
    private String id;
    
    @ShardingKey  // ✅ Exactly one, LocalDateTime type
    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    // Other fields (no restrictions)
    @Column(name = "username")
    private String username;
    
    @Column(name = "email")
    private String email;
    
    @Column(name = "last_login")
    private LocalDateTime lastLogin;
    
    // Required interface methods
    @Override
    public String getId() { 
        return id; 
    }
    
    @Override
    public void setId(String id) { 
        this.id = id; 
    }
    
    @Override
    public LocalDateTime getCreatedAt() { 
        return createdAt; 
    }
    
    @Override
    public void setCreatedAt(LocalDateTime createdAt) { 
        this.createdAt = createdAt; 
    }
    
    // Other getters/setters...
}
```

## Error Messages

When constraints are violated, you'll see clear error messages at startup:

| Violation | Error Message |
|-----------|--------------|
| No @Id | `Entity User must have exactly ONE field annotated with @Id` |
| Multiple @Id | `Entity User has 2 fields annotated with @Id, but only ONE is allowed` |
| Wrong ID type | `Entity User @Id field 'id' must be of type String for Split-Verse (found: Long)` |
| Auto-generated ID | `Entity User @Id field 'id' must have autoGenerated=false` |
| No @ShardingKey | `Entity User must have exactly ONE field annotated with @ShardingKey` |
| Multiple @ShardingKey | `Entity User has 2 fields annotated with @ShardingKey, but only ONE is allowed` |
| Wrong ShardingKey type | `Entity User @ShardingKey field 'createdAt' must be of type LocalDateTime (found: Date)` |

## ID Generation Strategies

Since `autoGenerated = false` is required, you must generate IDs externally:

```java
// Option 1: UUID
user.setId(UUID.randomUUID().toString());

// Option 2: ULID (sortable)
user.setId(UlidCreator.getUlid().toString());

// Option 3: NanoID
user.setId(NanoIdUtils.randomNanoId());

// Option 4: Custom format
user.setId("user_" + System.currentTimeMillis() + "_" + randomSuffix());
```

## Why These Requirements?

1. **String IDs**: Enable consistent hash-based sharding across any number of shards
2. **No AUTO_INCREMENT**: Prevents ID conflicts in distributed systems
3. **Single @Id**: Simplifies sharding logic and prevents ambiguity
4. **Single @ShardingKey**: Ensures clear partitioning strategy
5. **LocalDateTime for sharding**: Enables time-based partition pruning for performance
6. **Compile-time + Runtime enforcement**: Catches errors early, prevents production issues

## Testing Your Entity

Use this simple test to verify your entity meets all requirements:

```java
import com.telcobright.core.metadata.EntityMetadata;

public class EntityValidationTest {
    public static void main(String[] args) {
        try {
            new EntityMetadata<>(YourEntity.class);
            System.out.println("✅ Entity is valid for Split-Verse!");
        } catch (IllegalArgumentException e) {
            System.err.println("❌ Entity validation failed: " + e.getMessage());
        }
    }
}
```