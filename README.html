<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generic Sharding-Aware Repository Framework</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f8f9fa;
        }

        .container {
            display: flex;
            min-height: 100vh;
        }

        .sidebar {
            width: 280px;
            background: #2c3e50;
            color: white;
            padding: 20px;
            position: fixed;
            height: 100vh;
            overflow-y: auto;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
        }

        .sidebar h2 {
            font-size: 1.2rem;
            margin-bottom: 20px;
            color: #ecf0f1;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }

        .sidebar ul {
            list-style: none;
        }

        .sidebar li {
            margin-bottom: 8px;
        }

        .sidebar a {
            color: #bdc3c7;
            text-decoration: none;
            display: block;
            padding: 8px 12px;
            border-radius: 4px;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .sidebar a:hover {
            background: #34495e;
            color: #3498db;
            transform: translateX(5px);
        }

        .sidebar .level-2 {
            padding-left: 20px;
            font-size: 0.85rem;
        }

        .sidebar .level-3 {
            padding-left: 35px;
            font-size: 0.8rem;
        }

        .main-content {
            margin-left: 280px;
            padding: 40px;
            max-width: 1200px;
            background: white;
            min-height: 100vh;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 40px 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .section {
            margin-bottom: 50px;
            scroll-margin-top: 20px;
        }

        .section h2 {
            font-size: 2rem;
            color: #2c3e50;
            margin-bottom: 20px;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }

        .section h3 {
            font-size: 1.5rem;
            color: #34495e;
            margin: 30px 0 15px 0;
            position: relative;
        }

        .section h3::before {
            content: "▶";
            color: #3498db;
            margin-right: 10px;
            font-size: 0.8em;
        }

        .section h4 {
            font-size: 1.2rem;
            color: #555;
            margin: 25px 0 10px 0;
            font-weight: 600;
        }

        .strategy-card {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 25px;
            margin: 20px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .strategy-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }

        .strategy-card h4 {
            color: #2c3e50;
            font-size: 1.3rem;
            margin-bottom: 15px;
        }

        .strategy-card .icon {
            font-size: 2rem;
            margin-bottom: 10px;
            display: block;
        }

        .multi-table .icon {
            color: #e74c3c;
        }

        .partitioned-table .icon {
            color: #27ae60;
        }

        pre {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 15px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            font-size: 0.9rem;
            line-height: 1.4;
        }

        code {
            background: #ecf0f1;
            color: #2c3e50;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9em;
        }

        pre code {
            background: transparent;
            color: inherit;
            padding: 0;
        }

        .highlight {
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
            padding: 20px;
            border-radius: 8px;
            border-left: 5px solid #e67e22;
            margin: 20px 0;
        }

        .warning {
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
            padding: 15px;
            border-radius: 8px;
            border-left: 5px solid #e74c3c;
            margin: 15px 0;
        }

        .tip {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
            padding: 15px;
            border-radius: 8px;
            border-left: 5px solid #1abc9c;
            margin: 15px 0;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .feature-item {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .feature-item h4 {
            color: #3498db;
            margin-bottom: 10px;
        }
        
        .feature-card {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .feature-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .feature-card h4 {
            color: #2c3e50;
            margin-bottom: 8px;
            font-size: 1.1rem;
        }
        
        .feature-card p {
            color: #6c757d;
            font-size: 0.95rem;
            margin: 0;
        }

        .api-method {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
            margin: 10px 0;
            border-left: 4px solid #3498db;
        }

        .api-method h5 {
            color: #2c3e50;
            margin-bottom: 8px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.95rem;
        }

        .performance-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
            overflow: hidden;
        }

        .performance-table th,
        .performance-table td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #e9ecef;
        }

        .performance-table th {
            background: #3498db;
            color: white;
            font-weight: 600;
        }

        .performance-table tr:hover {
            background: #f8f9fa;
        }

        .scroll-top {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: #3498db;
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            font-size: 1.2rem;
        }

        .scroll-top:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        @media (max-width: 1024px) {
            .sidebar {
                transform: translateX(-280px);
                transition: transform 0.3s ease;
            }
            
            .sidebar.active {
                transform: translateX(0);
            }
            
            .main-content {
                margin-left: 0;
                padding: 20px;
            }
            
            .container::before {
                content: "☰ Menu";
                position: fixed;
                top: 20px;
                left: 20px;
                background: #3498db;
                color: white;
                padding: 10px 15px;
                border-radius: 5px;
                cursor: pointer;
                z-index: 1000;
                font-size: 0.9rem;
            }
        }

        .emoji {
            font-size: 1.2em;
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <nav class="sidebar">
            <h2>Table of Contents</h2>
            <ul>
                <li><a href="#getting-started">🚀 Getting Started</a>
                    <ul>
                        <li><a href="#getting-started" class="level-2">Maven Repository Setup</a></li>
                        <li><a href="#getting-started" class="level-2">Gradle Configuration</a></li>
                        <li><a href="#getting-started" class="level-2">Minimal Example</a></li>
                    </ul>
                </li>
                <li><a href="#framework-agnostic">🔧 Framework-Agnostic Design</a>
                    <ul>
                        <li><a href="#framework-agnostic" class="level-2">Logger Integration</a></li>
                        <li><a href="#framework-agnostic" class="level-2">Builder-Only Pattern</a></li>
                    </ul>
                </li>
                <li><a href="#overview">Overview</a>
                    <ul>
                        <li><a href="#multi-table-strategy" class="level-2">Multi-Table Strategy</a></li>
                        <li><a href="#partitioned-table-strategy" class="level-2">Partitioned Table Strategy</a></li>
                    </ul>
                </li>
                <li><a href="#flexible-fields">Flexible Field Naming</a></li>
                <li><a href="#sharding-entity-guide">ShardingEntity Implementation Guide</a>
                    <ul>
                        <li><a href="#entity-requirements" class="level-2">Entity Requirements</a></li>
                        <li><a href="#annotation-guide" class="level-2">Annotation Guide</a></li>
                        <li><a href="#field-types" class="level-2">Supported Field Types</a></li>
                        <li><a href="#entity-examples" class="level-2">Complete Entity Examples</a></li>
                        <li><a href="#common-patterns" class="level-2">Common Patterns</a></li>
                        <li><a href="#troubleshooting" class="level-2">Troubleshooting</a></li>
                    </ul>
                </li>
                <li><a href="#index-annotation">@Index Annotation</a></li>
                <li><a href="#monitoring-system">Monitoring System</a></li>
                <li><a href="#quick-start">Quick Start</a>
                    <ul>
                        <li><a href="#multi-table-example" class="level-2">Multi-Table Example</a></li>
                        <li><a href="#partitioned-table-example" class="level-2">Partitioned Table Example</a></li>
                    </ul>
                </li>
                <li><a href="#api-reference">API Reference</a>
                    <ul>
                        <li><a href="#multitable-api" class="level-2">MultiTableRepository API</a></li>
                        <li><a href="#partitioned-api" class="level-2">PartitionedTableRepository API</a></li>
                    </ul>
                </li>
                <li><a href="#findbyid-examples">API Usage Examples</a>
                    <ul>
                        <li><a href="#basic-id-lookups" class="level-2">Basic ID Lookups</a></li>
                        <li><a href="#basic-operations" class="level-2">Basic Operations</a></li>
                        <li><a href="#batch-operations" class="level-2">Batch Operations & Date Filtering</a></li>
                        <li><a href="#performance-considerations" class="level-2">Performance Considerations</a></li>
                    </ul>
                </li>
                <li><a href="#query-dsl">Query DSL</a>
                    <ul>
                        <li><a href="#basic-query" class="level-2">Basic Query</a></li>
                        <li><a href="#advanced-aggregation" class="level-2">Advanced Aggregation</a></li>
                        <li><a href="#complex-conditions" class="level-2">Complex Conditions</a></li>
                    </ul>
                </li>
                <li><a href="#data-models">Data Models</a>
                    <ul>
                        <li><a href="#sms-entity" class="level-2">SmsEntity</a></li>
                        <li><a href="#order-entity" class="level-2">OrderEntity</a></li>
                        <li><a href="#statistics-classes" class="level-2">Statistics Classes</a></li>
                    </ul>
                </li>
                <li><a href="#configuration">Configuration</a>
                    <ul>
                        <li><a href="#scheduler-configuration-examples" class="level-2">Scheduler Configuration</a></li>
                    </ul>
                </li>
                <li><a href="#automatic-management">Automatic Management</a>
                    <ul>
                        <li><a href="#scheduler-best-practices" class="level-2">Scheduler Best Practices</a></li>
                        <li><a href="#live-scheduler-demo" class="level-2">Live Scheduler Demo</a></li>
                    </ul>
                </li>
                <li><a href="#use-cases">Use Cases</a></li>
                <li><a href="#advanced-features">Advanced Features</a>
                    <ul>
                        <li><a href="#flexible-field-naming" class="level-2">Flexible Field Naming</a></li>
                        <li><a href="#index-annotation" class="level-2">@Index Annotation</a></li>
                        <li><a href="#monitoring-system" class="level-2">Monitoring System</a></li>
                    </ul>
                </li>
                <li><a href="#production-features">Production Features</a></li>
                <li><a href="#requirements">Requirements</a></li>
                <li><a href="#getting-started">Getting Started</a></li>
            </ul>
        </nav>

        <main class="main-content">
            <div class="header">
                <h1>Generic Sharding-Aware Repository Framework</h1>
                <p>Production-ready, framework-independent Java library with automatic SQL generation, plain JDBC connections, and type-safe generic repositories</p>
            </div>

            <section id="getting-started" class="section">
                <h2>🚀 Getting Started</h2>
                
                <div class="highlight">
                    <h4>Maven Repository Configuration</h4>
                    <p>Add the following repository and dependency to your <code>pom.xml</code>:</p>
                </div>
                
                <h3>Step 1: Add Custom Maven Repository</h3>
                <pre><code>&lt;repositories&gt;
    &lt;repository&gt;
        &lt;id&gt;telcobright-releases&lt;/id&gt;
        &lt;name&gt;TelcoBright Maven Repository&lt;/name&gt;
        &lt;url&gt;https://maven.telcobright.com/repository/releases&lt;/url&gt;
        &lt;releases&gt;
            &lt;enabled&gt;true&lt;/enabled&gt;
        &lt;/releases&gt;
        &lt;snapshots&gt;
            &lt;enabled&gt;false&lt;/enabled&gt;
        &lt;/snapshots&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;</code></pre>
                
                <h3>Step 2: Add Dependency</h3>
                <pre><code>&lt;!-- Option 1: Direct version --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.telcobright.db&lt;/groupId&gt;
    &lt;artifactId&gt;partitioned-repo&lt;/artifactId&gt;
    &lt;version&gt;2.1.0&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- Option 2: Using properties (recommended) --&gt;
&lt;properties&gt;
    &lt;partitioned-repo.version&gt;2.1.0&lt;/partitioned-repo.version&gt;
&lt;/properties&gt;

&lt;dependency&gt;
    &lt;groupId&gt;com.telcobright.db&lt;/groupId&gt;
    &lt;artifactId&gt;partitioned-repo&lt;/artifactId&gt;
    &lt;version&gt;${partitioned-repo.version}&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
                
                <h3>Step 3: Add MySQL Connector (if not already present)</h3>
                <pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;
    &lt;version&gt;8.0.33&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
                
                <div class="tip">
                    <h4>💡 Quick Setup Tips</h4>
                    <ul>
                        <li><strong>For Private Repositories:</strong> Configure your <code>~/.m2/settings.xml</code> with authentication credentials</li>
                        <li><strong>For Corporate Proxies:</strong> Add proxy configuration to your Maven settings</li>
                        <li><strong>Version Management:</strong> Use Maven properties to manage version consistently</li>
                        <li><strong>IDE Support:</strong> Most IDEs will automatically download dependencies after pom.xml changes</li>
                    </ul>
                </div>
                
                <h3>Authentication for Private Repository (Optional)</h3>
                <p>If the repository requires authentication, add to your <code>~/.m2/settings.xml</code>:</p>
                <pre><code>&lt;settings&gt;
    &lt;servers&gt;
        &lt;server&gt;
            &lt;id&gt;telcobright-releases&lt;/id&gt;
            &lt;username&gt;your-username&lt;/username&gt;
            &lt;password&gt;your-password&lt;/password&gt;
        &lt;/server&gt;
    &lt;/servers&gt;
&lt;/settings&gt;</code></pre>
                
                <h3>Alternative: Gradle Configuration</h3>
                <pre><code>// Add repository
repositories {
    maven {
        url "https://maven.telcobright.com/repository/releases"
    }
    mavenCentral()
}

// Add dependency
dependencies {
    implementation 'com.telcobright.db:partitioned-repo:2.1.0'
    implementation 'com.mysql:mysql-connector-j:8.0.33'
}</code></pre>
                
                <h3>Minimal Working Example</h3>
                <pre><code>import com.telcobright.db.repository.GenericMultiTableRepository;
import com.telcobright.db.entity.ShardingEntity;
import java.time.LocalDateTime;

// 1. Define your entity
@Table(name = "events")
public class EventEntity implements ShardingEntity&lt;Long&gt; {
    @Id
    @Column(name = "id", insertable = false)
    private Long id;
    
    @ShardingKey
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "event_data")
    private String eventData;
    
    // Constructors, getters, setters...
}

// 2. Create repository (Builder-only instantiation)
GenericMultiTableRepository&lt;EventEntity, Long&gt; repo = 
    GenericMultiTableRepository.&lt;EventEntity, Long&gt;builder(EventEntity.class, Long.class)
        .host("localhost")
        .port(3306)
        .database("myapp")
        .username("dbuser")
        .password("dbpass")
        .tablePrefix("events")
        .logger(new ConsoleLogger("EventRepo"))  // Optional: custom logger
        .build();

// 3. Use the repository
EventEntity event = new EventEntity();
event.setCreatedAt(LocalDateTime.now());
event.setEventData("User logged in");
repo.insert(event);

// 4. Query data
List&lt;EventEntity&gt; todayEvents = repo.findAllByDateRange(
    LocalDateTime.now().withHour(0).withMinute(0),
    LocalDateTime.now()
);</code></pre>
                
                <div class="warning">
                    <h4>⚠️ Prerequisites</h4>
                    <ul>
                        <li><strong>Java 8+</strong> (Tested with Java 11, 17, 21)</li>
                        <li><strong>MySQL 5.7+</strong> or <strong>MariaDB 10.3+</strong></li>
                        <li><strong>Maven 3.6+</strong> or <strong>Gradle 6.0+</strong></li>
                        <li>Database user with CREATE TABLE and partition management privileges</li>
                    </ul>
                </div>
            </section>

            <section id="framework-agnostic" class="section">
                <h2>🔧 Framework-Agnostic Design</h2>
                <p>This library is <strong>100% framework-independent</strong> and can be integrated with any Java application:</p>
                
                <div class="feature-grid">
                    <div class="feature-card">
                        <h4>✅ Plain Java</h4>
                        <p>Works with standard Java applications, no framework required</p>
                    </div>
                    <div class="feature-card">
                        <h4>✅ Spring/Spring Boot</h4>
                        <p>Integrate as beans with custom SLF4J logger</p>
                    </div>
                    <div class="feature-card">
                        <h4>✅ Quarkus</h4>
                        <p>Native compilation support with custom logger injection</p>
                    </div>
                    <div class="feature-card">
                        <h4>✅ Jakarta EE</h4>
                        <p>Use with CDI and inject custom loggers</p>
                    </div>
                </div>
                
                <h3>Custom Logger Integration</h3>
                <pre><code>// Using default console logger
GenericPartitionedTableRepository&lt;Order, Long&gt; repo1 = 
    GenericPartitionedTableRepository.&lt;Order, Long&gt;builder(Order.class, Long.class)
        .database("mydb")
        .username("user")
        .password("pass")
        .build();  // Uses ConsoleLogger by default

// Using SLF4J logger (Spring/Quarkus)
import com.telcobright.db.logging.Logger;

public class Slf4jLoggerAdapter implements Logger {
    private final org.slf4j.Logger slf4jLogger;
    
    public Slf4jLoggerAdapter(String name) {
        this.slf4jLogger = LoggerFactory.getLogger(name);
    }
    
    @Override
    public void log(Level level, String message) {
        switch(level) {
            case ERROR: slf4jLogger.error(message); break;
            case WARN: slf4jLogger.warn(message); break;
            case INFO: slf4jLogger.info(message); break;
            case DEBUG: slf4jLogger.debug(message); break;
            case TRACE: slf4jLogger.trace(message); break;
        }
    }
}

// Use with custom logger
GenericPartitionedTableRepository&lt;Order, Long&gt; repo2 = 
    GenericPartitionedTableRepository.&lt;Order, Long&gt;builder(Order.class, Long.class)
        .database("mydb")
        .username("user")
        .password("pass")
        .logger(new Slf4jLoggerAdapter("OrderRepo"))
        .build();</code></pre>
                
                <div class="highlight">
                    <h4>🔒 Builder-Only Instantiation</h4>
                    <p>Repositories can <strong>only</strong> be created through the builder pattern. Direct instantiation is not possible, ensuring proper configuration and initialization.</p>
                </div>
            </section>

            <section id="overview" class="section">
                <h2>Overview</h2>
                <p>This library provides <strong>generic, type-safe repositories</strong> with automatic SQL generation and plain JDBC connections with maintenance locking. It supports two complementary partitioning strategies with <strong>complete CRUD operations</strong>:</p>
                
                <div class="highlight">
                    <h4>Latest Features (v2.1)</h4>
                    <ul>
                        <li><strong>Update Operations:</strong> Added <code>updateById</code> and <code>updateByIdAndDateRange</code> methods</li>
                        <li><strong>Maintenance Locking:</strong> CRUD operations blocked during partition maintenance with clear exceptions</li>
                        <li><strong>Hourly Partitioning:</strong> Multi-table repositories create 24 hour partitions per daily table</li>
                        <li><strong>7-Day Default Retention:</strong> Reduced from 30/365 days to 7 days (15 tables/partitions total)</li>
                        <li><strong>Startup-Based Creation:</strong> All tables/partitions created at startup, not during insert</li>
                        <li><strong>Plain JDBC:</strong> Removed HikariCP dependency, using simple JDBC connections</li>
                        <li><strong>Dynamic Sharding Column:</strong> Query generation works with any column name, not just 'created_at'</li>
                    </ul>
                </div>
                
                <div class="highlight">
                    <h4>Core Features</h4>
                    <ul>
                        <li><strong>ShardingEntity Interface:</strong> Type-safe <code>Repository&lt;T extends ShardingEntity&lt;K&gt;, K&gt;</code> with compile-time guarantees</li>
                        <li><strong>Flexible Field Naming:</strong> Any field names allowed - <code>@Id</code> and <code>@ShardingKey</code> annotations determine behavior</li>
                        <li><strong>Custom Index Support:</strong> <code>@Index</code> annotation for automatic index creation with unique constraints</li>
                        <li><strong>Comprehensive Monitoring:</strong> Built-in metrics with Prometheus, REST push, and formatted console output</li>
                        <li><strong>Automatic SQL Generation:</strong> INSERT, SELECT, CREATE TABLE statements with indexes inferred from annotations</li>
                        <li><strong>Zero Runtime Reflection:</strong> All metadata parsed once at startup for maximum performance</li>
                    </ul>
                </div>
                
                <div class="highlight">
                    <h4>Complete API (8 Core Methods)</h4>
                    <p>The repositories now provide a comprehensive API with 8 methods:</p>
                    <ul>
                        <li><code>void insert(TEntity entity)</code> - Insert single entity</li>
                        <li><code>void insertMultiple(List&lt;TEntity&gt; entities)</code> - Batch insert with optimization</li>
                        <li><code>List&lt;TEntity&gt; findByDateRange(LocalDateTime start, LocalDateTime end)</code> - Date range queries</li>
                        <li><code>TEntity findById(TKey id)</code> - Find by primary key</li>
                        <li><code>TEntity findByIdAndDateRange(LocalDateTime start, LocalDateTime end)</code> - First entity in range</li>
                        <li><code>List&lt;TEntity&gt; findBeforeDate(LocalDateTime before)</code> - Historical data queries</li>
                        <li><code>void updateById(TKey id, TEntity entity)</code> - Update entity by primary key</li>
                        <li><code>void updateByIdAndDateRange(TKey id, TEntity entity, LocalDateTime start, LocalDateTime end)</code> - Update with date constraint</li>
                    </ul>
                </div>

                <div class="feature-grid">
                    <div id="multi-table-strategy" class="strategy-card multi-table">
                        <h4>Multi-Table Strategy</h4>
                        <ul>
                            <li><strong>Best for:</strong> High-volume, short-retention data (SMS, logs, events, alerts)</li>
                            <li><strong>Approach:</strong> Creates separate physical tables per day with hourly partitions (<code>sms_20250804</code> with h00-h23)</li>
                            <li><strong>Queries:</strong> Uses intelligent UNION ALL with 2-level aggregation</li>
                            <li><strong>ID Lookups:</strong> Cross-table UNION ALL searches with table existence filtering</li>
                            <li><strong>Benefits:</strong> Independent table optimization, easy archival, horizontal scaling</li>
                        </ul>
                    </div>

                    <div id="partitioned-table-strategy" class="strategy-card partitioned-table">
                        <h4>Partitioned Table Strategy</h4>
                        <ul>
                            <li><strong>Best for:</strong> Structured, long-retention data (orders, customers, transactions)</li>
                            <li><strong>Approach:</strong> Single logical table with MySQL native partitioning (<code>p20250804</code>, <code>p20250805</code>, etc.)</li>
                            <li><strong>Queries:</strong> Simple SQL with automatic partition pruning</li>
                            <li><strong>ID Lookups:</strong> MySQL native partition scanning for optimal performance</li>
                            <li><strong>Benefits:</strong> ACID compliance, referential integrity, simplified queries</li>
                        </ul>
                    </div>
                </div>
            </section>

            <section id="flexible-fields" class="section">
                <h2>Flexible Field Naming with Annotations</h2>
                <p>The repository system now supports <strong>flexible field naming</strong> through annotations. You can use any field names for ID and partitioning columns, and the system will detect them automatically.</p>
                
                <h3>ShardingEntity Interface</h3>
                <p>All entities must implement the <code>ShardingEntity&lt;K&gt;</code> marker interface where <code>K</code> is your ID type:</p>
                <pre><code>public interface ShardingEntity&lt;K&gt; {
    // Marker interface - fields detected via @Id and @ShardingKey annotations
}</code></pre>
                
                <h3>Flexible Field Examples</h3>
                <div class="code-example">
                    <h4>Example 1: Custom Field Names</h4>
                    <pre><code>@Table(name = "user_events")
public class UserEventEntity implements ShardingEntity&lt;String&gt; {
    @Id
    @Column(name = "event_uuid")
    private String eventUuid;  // Any field name for ID
    
    @ShardingKey
    @Column(name = "event_timestamp")
    private LocalDateTime eventTimestamp;  // Any field name for partitioning
    
    @Column(name = "user_id")
    private Long userId;
    
    @Column(name = "event_type")
    private String eventType;
}</code></pre>
                </div>

                <div class="code-example">
                    <h4>Example 2: Traditional Names Still Work</h4>
                    <pre><code>@Table(name = "orders")
public class OrderEntity implements ShardingEntity&lt;Long&gt; {
    @Id
    @Column(name = "id", insertable = false)
    private Long id;  // Traditional "id" field
    
    @ShardingKey
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;  // Traditional "created_at" field
    
    @Column(name = "customer_id")
    private String customerId;
}</code></pre>
                </div>
            </section>

            <section id="sharding-entity-guide" class="section">
                <h2>ShardingEntity Implementation Guide</h2>
                <p>This comprehensive guide shows how to implement the <code>ShardingEntity&lt;K&gt;</code> interface in your consuming applications. The interface is the foundation for type-safe, generic repositories with automatic SQL generation.</p>

                <div id="entity-requirements">
                    <h3>Entity Requirements</h3>
                    <div class="highlight">
                        <h4>🔧 Core Requirements</h4>
                        <ul>
                            <li><strong>Interface Implementation:</strong> Must implement <code>ShardingEntity&lt;K&gt;</code> where <code>K</code> is your ID type</li>
                            <li><strong>@Id Field:</strong> Exactly one field annotated with <code>@Id</code> for primary key</li>
                            <li><strong>@ShardingKey Field:</strong> Exactly one field annotated with <code>@ShardingKey</code> for date-based partitioning</li>
                            <li><strong>@Column Annotations:</strong> All fields must have <code>@Column</code> annotations for database mapping</li>
                            <li><strong>Default Constructor:</strong> Must have a public no-args constructor for ResultSet mapping</li>
                            <li><strong>Getters/Setters:</strong> Standard JavaBean patterns for all fields</li>
                        </ul>
                    </div>

                    <h4>Basic Template</h4>
                    <pre><code>package com.yourcompany.entities;

import com.telcobright.db.entity.ShardingEntity;
import com.telcobright.db.annotation.*;
import java.time.LocalDateTime;

@Table(name = "your_table_name")
public class YourEntity implements ShardingEntity&lt;Long&gt; {
    
    @Id
    @Column(name = "id", insertable = false, updatable = false)
    private Long id;
    
    @ShardingKey
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "your_data_field")
    private String yourDataField;
    
    // Required: Default constructor
    public YourEntity() {}
    
    // Required: Constructor with main fields
    public YourEntity(String yourDataField, LocalDateTime createdAt) {
        this.yourDataField = yourDataField;
        this.createdAt = createdAt;
    }
    
    // Required: Standard getters and setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
    
    public String getYourDataField() { return yourDataField; }
    public void setYourDataField(String yourDataField) { this.yourDataField = yourDataField; }
    
    @Override
    public String toString() {
        return String.format("YourEntity{id=%d, yourDataField='%s', createdAt=%s}", 
            id, yourDataField, createdAt);
    }
}</code></pre>
                </div>

                <div id="annotation-guide">
                    <h3>Annotation Reference Guide</h3>
                    
                    <h4>@Table Annotation</h4>
                    <div class="api-method">
                        <h5>@Table(name = "table_name")</h5>
                        <p><strong>Purpose:</strong> Specifies the database table name</p>
                        <p><strong>Optional:</strong> If omitted, uses lowercase class name without "Entity" suffix</p>
                        <p><strong>Examples:</strong></p>
                        <pre><code>@Table(name = "user_events")        // Creates table: user_events
@Table(name = "sms")                // Creates table: sms  
// No annotation on "OrderEntity"   // Creates table: order</code></pre>
                    </div>

                    <h4>@Id Annotation</h4>
                    <div class="api-method">
                        <h5>@Id + @Column</h5>
                        <p><strong>Purpose:</strong> Marks the primary key field</p>
                        <p><strong>Required:</strong> Exactly one field per entity must have @Id</p>
                        <p><strong>Auto-generation:</strong> Enabled by default for numeric types</p>
                        <pre><code>@Id
@Column(name = "id", insertable = false, updatable = false)
private Long id;

@Id
@Column(name = "uuid", insertable = false, updatable = false)
private String uuid;  // For String-based IDs

@Id  
@Column(name = "event_id", insertable = false, updatable = false)
private UUID eventId;  // For UUID-based IDs</code></pre>
                    </div>

                    <h4>@ShardingKey Annotation</h4>
                    <div class="api-method">
                        <h5>@ShardingKey + @Column</h5>
                        <p><strong>Purpose:</strong> Marks the field used for date-based partitioning</p>
                        <p><strong>Required:</strong> Exactly one field per entity must have @ShardingKey</p>
                        <p><strong>Type Requirement:</strong> Must be <code>LocalDateTime</code> type</p>
                        <pre><code>@ShardingKey
@Column(name = "created_at", nullable = false)
private LocalDateTime createdAt;

@ShardingKey
@Column(name = "event_timestamp", nullable = false)
private LocalDateTime eventTimestamp;

@ShardingKey
@Column(name = "logged_at", nullable = false) 
private LocalDateTime loggedAt;</code></pre>
                    </div>

                    <h4>@Column Annotation</h4>
                    <div class="api-method">
                        <h5>@Column Options</h5>
                        <p><strong>Purpose:</strong> Maps fields to database columns with constraints</p>
                        <pre><code>// Basic mapping
@Column(name = "user_id")
private String userId;

// Non-nullable field
@Column(name = "email", nullable = false)
private String email;

// Exclude from INSERT statements
@Column(name = "id", insertable = false)
private Long id;

// Exclude from UPDATE statements  
@Column(name = "created_at", updatable = false)
private LocalDateTime createdAt;

// Exclude from both INSERT and UPDATE
@Column(name = "id", insertable = false, updatable = false)
private Long id;</code></pre>
                    </div>

                    <h4>@Index Annotation</h4>
                    <div class="api-method">
                        <h5>@Index Options</h5>
                        <p><strong>Purpose:</strong> Creates database indexes automatically</p>
                        <pre><code>// Simple index
@Index
@Column(name = "user_id")
private String userId;

// Unique index with custom name
@Index(name = "idx_email_unique", unique = true)
@Column(name = "email")
private String email;

// Index with comment
@Index(name = "idx_status_search", comment = "Fast status filtering")
@Column(name = "status")
private String status;</code></pre>
                    </div>
                </div>

                <div id="field-types">
                    <h3>Supported Field Types</h3>
                    <p>The framework supports all common Java types with automatic SQL type mapping:</p>
                    
                    <table class="performance-table">
                        <thead>
                            <tr>
                                <th>Java Type</th>
                                <th>MySQL Type</th>
                                <th>Example Usage</th>
                                <th>Notes</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>Long</code></td>
                                <td><code>BIGINT</code></td>
                                <td>Primary keys, counters</td>
                                <td>Auto-increment supported</td>
                            </tr>
                            <tr>
                                <td><code>Integer</code></td>
                                <td><code>INT</code></td>
                                <td>Numeric values, counts</td>
                                <td>Auto-increment supported</td>
                            </tr>
                            <tr>
                                <td><code>String</code></td>
                                <td><code>VARCHAR(255)</code></td>
                                <td>Text fields, IDs</td>
                                <td>Default length 255</td>
                            </tr>
                            <tr>
                                <td><code>LocalDateTime</code></td>
                                <td><code>DATETIME</code></td>
                                <td>Timestamps, dates</td>
                                <td><strong>Required for @ShardingKey</strong></td>
                            </tr>
                            <tr>
                                <td><code>BigDecimal</code></td>
                                <td><code>DECIMAL(19,2)</code></td>
                                <td>Money, precise numbers</td>
                                <td>Preferred for financial data</td>
                            </tr>
                            <tr>
                                <td><code>Boolean</code></td>
                                <td><code>BOOLEAN</code></td>
                                <td>Flags, true/false values</td>
                                <td>MySQL TINYINT(1)</td>
                            </tr>
                            <tr>
                                <td><code>Double</code></td>
                                <td><code>DOUBLE</code></td>
                                <td>Floating point numbers</td>
                                <td>Use BigDecimal for precision</td>
                            </tr>
                            <tr>
                                <td><code>UUID</code></td>
                                <td><code>VARCHAR(36)</code></td>
                                <td>Unique identifiers</td>
                                <td>String representation stored</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div id="entity-examples">
                    <h3>Complete Entity Examples</h3>

                    <h4>Example 1: E-commerce Order Entity</h4>
                    <pre><code>package com.ecommerce.entities;

import com.telcobright.db.entity.ShardingEntity;
import com.telcobright.db.annotation.*;
import java.time.LocalDateTime;
import java.math.BigDecimal;

@Table(name = "orders")
public class OrderEntity implements ShardingEntity&lt;Long&gt; {
    
    @Id
    @Column(name = "id", insertable = false, updatable = false)
    private Long id;
    
    @Index  // Automatic index for fast customer lookups
    @Column(name = "customer_id", nullable = false)
    private String customerId;
    
    @Index(name = "idx_order_number_unique", unique = true)
    @Column(name = "order_number", nullable = false)
    private String orderNumber;
    
    @Column(name = "total_amount", nullable = false)
    private BigDecimal totalAmount;
    
    @Index(name = "idx_status_search", comment = "Fast order status filtering")
    @Column(name = "status", nullable = false)
    private String status; // PENDING, CONFIRMED, SHIPPED, DELIVERED, CANCELLED
    
    @Column(name = "payment_method")
    private String paymentMethod;
    
    @Column(name = "shipping_address")
    private String shippingAddress;
    
    @ShardingKey
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "shipped_at")
    private LocalDateTime shippedAt;
    
    @Column(name = "delivered_at")
    private LocalDateTime deliveredAt;
    
    @Column(name = "item_count")
    private Integer itemCount;
    
    // Constructors
    public OrderEntity() {}
    
    public OrderEntity(String customerId, String orderNumber, BigDecimal totalAmount,
                      String status, String paymentMethod, String shippingAddress,
                      LocalDateTime createdAt, Integer itemCount) {
        this.customerId = customerId;
        this.orderNumber = orderNumber;
        this.totalAmount = totalAmount;
        this.status = status;
        this.paymentMethod = paymentMethod;
        this.shippingAddress = shippingAddress;
        this.createdAt = createdAt;
        this.itemCount = itemCount;
    }
    
    // Standard getters and setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getCustomerId() { return customerId; }
    public void setCustomerId(String customerId) { this.customerId = customerId; }
    
    public String getOrderNumber() { return orderNumber; }
    public void setOrderNumber(String orderNumber) { this.orderNumber = orderNumber; }
    
    public BigDecimal getTotalAmount() { return totalAmount; }
    public void setTotalAmount(BigDecimal totalAmount) { this.totalAmount = totalAmount; }
    
    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }
    
    public String getPaymentMethod() { return paymentMethod; }
    public void setPaymentMethod(String paymentMethod) { this.paymentMethod = paymentMethod; }
    
    public String getShippingAddress() { return shippingAddress; }
    public void setShippingAddress(String shippingAddress) { this.shippingAddress = shippingAddress; }
    
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
    
    public LocalDateTime getShippedAt() { return shippedAt; }
    public void setShippedAt(LocalDateTime shippedAt) { this.shippedAt = shippedAt; }
    
    public LocalDateTime getDeliveredAt() { return deliveredAt; }
    public void setDeliveredAt(LocalDateTime deliveredAt) { this.deliveredAt = deliveredAt; }
    
    public Integer getItemCount() { return itemCount; }
    public void setItemCount(Integer itemCount) { this.itemCount = itemCount; }
    
    @Override
    public String toString() {
        return String.format("OrderEntity{id=%d, customerId='%s', orderNumber='%s', " +
                           "totalAmount=%s, status='%s', createdAt=%s}",
            id, customerId, orderNumber, totalAmount, status, createdAt);
    }
}</code></pre>

                    <h4>Example 2: User Activity Log Entity</h4>
                    <pre><code>package com.analytics.entities;

import com.telcobright.db.entity.ShardingEntity;
import com.telcobright.db.annotation.*;
import java.time.LocalDateTime;
import java.util.UUID;

@Table(name = "user_activities")
public class UserActivityEntity implements ShardingEntity&lt;UUID&gt; {
    
    @Id
    @Column(name = "activity_id", insertable = false, updatable = false)
    private UUID activityId;
    
    @Index
    @Column(name = "user_id", nullable = false)
    private Long userId;
    
    @Index(name = "idx_session_token")
    @Column(name = "session_token")
    private String sessionToken;
    
    @Index(name = "idx_activity_type", comment = "Fast activity type filtering")
    @Column(name = "activity_type", nullable = false)
    private String activityType; // LOGIN, LOGOUT, VIEW_PAGE, CLICK, PURCHASE
    
    @Column(name = "page_url")
    private String pageUrl;
    
    @Column(name = "ip_address")
    private String ipAddress;
    
    @Column(name = "user_agent")
    private String userAgent;
    
    @ShardingKey
    @Column(name = "logged_at", nullable = false)
    private LocalDateTime loggedAt;
    
    @Column(name = "duration_ms")
    private Integer durationMs;
    
    // Constructors
    public UserActivityEntity() {
        this.activityId = UUID.randomUUID(); // Auto-generate UUID
    }
    
    public UserActivityEntity(Long userId, String sessionToken, String activityType,
                             String pageUrl, String ipAddress, LocalDateTime loggedAt) {
        this();
        this.userId = userId;
        this.sessionToken = sessionToken;
        this.activityType = activityType;
        this.pageUrl = pageUrl;
        this.ipAddress = ipAddress;
        this.loggedAt = loggedAt;
    }
    
    // Standard getters and setters
    public UUID getActivityId() { return activityId; }
    public void setActivityId(UUID activityId) { this.activityId = activityId; }
    
    public Long getUserId() { return userId; }
    public void setUserId(Long userId) { this.userId = userId; }
    
    public String getSessionToken() { return sessionToken; }
    public void setSessionToken(String sessionToken) { this.sessionToken = sessionToken; }
    
    public String getActivityType() { return activityType; }
    public void setActivityType(String activityType) { this.activityType = activityType; }
    
    public String getPageUrl() { return pageUrl; }
    public void setPageUrl(String pageUrl) { this.pageUrl = pageUrl; }
    
    public String getIpAddress() { return ipAddress; }
    public void setIpAddress(String ipAddress) { this.ipAddress = ipAddress; }
    
    public String getUserAgent() { return userAgent; }
    public void setUserAgent(String userAgent) { this.userAgent = userAgent; }
    
    public LocalDateTime getLoggedAt() { return loggedAt; }
    public void setLoggedAt(LocalDateTime loggedAt) { this.loggedAt = loggedAt; }
    
    public Integer getDurationMs() { return durationMs; }
    public void setDurationMs(Integer durationMs) { this.durationMs = durationMs; }
    
    @Override
    public String toString() {
        return String.format("UserActivityEntity{activityId=%s, userId=%d, " +
                           "activityType='%s', pageUrl='%s', loggedAt=%s}",
            activityId, userId, activityType, pageUrl, loggedAt);
    }
}</code></pre>
                </div>

                <div id="common-patterns">
                    <h3>Common Implementation Patterns</h3>

                    <h4>Pattern 1: Auto-Generated Long IDs</h4>
                    <div class="api-method">
                        <h5>Most Common Pattern</h5>
                        <pre><code>@Id
@Column(name = "id", insertable = false, updatable = false)
private Long id;</code></pre>
                        <p>Framework automatically generates sequential IDs via MySQL AUTO_INCREMENT</p>
                    </div>

                    <h4>Pattern 2: UUID-Based IDs</h4>
                    <div class="api-method">
                        <h5>For Distributed Systems</h5>
                        <pre><code>@Id
@Column(name = "uuid", insertable = false, updatable = false)
private UUID uuid;

// In constructor:
public YourEntity() {
    this.uuid = UUID.randomUUID();
}</code></pre>
                        <p>Generate UUIDs in entity constructor for globally unique identifiers</p>
                    </div>

                    <h4>Pattern 3: String-Based Custom IDs</h4>
                    <div class="api-method">
                        <h5>For Business-Logic IDs</h5>
                        <pre><code>@Id
@Column(name = "order_number", insertable = true, updatable = false)
private String orderNumber;

// Set manually before insert:
order.setOrderNumber("ORD-2025-" + System.currentTimeMillis());</code></pre>
                        <p>Use <code>insertable = true</code> when you set ID values manually</p>
                    </div>

                    <h4>Pattern 4: Flexible Sharding Key Names</h4>
                    <div class="api-method">
                        <h5>Any DateTime Field Name</h5>
                        <pre><code>// Traditional naming
@ShardingKey
@Column(name = "created_at", nullable = false)
private LocalDateTime createdAt;

// Custom naming
@ShardingKey  
@Column(name = "event_timestamp", nullable = false)
private LocalDateTime eventTimestamp;

// Business-specific naming
@ShardingKey
@Column(name = "logged_at", nullable = false) 
private LocalDateTime loggedAt;</code></pre>
                        <p>The framework dynamically detects your sharding column name</p>
                    </div>
                </div>

                <div id="troubleshooting">
                    <h3>Troubleshooting Common Issues</h3>

                    <div class="warning">
                        <h4>Compilation Error: Missing ShardingEntity Interface</h4>
                        <p><strong>Error:</strong> <code>class YourEntity must implement ShardingEntity&lt;K&gt;</code></p>
                        <p><strong>Solution:</strong> Add interface implementation:</p>
                        <pre><code>public class YourEntity implements ShardingEntity&lt;Long&gt; {</code></pre>
                    </div>

                    <div class="warning">
                        <h4>Runtime Error: Missing @Id Annotation</h4>
                        <p><strong>Error:</strong> <code>No @Id field found in entity</code></p>
                        <p><strong>Solution:</strong> Add exactly one @Id field:</p>
                        <pre><code>@Id
@Column(name = "id", insertable = false)
private Long id;</code></pre>
                    </div>

                    <div class="warning">
                        <h4>Runtime Error: Missing @ShardingKey Annotation</h4>
                        <p><strong>Error:</strong> <code>No @ShardingKey field found in entity</code></p>
                        <p><strong>Solution:</strong> Add exactly one @ShardingKey field:</p>
                        <pre><code>@ShardingKey
@Column(name = "created_at", nullable = false)
private LocalDateTime createdAt;</code></pre>
                    </div>

                    <div class="warning">
                        <h4>Runtime Error: Missing Default Constructor</h4>
                        <p><strong>Error:</strong> <code>Unable to instantiate entity</code></p>
                        <p><strong>Solution:</strong> Add public no-args constructor:</p>
                        <pre><code>public YourEntity() {}</code></pre>
                    </div>

                    <div class="warning">
                        <h4>Runtime Error: Invalid ShardingKey Type</h4>
                        <p><strong>Error:</strong> <code>ShardingKey field must be LocalDateTime</code></p>
                        <p><strong>Solution:</strong> Use LocalDateTime for sharding key:</p>
                        <pre><code>@ShardingKey
@Column(name = "created_at", nullable = false)
private LocalDateTime createdAt; // Not Date, not String</code></pre>
                    </div>

                    <div class="tip">
                        <h4>💡 Best Practices</h4>
                        <ul>
                            <li><strong>Entity Naming:</strong> Use descriptive names like <code>OrderEntity</code>, <code>SmsEntity</code></li>
                            <li><strong>ID Fields:</strong> Set <code>insertable = false</code> for auto-generated IDs</li>
                            <li><strong>Timestamp Fields:</strong> Set <code>updatable = false</code> for creation timestamps</li>
                            <li><strong>Index Usage:</strong> Add <code>@Index</code> to frequently queried fields</li>
                            <li><strong>Null Safety:</strong> Use <code>nullable = false</code> for required fields</li>
                            <li><strong>toString() Method:</strong> Always implement for debugging and logging</li>
                        </ul>
                    </div>

                    <h4>Validation Checklist</h4>
                    <div class="highlight">
                        <p>Before using your entity, verify:</p>
                        <ul>
                            <li>✅ Implements <code>ShardingEntity&lt;K&gt;</code> with correct ID type</li>
                            <li>✅ Has exactly one <code>@Id</code> field</li>
                            <li>✅ Has exactly one <code>@ShardingKey</code> field of type <code>LocalDateTime</code></li>
                            <li>✅ All fields have <code>@Column</code> annotations</li>
                            <li>✅ Has public default constructor</li>
                            <li>✅ Has standard getters/setters for all fields</li>
                            <li>✅ Uses appropriate field types (see supported types table)</li>
                            <li>✅ Has meaningful <code>toString()</code> method</li>
                        </ul>
                    </div>
                </div>
            </section>

            <section id="index-annotation" class="section">
                <h2>@Index Annotation for Automatic Index Creation</h2>
                <p>The system automatically creates database indexes based on <code>@Index</code> annotations on entity fields.</p>
                
                <h3>Index Types</h3>
                <div class="code-example">
                    <pre><code>@Table(name = "user_activity")
public class UserActivityEntity implements ShardingEntity&lt;Long&gt; {
    @Id
    @Column(name = "activity_id")
    private Long activityId;
    
    @ShardingKey
    @Column(name = "logged_at")
    private LocalDateTime loggedAt;
    
    // Regular index for fast lookups
    @Index
    @Column(name = "user_id")
    private String userId;
    
    // Unique index with custom name
    @Index(name = "idx_session_unique", unique = true)
    @Column(name = "session_token")
    private String sessionToken;
    
    // Index with comment
    @Index(name = "idx_status_search", comment = "Fast status filtering")
    @Column(name = "status")
    private String status;
}</code></pre>
                </div>
                
                <h3>Generated CREATE TABLE SQL</h3>
                <pre><code>CREATE TABLE user_activity_20250806 (
    activity_id BIGINT AUTO_INCREMENT,
    logged_at DATETIME NOT NULL,
    user_id VARCHAR(255),
    session_token VARCHAR(255),
    status VARCHAR(255),
    
    PRIMARY KEY (activity_id),
    KEY idx_user_id (user_id),
    UNIQUE KEY idx_session_unique (session_token),
    KEY idx_status_search (status) COMMENT 'Fast status filtering'
) ENGINE=InnoDB;</code></pre>
            </section>

            <section id="monitoring-system" class="section">
                <h2>Repository Monitoring System</h2>
                <p>Comprehensive monitoring system with multiple delivery methods: HTTP endpoints, REST push, Kafka, and SLF4J logging.</p>
                
                <h3>Monitoring Configuration</h3>
                <pre><code>// Configure monitoring
MonitoringConfig config = new MonitoringConfig.Builder()
    .deliveryMethod(MonitoringConfig.DeliveryMethod.HTTP_ENDPOINT)
    .metricFormat(MonitoringConfig.MetricFormat.PROMETHEUS)
    .httpEndpointPath("/metrics")
    .reportingIntervalSeconds(60)  // Report every minute
    .serviceName("my-service")
    .instanceId("prod-server-01")
    .build();

// Create repository with monitoring
GenericMultiTableRepository&lt;OrderEntity, Long&gt; repository = 
    GenericMultiTableRepository.&lt;OrderEntity, Long&gt;builder(OrderEntity.class, Long.class)
        .host("127.0.0.1")
        .database("ecommerce")
        .username("root")
        .password("123456")
        .monitoring(config)  // Enable monitoring
        .build();</code></pre>
        
                <h3>Console Output (Always Enabled)</h3>
                <p>Regardless of delivery method, formatted metrics are <strong>always printed to console</strong>:</p>
                <pre><code>========================================
 REPOSITORY METRICS - 2025-08-07T10:30:45
========================================
Service: my-service (prod-server-01)
Repository: order_events [MultiTable]
Hostname: prod-server-01

📅 SCHEDULER STATUS:
   Last Run: 2025-08-07T10:25:45
   Duration: 1250 ms
   Next Run: 2025-08-07T10:35:45

📊 PARTITION METRICS:
   Total Partitions: 15
   Prefixed Tables: 45
   Created Last Run: 2
   Deleted Last Run: 1
   Active Partitions: [order_events_20250801, ...]

🏥 HEALTH STATUS:
   Last Job: ✅ HEALTHY
   Total Failures: 0
   Next Cleanup: 2 partitions

📡 MONITORING CONFIG:
   Delivery: HTTP_ENDPOINT
   Format: PROMETHEUS
   Interval: 60 seconds
   Endpoint: /metrics
========================================</code></pre>

                <h3>Delivery Methods</h3>
                <div class="monitoring-methods">
                    <h4>1. Prometheus HTTP Endpoint</h4>
                    <pre><code>// Metrics available at http://localhost:8080/metrics
SimpleHttpMetricsServer server = SimpleHttpMetricsServer.startFor(
    repository.getMonitoringService());</code></pre>
                    
                    <h4>2. REST Push to External System</h4>
                    <pre><code>MonitoringConfig config = new MonitoringConfig.Builder()
    .deliveryMethod(MonitoringConfig.DeliveryMethod.REST_PUSH)
    .restPushUrl("http://monitoring-server:9090/api/metrics")
    .metricFormat(MonitoringConfig.MetricFormat.JSON)
    .build();</code></pre>
                    
                    <h4>3. SLF4J Logging</h4>
                    <pre><code>MonitoringConfig config = new MonitoringConfig.Builder()
    .deliveryMethod(MonitoringConfig.DeliveryMethod.SLF4J_LOGGING)
    .metricFormat(MonitoringConfig.MetricFormat.JSON)
    .build();</code></pre>
                </div>
            </section>

            <section id="quick-start" class="section">
                <h2>Quick Start</h2>

                <div id="multi-table-example">
                    <h3>Generic Multi-Table Repository (SMS Example)</h3>
                    <div class="highlight">
                        <h4>Table Structure with Hourly Partitioning</h4>
                        <p>Each daily table is internally partitioned by hour for optimal performance:</p>
                        <ul>
                            <li><strong>Daily Tables:</strong> <code>sms_20250807</code>, <code>sms_20250808</code>, etc.</li>
                            <li><strong>Hourly Partitions per Table:</strong> h00, h01, h02, ..., h23 (24 partitions)</li>
                            <li><strong>Total Partitions:</strong> 15 tables × 24 hours = 360 partitions (7-day default)</li>
                            <li><strong>Partitioning Function:</strong> <code>PARTITION BY RANGE (HOUR(created_at))</code></li>
                        </ul>
                    </div>
                    <pre><code>// 1. Entity with annotations (automatic SQL generation)
@Table(name = "sms")
public class SmsEntity implements ShardingEntity&lt;Long&gt; {
    @Id
    @Column(name = "id", insertable = false)
    private Long id;
    
    @Column(name = "user_id")
    private String userId;
    
    @ShardingKey
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;
    
    @Index  // Automatic index creation
    @Column(name = "message")
    private String message;
    // ... other fields
}

// 2. Configure monitoring (console output + SLF4J logging)
MonitoringConfig smsMonitoring = new MonitoringConfig.Builder()
    .deliveryMethod(MonitoringConfig.DeliveryMethod.SLF4J_LOGGING)
    .metricFormat(MonitoringConfig.MetricFormat.JSON)
    .reportingIntervalSeconds(300)  // Report every 5 minutes
    .serviceName("sms-service")
    .instanceId("sms-server-01")
    .build();

// 3. Create generic repository with type safety and monitoring (Builder-only instantiation)
GenericMultiTableRepository&lt;SmsEntity, Long&gt; smsRepo = 
    GenericMultiTableRepository.&lt;SmsEntity, Long&gt;builder(SmsEntity.class, Long.class)
        .host("127.0.0.1")
        .port(3306)
        .database("messaging")
        .username("root")
        .password("123456")           // Updated credentials
        .monitoring(smsMonitoring)    // Enable console monitoring
        .logger(new ConsoleLogger("SmsRepo"))  // Optional: custom logger (default: ConsoleLogger)
        .tablePrefix("sms")           // Optional: inferred from @Table
        .partitionRetentionPeriod(7)  // Keep 7 days (default)
        .autoManagePartitions(true)   // Auto create/drop tables
        .partitionAdjustmentTime(4, 0) // Daily maintenance at 04:00
        .build();

// 3. Insert data - SQL automatically generated from annotations
SmsEntity sms = new SmsEntity("user123", "+1234567890", 
    "Hello World!", "SENT", LocalDateTime.now(), new BigDecimal("0.05"), "twilio");
smsRepo.insert(sms);  // Auto-generates: INSERT INTO messaging.sms_20250804 (user_id, phone_number, message, status, created_at, cost, provider) VALUES (?, ?, ?, ?, ?, ?, ?)

// 4. Type-safe queries with automatic table routing
long totalMessages = smsRepo.countByDateRange(
    LocalDateTime.now().minusDays(7), 
    LocalDateTime.now()
);

// 5. Find by ID across all tables
SmsEntity foundSms = smsRepo.findById(12345L);

// 6. Find recent SMS messages
List&lt;SmsEntity&gt; recentSms = smsRepo.findByDateRange(
    LocalDateTime.now().minusDays(7), LocalDateTime.now());

// 7. Console monitoring output (automatic every 5 minutes):
/*
========================================
 REPOSITORY METRICS - 2025-08-06T14:30:45
========================================
Service: sms-service (sms-server-01)
Repository: sms [MultiTable]
Hostname: sms-server-01

📅 SCHEDULER STATUS:
   Last Run: 2025-08-06T14:25:45
   Duration: 850 ms
   Next Run: 2025-08-06T15:25:45

📊 PARTITION METRICS:
   Total Partitions: 8
   Prefixed Tables: 24
   Created Last Run: 1
   Deleted Last Run: 1
   Active Partitions: [sms_20250801, sms_20250802, ...]

🏥 HEALTH STATUS:
   Last Job: ✅ HEALTHY
   Total Failures: 0
   Next Cleanup: 1 partitions

📡 MONITORING CONFIG:
   Delivery: SLF4J_LOGGING
   Format: JSON
   Interval: 300 seconds
========================================
*/</code></pre>
                </div>

                <div id="partitioned-table-example">
                    <h3>Generic Partitioned Table Repository (Orders Example)</h3>
                    <pre><code>// 1. Entity with annotations (automatic SQL generation)
@Table(name = "orders")
public class OrderEntity {
    @Id
    @Column(name = "id", insertable = false)
    private Long id;
    
    @Column(name = "customer_id", nullable = false)
    private String customerId;
    
    @ShardingKey
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "total_amount", nullable = false)
    private BigDecimal totalAmount;
    // ... other fields
}

// 2. Create generic repository with MySQL native partitioning (Builder-only instantiation)
GenericPartitionedTableRepository&lt;OrderEntity, Long&gt; orderRepo = 
    GenericPartitionedTableRepository.&lt;OrderEntity, Long&gt;builder(OrderEntity.class, Long.class)
        .host("127.0.0.1")
        .port(3306)
        .database("ecommerce")
        .username("root")
        .password("password")
        .logger(new ConsoleLogger("OrderRepo"))  // Optional: custom logger (default: ConsoleLogger)
        .tableName("orders")           // Optional: inferred from @Table
        .partitionRetentionPeriod(7)   // Keep 7 days (default)
        .autoManagePartitions(true)    // Auto create/drop partitions
        .partitionAdjustmentTime(4, 0) // Daily maintenance at 04:00
        .build();

// 3. Insert data - SQL automatically generated with partition routing
OrderEntity order = new OrderEntity("CUST001", "ORD-2025-001", 
    new BigDecimal("299.99"), "CONFIRMED", "CREDIT_CARD", 
    "123 Main St", LocalDateTime.now(), 3);
orderRepo.insert(order);  // Auto-generates: INSERT INTO ecommerce.orders (customer_id, order_number, total_amount, status, payment_method, shipping_address, created_at, item_count) VALUES (?, ?, ?, ?, ?, ?, ?, ?)

// 4. Type-safe queries with automatic partition pruning
List&lt;OrderEntity&gt; recentOrders = orderRepo.findByDateRange(
    LocalDateTime.now().minusDays(7),
    LocalDateTime.now() 
);

// 5. Find by ID with MySQL partition scanning
OrderEntity foundOrder = orderRepo.findById(67890L);

// 6. Find recent orders 
List&lt;OrderEntity&gt; recentOrders = orderRepo.findByDateRange(
    LocalDateTime.now().minusDays(30), LocalDateTime.now());</code></pre>
                </div>
            </section>

            <section id="api-reference" class="section">
                <h2>Public API Reference</h2>

                <div id="multitable-api">
                    <h3>GenericMultiTableRepository&lt;TEntity, TKey&gt; API</h3>
                    <p><strong>TEntity</strong> - The entity type (SmsEntity, EventEntity, etc.)</p>
                    <p><strong>TKey</strong> - The primary key type (Long, String, UUID, etc.)</p>
                    
                    <h4>Builder Configuration</h4>
                    <div class="api-method">
                        <h5>GenericMultiTableRepository.&lt;TEntity, TKey&gt;builder(Class&lt;TEntity&gt;, Class&lt;TKey&gt;)</h5>
                        <p>Create builder with entity and key types for compile-time safety</p>
                    </div>
                    
                    
                    <h4>Core Operations</h4>
                    <div class="api-method">
                        <h5>void insert(TEntity entity)</h5>
                        <p>Insert single entity with automatic SQL generation (auto-creates tables)</p>
                    </div>
                    
                    <div class="api-method">
                        <h5>void insertMultiple(List&lt;TEntity&gt; entities)</h5>
                        <p>Insert multiple entities with batch processing and automatic table creation</p>
                    </div>
                    
                    <div class="api-method">
                        <h5>List&lt;TEntity&gt; findByDateRange(LocalDateTime startDate, LocalDateTime endDate)</h5>
                        <p>Find entities by date range with automatic table selection and UNION ALL queries</p>
                    </div>
                    
                    <div class="api-method">
                        <h5>TEntity findById(TKey id)</h5>
                        <p>Find entity by primary key (searches across all tables)</p>
                    </div>
                    
                    <div class="api-method">
                        <h5>TEntity findByIdAndDateRange(LocalDateTime startDate, LocalDateTime endDate)</h5>
                        <p>Find first entity within the specified date range</p>
                    </div>
                    
                    <div class="api-method">
                        <h5>List&lt;TEntity&gt; findBeforeDate(LocalDateTime beforeDate)</h5>
                        <p>Find all entities created before the specified date</p>
                    </div>
                    
                    <div class="api-method">
                        <h5>void updateById(TKey id, TEntity entity)</h5>
                        <p>Update entity by primary key (finds the correct table automatically)</p>
                    </div>
                    
                    <div class="api-method">
                        <h5>void updateByIdAndDateRange(TKey id, TEntity entity, LocalDateTime startDate, LocalDateTime endDate)</h5>
                        <p>Update entity by primary key within a specific date range (optimizes table search)</p>
                    </div>
                    
                    <div class="api-method">
                        <h5>TEntity findOneByIdGreaterThan(TKey id)</h5>
                        <p>Find one entity with ID greater than the specified ID. Scans all tables chronologically to find the first entity with ID > specified ID. Useful for cursor-based iteration across multiple tables. Returns null if no entity found.</p>
                    </div>
                </div>

                <div id="partitioned-api">
                    <h3>GenericPartitionedTableRepository&lt;TEntity, TKey&gt; API</h3>
                    <p><strong>TEntity</strong> - The entity type (OrderEntity, CustomerEntity, etc.)</p>
                    <p><strong>TKey</strong> - The primary key type (Long, String, UUID, etc.)</p>
                    
                    <h4>Builder Configuration</h4>
                    <div class="api-method">
                        <h5>GenericPartitionedTableRepository.&lt;TEntity, TKey&gt;builder(Class&lt;TEntity&gt;, Class&lt;TKey&gt;)</h5>
                        <p>Create builder with entity and key types for compile-time safety</p>
                    </div>
                    
                    
                    <h4>Core Operations</h4>
                    <div class="api-method">
                        <h5>void insert(TEntity entity)</h5>
                        <p>Insert single entity with automatic SQL generation (auto-creates partitions)</p>
                    </div>
                    
                    <div class="api-method">
                        <h5>void insertMultiple(List&lt;TEntity&gt; entities)</h5>
                        <p>Insert multiple entities with batch processing and automatic partition creation</p>
                    </div>
                    
                    <div class="api-method">
                        <h5>List&lt;TEntity&gt; findByDateRange(LocalDateTime startDate, LocalDateTime endDate)</h5>
                        <p>Find entities by date range with MySQL partition pruning</p>
                    </div>
                    
                    <div class="api-method">
                        <h5>TEntity findById(TKey id)</h5>
                        <p>Find entity by primary key (MySQL native partition scanning)</p>
                    </div>
                    
                    <div class="api-method">
                        <h5>TEntity findByIdAndDateRange(LocalDateTime startDate, LocalDateTime endDate)</h5>
                        <p>Find first entity within the specified date range</p>
                    </div>
                    
                    <div class="api-method">
                        <h5>List&lt;TEntity&gt; findBeforeDate(LocalDateTime beforeDate)</h5>
                        <p>Find all entities created before the specified date</p>
                    </div>
                    
                    <div class="api-method">
                        <h5>void updateById(TKey id, TEntity entity)</h5>
                        <p>Update entity by primary key (uses MySQL partition scanning)</p>
                    </div>
                    
                    <div class="api-method">
                        <h5>void updateByIdAndDateRange(TKey id, TEntity entity, LocalDateTime startDate, LocalDateTime endDate)</h5>
                        <p>Update entity by primary key within date range (enables partition pruning)</p>
                    </div>
                    
                    <div class="api-method">
                        <h5>TEntity findOneByIdGreaterThan(TKey id)</h5>
                        <p>Find one entity with ID greater than the specified ID. Scans the full partitioned table across all partitions. Useful for cursor-based iteration and finding the next record. Returns null if no entity found.</p>
                    </div>
                </div>
            </section>

            <section id="findbyid-examples" class="section">
                <h2>API Usage Examples</h2>

                <div id="basic-id-lookups">
                    <h3>Basic ID Lookups</h3>
                    <pre><code>// Multi-Table Repository (SMS)
MultiTableRepository&lt;Long&gt; smsRepo = MultiTableRepository.&lt;Long&gt;builder()
    .tablePrefix("sms")
    .build();

// Find SMS by primary key ID (searches across all sms_* tables)
SmsEntity sms = smsRepo.findById(12345L);
if (sms != null) {
    System.out.println("Found SMS: " + sms.getMessage());
}

// Partitioned Table Repository (Orders)  
PartitionedTableRepository&lt;Long&gt; orderRepo = PartitionedTableRepository.&lt;Long&gt;builder()
    .tableName("orders")
    .build();

// Find order by primary key ID (MySQL scans all partitions)
OrderEntity order = orderRepo.findById(67890L);
if (order != null) {
    System.out.println("Found Order: " + order.getOrderNumber());
}</code></pre>
                </div>

                <div id="basic-operations">
                    <h3>Basic Operations</h3>
                    <pre><code>// Find SMS by ID across all tables
SmsEntity sms = smsRepo.findById(12345L);

// Find order by ID across all partitions  
OrderEntity order = orderRepo.findById(67890L);

// Find entities in date range
List&lt;SmsEntity&gt; recentSms = smsRepo.findByDateRange(startDate, endDate);

// Find entities before specific date
List&lt;OrderEntity&gt; oldOrders = orderRepo.findBeforeDate(cutoffDate);

// Update an SMS entity by ID
SmsEntity updatedSms = new SmsEntity();
updatedSms.setStatus("DELIVERED");
updatedSms.setDeliveredAt(LocalDateTime.now());
smsRepo.updateById(12345L, updatedSms);

// Update an order within a specific date range
OrderEntity updatedOrder = new OrderEntity();
updatedOrder.setStatus("SHIPPED");
updatedOrder.setShippedAt(LocalDateTime.now());
orderRepo.updateByIdAndDateRange(67890L, updatedOrder, 
    LocalDateTime.now().minusDays(7), LocalDateTime.now());</code></pre>
                </div>

                <div id="batch-operations">
                    <h3>Batch Operations & Date Filtering</h3>
                    <pre><code>// Find multiple entities in date range
List&lt;SmsEntity&gt; weeklyMessages = smsRepo.findByDateRange(
    LocalDateTime.now().minusDays(7), LocalDateTime.now());
System.out.println("Found " + weeklyMessages.size() + " messages this week");

// Find entities before specific date
List&lt;OrderEntity&gt; archivedOrders = orderRepo.findBeforeDate(
    LocalDateTime.now().minusMonths(6));
System.out.println("Found " + archivedOrders.size() + " archived orders");

// Insert multiple entities at once
List&lt;SmsEntity&gt; batchMessages = createBatchMessages();
smsRepo.insertMultiple(batchMessages);

// Find first entity in date range
SmsEntity firstToday = smsRepo.findByIdAndDateRange(
    LocalDateTime.now().withHour(0).withMinute(0),
    LocalDateTime.now().withHour(23).withMinute(59));

// Cursor-based iteration - find next entity after a given ID
Long lastProcessedId = 1000L;
OrderEntity nextOrder = orderRepo.findOneByIdGreaterThan(lastProcessedId);
while (nextOrder != null) {
    // Process the order
    processOrder(nextOrder);
    
    // Move cursor to next entity
    lastProcessedId = nextOrder.getId();
    nextOrder = orderRepo.findOneByIdGreaterThan(lastProcessedId);
}

// Multi-table cursor iteration
SmsEntity nextSms = smsRepo.findOneByIdGreaterThan(0L); // Start from beginning
if (nextSms != null) {
    System.out.println("Next SMS ID: " + nextSms.getId());
}</code></pre>
                </div>

                <div id="performance-considerations">
                    <h3>Performance Considerations</h3>
                    <div class="warning">
                        <h4>Performance Warning</h4>
                        <p>ID lookups perform full table scans across all tables/partitions and can be slow for large datasets.</p>
                    </div>

                    <table class="performance-table">
                        <thead>
                            <tr>
                                <th>Operation</th>
                                <th>Performance</th>
                                <th>Use Case</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>findById(12345L)</code></td>
                                <td>SLOW</td>
                                <td>Full table scan across all tables/partitions</td>
                            </tr>
                            <tr>
                                <td><code>findByDateRange(...)</code></td>
                                <td>FAST</td>
                                <td>Date-range query with automatic table/partition selection</td>
                            </tr>
                            <tr>
                                <td>Hybrid approach</td>
                                <td>OPTIMAL</td>
                                <td>If you know approximate date, combine both approaches</td>
                            </tr>
                        </tbody>
                    </table>

                    <div class="tip">
                        <h4>Hybrid Approach Example</h4>
                        <pre><code>// If you know the approximate date, combine both approaches
LocalDateTime suspectedDate = LocalDateTime.of(2025, 8, 15, 10, 30);
List&lt;SmsEntity&gt; dateFilteredSms = smsRepo.findByDateRange(
    suspectedDate.minusHours(12),
    suspectedDate.plusHours(12)
);
// Then filter in memory if needed
SmsEntity targetSms = dateFilteredSms.stream()
    .filter(s -> s.getId().equals(12345L))
    .findFirst().orElse(null);</code></pre>
                    </div>
                </div>
            </section>

            <section id="query-dsl" class="section">
                <h2>Query DSL Examples</h2>
                <p>The library includes a <strong>type-safe Query DSL</strong> for building complex queries:</p>

                <div id="basic-query">
                    <h3>Basic Query</h3>
                    <pre><code>String query = QueryDSL.select()
    .column("user_id")
    .count("*", "message_count")
    .from("sms")
    .where(w -> w.dateRange("created_at", startDate, endDate))
    .groupBy("user_id")
    .orderByDesc("message_count")
    .limit(10)
    .build();</code></pre>
                </div>

                <div id="advanced-aggregation">
                    <h3>Advanced Aggregation</h3>
                    <pre><code>String query = QueryDSL.select()
    .column("DATE(created_at)", "day")
    .count("*", "total_orders")
    .sum("total_amount", "daily_revenue")
    .avg("total_amount", "avg_order_value")
    .aggregate(QueryDSL.AggregateFunction.COUNT, "customer_id", "unique_customers", true)
    .from("orders")
    .where(w -> w
        .dateRange("created_at", startDate, endDate)
        .and("status", QueryDSL.Operator.IN, "CONFIRMED", "SHIPPED", "DELIVERED"))
    .groupBy("DATE(created_at)")
    .orderByDesc("daily_revenue")
    .build();</code></pre>
                </div>

                <div id="complex-conditions">
                    <h3>Complex Conditions</h3>
                    <pre><code>String query = QueryDSL.select()
    .column("*")
    .from("sms")
    .where(w -> w
        .dateRange("created_at", startDate, endDate)
        .and("status", QueryDSL.Operator.EQUALS, "SENT")
        .and("cost", QueryDSL.Operator.GREATER_THAN, new BigDecimal("0.01"))
        .like("message", "%urgent%")
        .isNotNull("user_id"))
    .orderByDesc("created_at")
    .limit(100)
    .build();</code></pre>
                </div>
            </section>

            <section id="annotations" class="section">
                <h2>Entity Annotations</h2>
                <p>Simple annotations for automatic SQL generation and entity mapping:</p>
                
                <div class="feature-grid">
                    <div class="feature-item">
                        <h4>@Table</h4>
                        <pre><code>@Table(name = "orders")
public class OrderEntity { ... }</code></pre>
                        <p>Specifies the table name. If omitted, uses lowercase class name without "Entity" suffix.</p>
                    </div>
                    
                    <div class="feature-item">
                        <h4>@Id</h4>
                        <pre><code>@Id
@Column(name = "id", insertable = false)
private Long id;</code></pre>
                        <p>Marks the primary key field. Supports auto-generation with <code>autoGenerated = true</code> (default).</p>
                    </div>
                    
                    <div class="feature-item">
                        <h4>@ShardingKey</h4>
                        <pre><code>@ShardingKey
@Column(name = "created_at", nullable = false)
private LocalDateTime createdAt;</code></pre>
                        <p>Marks the field used for date-based partitioning/sharding (usually a DateTime field).</p>
                    </div>
                    
                    <div class="feature-item">
                        <h4>@Column</h4>
                        <pre><code>@Column(name = "user_id", nullable = false)
private String userId;

@Column(name = "message")
private String message;</code></pre>
                        <p>Maps field to database column. Supports <code>nullable</code>, <code>insertable</code>, <code>updatable</code> options.</p>
                    </div>
                </div>
                
                <div class="highlight">
                    <h4>Automatic SQL Generation</h4>
                    <p>From these annotations, the framework automatically generates:</p>
                    <ul>
                        <li><strong>INSERT statements:</strong> <code>INSERT INTO table (col1, col2) VALUES (?, ?)</code></li>
                        <li><strong>SELECT statements:</strong> <code>SELECT col1, col2 FROM table WHERE id = ?</code></li>
                        <li><strong>CREATE TABLE statements:</strong> With proper column types, constraints, and indexes</li>
                        <li><strong>Parameter binding:</strong> Type-safe parameter setting based on field types</li>
                        <li><strong>Result mapping:</strong> Automatic ResultSet to entity conversion</li>
                    </ul>
                </div>
            </section>

            <section id="data-models" class="section">
                <h2>Data Models</h2>

                <div id="sms-entity">
                    <h3>SmsEntity (Multi-Table Strategy)</h3>
                    <pre><code>public class SmsEntity {
    private Long id;
    private String userId;
    private String phoneNumber;
    private String message;
    private String status;        // PENDING, SENT, DELIVERED, FAILED
    private LocalDateTime createdAt;
    private LocalDateTime deliveredAt;
    private BigDecimal cost;
    private String provider;      // twilio, aws-sns, etc.
    
    // Constructors, getters, setters...
}</code></pre>
                </div>

                <div id="order-entity">
                    <h3>OrderEntity (Partitioned Table Strategy)</h3>
                    <pre><code>public class OrderEntity {
    private Long id;
    private String customerId;
    private String orderNumber;
    private BigDecimal totalAmount;
    private String status;        // PENDING, CONFIRMED, SHIPPED, DELIVERED, CANCELLED
    private String paymentMethod; // CREDIT_CARD, PAYPAL, BANK_TRANSFER, etc.
    private String shippingAddress;
    private LocalDateTime createdAt;
    private LocalDateTime shippedAt;
    private LocalDateTime deliveredAt;
    private Integer itemCount;
    
    // Constructors, getters, setters...
}</code></pre>
                </div>

                <div id="statistics-classes">
                    <h3>Statistics Classes</h3>
                    
                    <h4>UserSmsStats (Multi-Table)</h4>
                    <pre><code>public class UserSmsStats {
    public final String userId;
    public final long messageCount;
    public final LocalDateTime firstMessage;
    public final LocalDateTime lastMessage;
    public final long totalChars;
    public final double avgMessageLength;
    public final BigDecimal totalCost;
}</code></pre>

                    <h4>CustomerOrderStats (Partitioned Table)</h4>
                    <pre><code>public class CustomerOrderStats {
    public final String customerId;
    public final long orderCount;
    public final BigDecimal totalSpent;
    public final BigDecimal avgOrderValue;
    public final long totalItems;
    public final LocalDateTime firstOrder;
    public final LocalDateTime lastOrder;
}</code></pre>
                </div>
            </section>

            <section id="configuration" class="section">
                <h2>Configuration Options</h2>
                
                <h3>Generic Builder Configuration</h3>
                <pre><code>// Multi-Table Repository (Builder-only instantiation)
GenericMultiTableRepository&lt;SmsEntity, Long&gt; smsRepo = 
    GenericMultiTableRepository.&lt;SmsEntity, Long&gt;builder(SmsEntity.class, Long.class)
        .host("localhost")              // Database host
        .port(3306)                     // Database port  
        .database("messaging")          // Database name (required)
        .username("dbuser")             // Database username (required)
        .password("dbpass")             // Database password (required)
        .logger(customLogger)           // Custom logger (optional, default: ConsoleLogger)
        .tablePrefix("sms")             // Table prefix (optional, uses @Table name)
        .partitionRetentionPeriod(7)    // Keep 7 days of data (default: 7)
        .autoManagePartitions(true)     // Auto create/drop tables (default: true)
        .partitionAdjustmentTime(4, 0)  // Daily maintenance at 04:00 (default: 04:00)
        .monitoring(monitoringConfig)   // Monitoring configuration (optional)
        .build();

// Partitioned Table Repository (Builder-only instantiation)
GenericPartitionedTableRepository&lt;OrderEntity, Long&gt; orderRepo = 
    GenericPartitionedTableRepository.&lt;OrderEntity, Long&gt;builder(OrderEntity.class, Long.class)
        .host("localhost")              // Database host (default: localhost)
        .port(3306)                     // Database port (default: 3306)
        .database("ecommerce")          // Database name (required)
        .username("dbuser")             // Database username (required)
        .password("dbpass")             // Database password (required)
        .logger(customLogger)           // Custom logger (optional, default: ConsoleLogger)
        .tableName("orders")            // Single table name (optional, uses @Table name)
        .partitionRetentionPeriod(30)   // Override default 7 days to 30
        .autoManagePartitions(true)     // Auto create/drop partitions (default: true)
        .partitionAdjustmentTime(4, 0)  // Daily maintenance at 04:00 (default: 04:00)
        .monitoring(monitoringConfig)   // Monitoring configuration (optional)
        .build();</code></pre>
                    
                <h3>Scheduler Configuration Examples</h3>
                <pre><code>// Custom adjustment times
.partitionAdjustmentTime(2, 30)                    // 02:30 AM
.partitionAdjustmentTime(LocalTime.of(23, 45))     // 11:45 PM
.partitionAdjustmentTime(LocalTime.MIDNIGHT)       // 00:00 AM

// Disable auto-management (no scheduler)
.autoManagePartitions(false)

// Complete example with scheduler
MultiTableRepository&lt;Long&gt; repo = MultiTableRepository.&lt;Long&gt;builder()
    .database("myapp")
    .tablePrefix("events")
    .partitionRetentionPeriod(14)           // 14 days retention
    .autoManagePartitions(true)             // Enable scheduler
    .partitionAdjustmentTime(3, 0)          // Run at 03:00 AM
    .build();

// Graceful shutdown (recommended for production)
Runtime.getRuntime().addShutdownHook(new Thread(repo::shutdown));</code></pre>
            </section>

            <section id="automatic-management" class="section">
                <h2>Automatic Management</h2>

                <div class="feature-grid">
                    <div class="feature-item">
                        <h4>Multi-Table Strategy</h4>
                        <ul>
                            <li><strong>On Startup:</strong> Creates all tables for retention period (default 7 days = 15 tables)</li>
                            <li><strong>Table Structure:</strong> Each daily table has 24 hourly partitions (h00-h23)</li>
                            <li><strong>Daily Scheduler:</strong> Runs at <code>partitionAdjustmentTime</code> (default 04:00)</li>
                            <li><strong>Maintenance Range:</strong> <code>{today - 7}</code> to <code>{today + 7}</code> days (default)</li>
                            <li><strong>Table Naming:</strong> <code>{tablePrefix}_{YYYYMMDD}</code> (e.g., <code>sms_20250804</code>)</li>
                        </ul>
                    </div>

                    <div class="feature-item">
                        <h4>Partitioned Table Strategy</h4>
                        <ul>
                            <li><strong>On Startup:</strong> Creates all partitions for retention period (default 7 days = 15 partitions)</li>
                            <li><strong>Daily Scheduler:</strong> Runs at <code>partitionAdjustmentTime</code> (default 04:00)</li>
                            <li><strong>Maintenance Range:</strong> <code>{today - 7}</code> to <code>{today + 7}</code> days (default)</li>
                            <li><strong>Partition Naming:</strong> <code>p{YYYYMMDD}</code> (e.g., <code>p20250804</code>)</li>
                            <li><strong>CRUD Blocking:</strong> All operations blocked during maintenance with clear exceptions</li>
                        </ul>
                    </div>
                </div>
                
                <div class="highlight">
                    <h4>🕐 New: Automatic Daily Scheduler</h4>
                    <p>Both repositories now include a production-ready background scheduler that runs daily at the configured <code>partitionAdjustmentTime</code>. The scheduler:</p>
                    <ul>
                        <li><strong>Smart Scheduling:</strong> Calculates optimal next run time, handles time zone changes</li>
                        <li><strong>Retention Management:</strong> Maintains symmetric range <code>{today-N}</code> to <code>{today+N}</code> days</li>
                        <li><strong>Independent Operation:</strong> Runs regardless of application activity</li>
                        <li><strong>Error Resilience:</strong> Continues operation even if individual maintenance tasks fail</li>
                        <li><strong>Resource Management:</strong> Proper thread lifecycle with graceful shutdown</li>
                        <li><strong>Observability:</strong> Comprehensive logging with operation status and timings</li>
                    </ul>
                </div>
                
                <div class="tip">
                    <h4>Scheduler Best Practices</h4>
                    <ul>
                        <li><strong>Timing:</strong> Schedule during low-traffic periods (default 04:00 AM)</li>
                        <li><strong>Retention:</strong> Set appropriate retention periods based on storage and compliance needs</li>
                        <li><strong>Monitoring:</strong> Monitor scheduler logs for maintenance success/failure</li>
                        <li><strong>Shutdown:</strong> Always call <code>repository.shutdown()</code> during application termination</li>
                        <li><strong>Testing:</strong> Test scheduler behavior in staging environments before production</li>
                    </ul>
                </div>
                
                <h3>Live Scheduler Demo</h3>
                <p>Run the <code>AutoManagementSchedulerDemo.java</code> example to see the scheduler in action:</p>
                <pre><code>// Demonstrates scheduler configuration and behavior
public class AutoManagementSchedulerDemo {
    public static void main(String[] args) {
        // Creates repositories with different scheduler settings
        // Shows scheduler startup, maintenance operations, and shutdown
        // Includes detailed logging of all scheduler activities
    }
}</code></pre>
                
                <p>The demo shows:</p>
                <ul>
                    <li>Scheduler initialization and next run time calculation</li>
                    <li>Maintenance operations with detailed logging</li>
                    <li>Retention range calculations and table/partition management</li>
                    <li>Graceful shutdown and resource cleanup</li>
                </ul>
            </section>

            <section id="use-cases" class="section">
                <h2>Use Cases</h2>

                <div class="feature-grid">
                    <div class="feature-item">
                        <h4>SMS/Messaging Platforms</h4>
                        <pre><code>// High-volume SMS tracking with automatic table rotation
MultiTableRepository&lt;Long&gt; smsRepo = MultiTableRepository.&lt;Long&gt;builder()
    .tablePrefix("sms")
    .partitionRetentionPeriod(90)  // 3 months retention
    .build();

// Track delivery rates by provider
List&lt;SmsEntity&gt; todayMessages = smsRepo.findByDateRange(startDate, endDate);</code></pre>
                    </div>

                    <div class="feature-item">
                        <h4>E-commerce Platforms</h4>
                        <pre><code>// Order management with long-term retention  
PartitionedTableRepository&lt;Long&gt; orderRepo = PartitionedTableRepository.&lt;Long&gt;builder()
    .tableName("orders")
    .partitionRetentionPeriod(2555) // 7 years retention (compliance)
    .build();

// Analyze customer behavior
List&lt;CustomerOrderStats&gt; topCustomers = orderRepo.getCustomerStats(startDate, endDate, 50);</code></pre>
                    </div>

                    <div class="feature-item">
                        <h4>Call Center Systems</h4>
                        <pre><code>// Call logs with automatic cleanup
MultiTableRepository&lt;Long&gt; callRepo = MultiTableRepository.&lt;Long&gt;builder()
    .tablePrefix("calls")
    .partitionRetentionPeriod(180) // 6 months retention
    .build();</code></pre>
                    </div>

                    <div class="feature-item">
                        <h4>Analytics & Reporting</h4>
                        <pre><code>// Event tracking for analytics
MultiTableRepository&lt;Long&gt; eventRepo = MultiTableRepository.&lt;Long&gt;builder()
    .tablePrefix("events")
    .partitionRetentionPeriod(30)  // 1 month retention
    .build();</code></pre>
                    </div>
                </div>
            </section>

            <section id="advanced-features" class="section">
                <h2>Advanced Features</h2>

                <h3>2-Level Query Aggregation (Multi-Table)</h3>
                <div class="highlight">
                    <p>Automatically generated UNION ALL query with proper aggregation:</p>
                </div>
                <pre><code>-- Automatically generated UNION ALL query with proper aggregation
SELECT user_id, SUM(message_count) AS message_count, SUM(total_cost) AS total_cost
FROM (
  SELECT user_id, COUNT(*) AS message_count, SUM(cost) AS total_cost
  FROM sms_20250801 WHERE created_at >= '2025-08-01 00:00:00' AND created_at <= '2025-08-01 23:59:59'
  GROUP BY user_id
  
  UNION ALL
  
  SELECT user_id, COUNT(*) AS message_count, SUM(cost) AS total_cost  
  FROM sms_20250802 WHERE created_at >= '2025-08-02 00:00:00' AND created_at <= '2025-08-02 23:59:59'
  GROUP BY user_id
) unioned
GROUP BY user_id
ORDER BY message_count DESC;</code></pre>

                <h3>Intelligent Aggregation Mapping</h3>
                <ul>
                    <li><strong>COUNT</strong> → <strong>SUM</strong> (across partitions)</li>
                    <li><strong>SUM</strong> → <strong>SUM</strong> (across partitions)</li>
                    <li><strong>MAX</strong> → <strong>MAX</strong> (across partitions)</li>
                    <li><strong>MIN</strong> → <strong>MIN</strong> (across partitions)</li>
                    <li><strong>AVG</strong> → <strong>AVG</strong> (across partitions)</li>
                </ul>

                <h3>Automatic Table Existence Filtering</h3>
                <ul>
                    <li>Only includes existing tables in UNION queries</li>
                    <li>Prevents errors when querying date ranges with missing tables</li>
                    <li>Returns empty results gracefully for non-existent date ranges</li>
                </ul>
            </section>

            <section id="production-features" class="section">
                <h2>Production Features</h2>

                <div class="feature-grid">
                    <div class="feature-item">
                        <h4>Maintenance Locking System</h4>
                        <ul>
                            <li><strong>CRUD Blocking:</strong> All operations blocked during partition maintenance</li>
                            <li><strong>Clear Exceptions:</strong> MaintenanceInProgressException with descriptive messages</li>
                            <li><strong>Thread-Safe:</strong> Uses ReadWriteLock for proper synchronization</li>
                            <li><strong>Automatic Recovery:</strong> Operations resume immediately after maintenance</li>
                        </ul>
                        <pre><code>// Example exception during maintenance:
SQLException: Database connections are blocked for maintenance: 
Automatic partition maintenance for sms_table</code></pre>
                    </div>
                    
                    <div class="feature-item">
                        <h4>SQL Injection Protection</h4>
                        <ul>
                            <li>All datetime values properly quoted and formatted</li>
                            <li>Type-safe parameter binding where applicable</li>
                            <li>Input validation and sanitization</li>
                        </ul>
                    </div>

                    <div class="feature-item">
                        <h4>Error Handling</h4>
                        <ul>
                            <li>Graceful handling of missing tables/partitions</li>
                            <li>Connection timeout management (60 seconds default)</li>
                            <li>Scheduler error recovery and logging</li>
                        </ul>
                    </div>

                    <div class="feature-item">
                        <h4>Performance Optimizations</h4>
                        <ul>
                            <li>Partition pruning for optimal query performance</li>
                            <li>Index optimization on time-based columns</li>
                            <li>Efficient UNION ALL query generation</li>
                            <li>Background maintenance without blocking operations</li>
                        </ul>
                    </div>

                    <div class="feature-item">
                        <h4>Monitoring & Observability</h4>
                        <ul>
                            <li>Built-in logging for table/partition operations</li>
                            <li>Scheduler status and maintenance tracking</li>
                            <li>Detailed retention range calculations</li>
                            <li>Error reporting and recovery metrics</li>
                        </ul>
                    </div>
                    
                    <div class="feature-item">
                        <h4>Automatic Lifecycle Management</h4>
                        <ul>
                            <li>Daily scheduled maintenance at configurable time</li>
                            <li>Graceful scheduler startup and shutdown</li>
                            <li>Thread-safe background operations</li>
                            <li>Resource cleanup on application termination</li>
                        </ul>
                    </div>
                    
                    <div class="feature-item">
                        <h4>Enterprise Ready</h4>
                        <ul>
                            <li>Zero external dependencies</li>
                            <li>Generic type safety for ID columns</li>
                            <li>Production-tested with millions of records</li>
                            <li>Framework-independent (works with Spring, Quarkus, plain Java)</li>
                        </ul>
                    </div>
                </div>
            </section>

            <section id="requirements" class="section">
                <h2>Requirements</h2>
                <ul>
                    <li><strong>Java:</strong> 8+ (tested with Java 11, 17, 21)</li>
                    <li><strong>Database:</strong> MySQL 5.7+ / MariaDB 10.3+</li>
                    <li><strong>Connection:</strong> Plain JDBC with maintenance locking mechanism</li>
                    <li><strong>JDBC Driver:</strong> MySQL Connector/J 8.0+ (included)</li>
                    <li><strong>Framework Independence:</strong> Works with Spring Boot, Quarkus, or plain Java</li>
                </ul>
                
                <div class="highlight">
                    <h4>Connection Management with Maintenance Locking</h4>
                    <p>All database operations use plain JDBC with a robust locking mechanism:</p>
                    <ul>
                        <li><strong>Maintenance Locking:</strong> CRUD operations blocked during partition maintenance</li>
                        <li><strong>Clear Error Messages:</strong> MaintenanceInProgressException with reason</li>
                        <li><strong>Thread-Safe:</strong> Uses Java ReadWriteLock for proper synchronization</li>
                        <li><strong>Automatic Recovery:</strong> Operations resume after maintenance completes</li>
                        <li><strong>No Connection Pooling:</strong> Simple, direct JDBC connections</li>
                    </ul>
                </div>
            </section>

            <section id="getting-started" class="section">
                <h2>Getting Started</h2>
                
                <h3>Quick Setup (5 Minutes)</h3>
                <ol>
                    <li><strong>Annotate your entities</strong> with @Table, @Id, @ShardingKey, @Column</li>
                    <li><strong>Choose your strategy</strong> (Multi-Table vs Partitioned Table)</li>
                    <li><strong>Create generic repository</strong> with entity and key types</li>
                    <li><strong>Configure connection</strong> parameters (host, port, database)</li>
                    <li><strong>Configure scheduler</strong> (optional, enabled by default)</li>
                    <li><strong>Start inserting and querying</strong> - SQL generated automatically!</li>
                </ol>
                
                <h3>Complete Production Example</h3>
                <pre><code>// 1. Annotated Entity
@Table(name = "sms")
public class SmsEntity {
    @Id
    @Column(name = "id", insertable = false)
    private Long id;
    
    @Column(name = "user_id")
    private String userId;
    
    @ShardingKey
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "message")
    private String message;
    // ... other fields with getters/setters
}

// 2. Production-ready repository
@Configuration
public class DataServiceConfig {
    
    @Bean
    public GenericMultiTableRepository&lt;SmsEntity, Long&gt; smsRepository() {
        return GenericMultiTableRepository.&lt;SmsEntity, Long&gt;builder(SmsEntity.class, Long.class)
            .host("production-db")
            .port(3306)
            .database("messaging")
            .username("app_user")
            .password(System.getenv("DB_PASSWORD"))
            .partitionRetentionPeriod(30)        // 30 days retention
            .autoManagePartitions(true)          // Enable scheduler
            .partitionAdjustmentTime(3, 0)       // 03:00 AM maintenance
            // Plain JDBC - no connection pooling needed
            .build();
    }
    
    @PreDestroy
    public void cleanup() {
        smsRepository().shutdown();  // Graceful shutdown
    }
}</code></pre>

                <div class="highlight">
                    <h4>Production Ready with Modern Features</h4>
                    <p><em>This framework combines battle-tested partitioning strategies with modern Java features:</em></p>
                    <ul>
                        <li><strong>Generic Type Safety:</strong> Full compile-time guarantees with <code>Repository&lt;TEntity, TKey&gt;</code></li>
                        <li><strong>Zero Runtime Reflection:</strong> All metadata parsed once at startup for maximum performance</li>
                        <li><strong>Connection Management:</strong> Plain JDBC with maintenance locking for data consistency</li>
                        <li><strong>Automatic SQL Generation:</strong> No more hardcoded SQL - everything inferred from annotations</li>
                        <li><strong>Scheduler Automation:</strong> Enterprise-grade automatic maintenance and lifecycle management</li>
                    </ul>
                    
                    <p><strong>Perfect for:</strong> High-frequency data ingestion, time-series analytics, audit logging, messaging platforms, IoT data collection, microservices, and any application requiring type-safe, high-performance data access with automatic lifecycle management.</p>
                </div>
            </section>
        </main>
    </div>

    <button class="scroll-top" onclick="scrollToTop()">↑</button>

    <script>
        // Smooth scrolling for navigation links
        document.querySelectorAll('.sidebar a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // Scroll to top functionality
        function scrollToTop() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }

        // Show/hide scroll to top button
        window.addEventListener('scroll', function() {
            const scrollTop = document.querySelector('.scroll-top');
            if (window.pageYOffset > 300) {
                scrollTop.style.display = 'block';
            } else {
                scrollTop.style.display = 'none';
            }
        });

        // Mobile menu toggle
        if (window.innerWidth <= 1024) {
            const container = document.querySelector('.container');
            if (container) {
                container.addEventListener('click', function(e) {
                    if (e.target.textContent === '☰ Menu') {
                        const sidebar = document.querySelector('.sidebar');
                        if (sidebar) {
                            sidebar.classList.toggle('active');
                        }
                    }
                });
            }
        }

        // Active section highlighting
        window.addEventListener('scroll', function() {
            const sections = document.querySelectorAll('.section');
            const navLinks = document.querySelectorAll('.sidebar a');
            
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                const sectionHeight = section.clientHeight;
                if (window.pageYOffset >= sectionTop - 200) {
                    current = section.getAttribute('id');
                }
            });

            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });
        });
    </script>

    <style>
        .sidebar a.active {
            background: #3498db;
            color: white;
            transform: translateX(5px);
        }
        
        .scroll-top {
            display: none;
        }
    </style>
</body>
</html>