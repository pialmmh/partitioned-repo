<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Split-Verse: Infinite Horizontal Sharding for MySQL</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
        }
        
        .header {
            text-align: center;
            padding: 60px 20px;
            background: rgba(255,255,255,0.95);
            border-radius: 20px;
            margin-bottom: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
        }
        
        .header h1 {
            font-size: 3.5em;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 20px;
        }
        
        .header .subtitle {
            font-size: 1.5em;
            color: #666;
            margin-bottom: 30px;
        }
        
        .badges {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .badge {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 8px 16px;
            border-radius: 25px;
            font-size: 0.9em;
            font-weight: bold;
        }
        
        .section {
            background: white;
            border-radius: 15px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        
        .section h2 {
            color: #667eea;
            margin-bottom: 25px;
            font-size: 2em;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }
        
        .section h3 {
            color: #764ba2;
            margin-top: 25px;
            margin-bottom: 15px;
            font-size: 1.4em;
        }
        
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin-top: 30px;
        }
        
        .feature-card {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 25px;
            border-radius: 12px;
            transition: transform 0.3s;
        }
        
        .feature-card:hover {
            transform: translateY(-5px);
        }
        
        .feature-card h4 {
            color: #667eea;
            margin-bottom: 10px;
        }
        
        pre {
            background: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            line-height: 1.5;
        }
        
        code {
            background: #e2e8f0;
            color: #2d3748;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        .api-method {
            background: #f7fafc;
            border-left: 4px solid #667eea;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        
        .api-method h4 {
            color: #2d3748;
            margin-bottom: 10px;
            font-family: 'Courier New', monospace;
        }
        
        .api-method .description {
            color: #666;
            margin-bottom: 10px;
        }
        
        .api-method .params {
            margin-top: 15px;
        }
        
        .api-method .params strong {
            color: #667eea;
        }
        
        .warning {
            background: #fff5f5;
            border-left: 4px solid #fc8181;
            padding: 15px;
            margin: 20px 0;
            border-radius: 8px;
        }
        
        .info {
            background: #ebf8ff;
            border-left: 4px solid #4299e1;
            padding: 15px;
            margin: 20px 0;
            border-radius: 8px;
        }
        
        .success {
            background: #f0fff4;
            border-left: 4px solid #48bb78;
            padding: 15px;
            margin: 20px 0;
            border-radius: 8px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        th, td {
            text-align: left;
            padding: 12px;
            border-bottom: 1px solid #e2e8f0;
        }
        
        th {
            background: #667eea;
            color: white;
            font-weight: bold;
        }
        
        tr:hover {
            background: #f7fafc;
        }
        
        .footer {
            text-align: center;
            padding: 40px;
            color: white;
            margin-top: 60px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ Split-Verse</h1>
            <div class="subtitle">Infinite Horizontal Sharding Layer for MySQL</div>
            <div class="badges">
                <span class="badge">Version 1.0</span>
                <span class="badge">String IDs Only</span>
                <span class="badge">No AUTO_INCREMENT</span>
                <span class="badge">Hash-Based Routing</span>
                <span class="badge">Multi-Shard Ready</span>
            </div>
        </div>
        
        <div class="section">
            <h2>üéØ Overview</h2>
            <p>
                <strong>Split-Verse</strong> is an infinite horizontal sharding layer built on top of the partitioned-repo framework. 
                It provides seamless distribution of data across multiple MySQL instances using consistent hash-based routing.
            </p>
            
            <div class="info">
                <strong>Key Design Principle:</strong> All entities must use externally generated String IDs (UUID, NanoID, ULID, etc.). 
                AUTO_INCREMENT is not supported to ensure proper shard distribution and avoid ID conflicts.
            </div>
            
            <h3>Core Features</h3>
            <div class="feature-grid">
                <div class="feature-card">
                    <h4>üîÄ Hash-Based Routing</h4>
                    <p>Automatic key distribution using consistent hashing with virtual nodes for balanced load distribution</p>
                </div>
                <div class="feature-card">
                    <h4>‚ôæÔ∏è Infinite Scaling</h4>
                    <p>Add unlimited MySQL shards as your data grows, with minimal configuration changes</p>
                </div>
                <div class="feature-card">
                    <h4>üîë String IDs Only</h4>
                    <p>Enforces external ID generation for proper shard distribution and conflict-free scaling</p>
                </div>
                <div class="feature-card">
                    <h4>‚ö° Parallel Queries</h4>
                    <p>Fan-out queries execute in parallel across shards for optimal performance</p>
                </div>
            </div>
        </div>
        
        <div class="section">
            <h2>üìö Split-Verse API Reference</h2>
            
            <h3>Repository Creation</h3>
            
            <div class="api-method">
                <h4>SplitVerseRepository.builder()</h4>
                <div class="description">Creates a new Split-Verse repository with sharding capabilities</div>
                <pre>SplitVerseRepository&lt;SubscriberEntity&gt; repository = 
    SplitVerseRepository.&lt;SubscriberEntity&gt;builder()
        .withSingleShard(shardConfig)      // For single shard
        .withShardConfigs(shardList)       // For multiple shards
        .withEntityClass(SubscriberEntity.class)
        .build();</pre>
            </div>
            
            <h3>Core APIs</h3>
            
            <div class="api-method">
                <h4>void insert(T entity)</h4>
                <div class="description">Inserts an entity into the appropriate shard based on its ID hash</div>
                <div class="params">
                    <strong>Parameters:</strong>
                    <ul>
                        <li><code>entity</code> - The entity to insert (must have a non-null String ID)</li>
                    </ul>
                </div>
                <pre>SubscriberEntity subscriber = new SubscriberEntity();
subscriber.setId(NanoId.randomNanoId());  // External ID generation
subscriber.setMsisdn("+8801712345678");
subscriber.setCreatedAt(LocalDateTime.now());

repository.insert(subscriber);</pre>
            </div>
            
            <div class="api-method">
                <h4>void insertMultiple(List&lt;T&gt; entities)</h4>
                <div class="description">Batch inserts entities, automatically grouping them by target shard</div>
                <div class="params">
                    <strong>Parameters:</strong>
                    <ul>
                        <li><code>entities</code> - List of entities to insert</li>
                    </ul>
                </div>
                <pre>List&lt;SubscriberEntity&gt; subscribers = generateSubscribers(1000);
repository.insertMultiple(subscribers);  // Automatically distributed</pre>
            </div>
            
            <div class="api-method">
                <h4>T findById(String id)</h4>
                <div class="description">Finds an entity by its ID, routing directly to the correct shard</div>
                <div class="params">
                    <strong>Parameters:</strong>
                    <ul>
                        <li><code>id</code> - The String ID of the entity</li>
                    </ul>
                    <strong>Returns:</strong> The entity, or null if not found
                </div>
                <pre>String subscriberId = "sub_abc123def456";
SubscriberEntity found = repository.findById(subscriberId);</pre>
            </div>
            
            <div class="api-method">
                <h4>List&lt;T&gt; findAllByDateRange(LocalDateTime start, LocalDateTime end)</h4>
                <div class="description">Fan-out query to all shards for entities within a date range</div>
                <div class="params">
                    <strong>Parameters:</strong>
                    <ul>
                        <li><code>start</code> - Start of date range</li>
                        <li><code>end</code> - End of date range</li>
                    </ul>
                    <strong>Returns:</strong> Combined results from all shards
                </div>
                <pre>LocalDateTime yesterday = LocalDateTime.now().minusDays(1);
LocalDateTime now = LocalDateTime.now();
List&lt;SubscriberEntity&gt; recent = repository.findAllByDateRange(yesterday, now);</pre>
            </div>
            
            <div class="api-method">
                <h4>List&lt;T&gt; findAllByIdsAndDateRange(List&lt;String&gt; ids, LocalDateTime start, LocalDateTime end)</h4>
                <div class="description">Finds multiple entities by IDs within a date range, optimizing queries per shard</div>
                <div class="params">
                    <strong>Parameters:</strong>
                    <ul>
                        <li><code>ids</code> - List of String IDs to find</li>
                        <li><code>start</code> - Start of date range</li>
                        <li><code>end</code> - End of date range</li>
                    </ul>
                </div>
            </div>
            
            <div class="api-method">
                <h4>void updateById(String id, T entity)</h4>
                <div class="description">Updates an entity by ID, routing to the correct shard</div>
                <div class="params">
                    <strong>Parameters:</strong>
                    <ul>
                        <li><code>id</code> - The String ID of the entity to update</li>
                        <li><code>entity</code> - The updated entity data</li>
                    </ul>
                </div>
            </div>
            
            <div class="api-method">
                <h4>T findOneByIdGreaterThan(String id)</h4>
                <div class="description">Finds the next entity with ID greater than the specified ID (for cursor-based pagination)</div>
                <div class="params">
                    <strong>Parameters:</strong>
                    <ul>
                        <li><code>id</code> - The cursor ID</li>
                    </ul>
                    <strong>Returns:</strong> Next entity after the cursor
                </div>
            </div>
            
            <div class="api-method">
                <h4>List&lt;T&gt; findBatchByIdGreaterThan(String id, int batchSize)</h4>
                <div class="description">Retrieves a batch of entities for cursor-based pagination</div>
                <div class="params">
                    <strong>Parameters:</strong>
                    <ul>
                        <li><code>id</code> - The cursor ID</li>
                        <li><code>batchSize</code> - Maximum number of entities to return</li>
                    </ul>
                </div>
            </div>
            
            <div class="api-method">
                <h4>void shutdown()</h4>
                <div class="description">Gracefully shuts down all shard connections and thread pools</div>
            </div>
        </div>
        
        <div class="section">
            <h2>üîß Configuration</h2>
            
            <h3>ShardConfig</h3>
            <p>Configuration for individual MySQL shards:</p>
            
            <pre>ShardConfig shard1 = ShardConfig.builder()
    .shardId("shard-001")
    .host("mysql1.example.com")
    .port(3306)
    .database("telecom_shard1")
    .username("app_user")
    .password("secure_password")
    .connectionPoolSize(10)
    .enabled(true)
    .build();</pre>
            
            <h3>Entity Requirements</h3>
            
            <div class="warning">
                <strong>Important:</strong> All entities must implement <code>ShardingEntity</code> interface with:
                <ul>
                    <li><code>String getId()</code> - Returns the entity's String ID</li>
                    <li><code>void setId(String id)</code> - Sets the entity's String ID</li>
                    <li><code>LocalDateTime getCreatedAt()</code> - Returns the partition key datetime</li>
                    <li><code>void setCreatedAt(LocalDateTime dt)</code> - Sets the partition key datetime</li>
                </ul>
            </div>
            
            <pre>@Table(name = "subscribers")
public class SubscriberEntity implements ShardingEntity {
    
    @Id(autoGenerated = false)  // CRITICAL: No AUTO_INCREMENT
    @Column(name = "subscriber_id")
    private String id;
    
    @ShardingKey
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;
    
    // Required interface methods
    public String getId() { return id; }
    public void setId(String id) { this.id = id; }
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { 
        this.createdAt = createdAt; 
    }
}</pre>
        </div>
        
        <div class="section">
            <h2>üí° Usage Examples</h2>
            
            <h3>Single Shard Setup</h3>
            <pre>// Configure single shard
ShardConfig config = ShardConfig.builder()
    .shardId("primary")
    .host("127.0.0.1")
    .database("myapp_db")
    .username("root")
    .password("password")
    .build();

// Create repository
SplitVerseRepository&lt;UserEntity&gt; users = 
    SplitVerseRepository.&lt;UserEntity&gt;builder()
        .withSingleShard(config)
        .withEntityClass(UserEntity.class)
        .build();

// Use the repository
UserEntity user = new UserEntity();
user.setId(UUID.randomUUID().toString());
user.setName("John Doe");
user.setCreatedAt(LocalDateTime.now());

users.insert(user);</pre>
            
            <h3>Multi-Shard Setup</h3>
            <pre>// Configure multiple shards
List&lt;ShardConfig&gt; shards = Arrays.asList(
    ShardConfig.builder()
        .shardId("shard-us-east")
        .host("us-east.mysql.example.com")
        .database("app_shard_1")
        .build(),
    
    ShardConfig.builder()
        .shardId("shard-us-west")
        .host("us-west.mysql.example.com")
        .database("app_shard_2")
        .build(),
    
    ShardConfig.builder()
        .shardId("shard-eu-central")
        .host("eu.mysql.example.com")
        .database("app_shard_3")
        .build()
);

// Create multi-shard repository
SplitVerseRepository&lt;OrderEntity&gt; orders = 
    SplitVerseRepository.&lt;OrderEntity&gt;builder()
        .withShardConfigs(shards)
        .withEntityClass(OrderEntity.class)
        .build();

// Data automatically distributed across shards
for (int i = 0; i < 10000; i++) {
    OrderEntity order = new OrderEntity();
    order.setId(NanoId.randomNanoId());  // External ID
    order.setCustomerId("cust_" + i);
    order.setAmount(BigDecimal.valueOf(99.99));
    order.setCreatedAt(LocalDateTime.now());
    
    orders.insert(order);  // Automatically routed to correct shard
}</pre>
            
            <h3>Cursor-Based Pagination</h3>
            <pre>// Process large datasets efficiently
String cursor = null;
int batchSize = 100;

while (true) {
    List&lt;ProductEntity&gt; batch = repository.findBatchByIdGreaterThan(cursor, batchSize);
    
    if (batch.isEmpty()) {
        break;  // No more data
    }
    
    // Process batch
    for (ProductEntity product : batch) {
        processProduct(product);
    }
    
    // Update cursor for next iteration
    cursor = batch.get(batch.size() - 1).getId();
}</pre>
        </div>
        
        <div class="section">
            <h2>üöÄ Migration Path</h2>
            
            <table>
                <thead>
                    <tr>
                        <th>Phase</th>
                        <th>Configuration</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Phase 1</strong></td>
                        <td>Single Shard</td>
                        <td>Start with one shard wrapping existing partitioned table</td>
                    </tr>
                    <tr>
                        <td><strong>Phase 2</strong></td>
                        <td>Read Replica</td>
                        <td>Add read replicas as additional shards (read-only)</td>
                    </tr>
                    <tr>
                        <td><strong>Phase 3</strong></td>
                        <td>Multi-Master</td>
                        <td>Enable writes to multiple shards with hash routing</td>
                    </tr>
                    <tr>
                        <td><strong>Phase 4</strong></td>
                        <td>Full Sharding</td>
                        <td>Complete data distribution across all shards</td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <div class="section">
            <h2>‚ö° Performance Characteristics</h2>
            
            <h3>Operation Complexity</h3>
            <table>
                <thead>
                    <tr>
                        <th>Operation</th>
                        <th>Single Shard</th>
                        <th>Multi-Shard</th>
                        <th>Notes</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Insert by ID</td>
                        <td>O(1)</td>
                        <td>O(1)</td>
                        <td>Direct routing via hash</td>
                    </tr>
                    <tr>
                        <td>Find by ID</td>
                        <td>O(1)</td>
                        <td>O(1)</td>
                        <td>Direct routing via hash</td>
                    </tr>
                    <tr>
                        <td>Find by Date Range</td>
                        <td>O(n)</td>
                        <td>O(n/s)</td>
                        <td>Parallel query across s shards</td>
                    </tr>
                    <tr>
                        <td>Batch Insert</td>
                        <td>O(n)</td>
                        <td>O(n/s)</td>
                        <td>Distributed across shards</td>
                    </tr>
                </tbody>
            </table>
        </div>
        
        <div class="section">
            <h2>üì¶ External ID Generators</h2>
            
            <p>Since AUTO_INCREMENT is not supported, use these external ID generation strategies:</p>
            
            <div class="feature-grid">
                <div class="feature-card">
                    <h4>UUID v4</h4>
                    <pre>String id = UUID.randomUUID().toString();
// "550e8400-e29b-41d4-a716-446655440000"</pre>
                </div>
                <div class="feature-card">
                    <h4>NanoID</h4>
                    <pre>String id = NanoId.randomNanoId();
// "V1StGXR8_Z5jdHi6B-myT"</pre>
                </div>
                <div class="feature-card">
                    <h4>ULID</h4>
                    <pre>String id = UlidCreator.getUlid().toString();
// "01ARZ3NDEKTSV4RRFFQ69G5FAV"</pre>
                </div>
                <div class="feature-card">
                    <h4>Custom Prefix</h4>
                    <pre>String id = "user_" + UUID.randomUUID();
// "user_550e8400-e29b-41d4-a716"</pre>
                </div>
            </div>
        </div>
        
        <div class="section">
            <h2>üîç Troubleshooting</h2>
            
            <h3>Common Issues</h3>
            
            <div class="warning">
                <strong>Issue:</strong> "Entity ID cannot be null"<br>
                <strong>Solution:</strong> Always generate IDs before insertion. Split-Verse does not support AUTO_INCREMENT.
            </div>
            
            <div class="warning">
                <strong>Issue:</strong> "Multiple primary key defined"<br>
                <strong>Solution:</strong> Ensure only single String ID is used as primary key. No composite keys.
            </div>
            
            <div class="info">
                <strong>Issue:</strong> Uneven shard distribution<br>
                <strong>Solution:</strong> Use high-quality random ID generators (UUID, NanoID) for better hash distribution.
            </div>
        </div>
        
        <div class="footer">
            <p><strong>Split-Verse</strong> - Infinite Horizontal Sharding for MySQL</p>
            <p>Built with ‚ù§Ô∏è for massive scale applications</p>
            <p>¬© 2025 TelcoBright</p>
        </div>
    </div>
</body>
</html>