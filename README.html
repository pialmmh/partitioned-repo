<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generic Sharding-Aware Repository Framework</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f8f9fa;
        }

        .container {
            display: flex;
            min-height: 100vh;
        }

        .sidebar {
            width: 280px;
            background: #2c3e50;
            color: white;
            padding: 20px;
            position: fixed;
            height: 100vh;
            overflow-y: auto;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
        }

        .sidebar h2 {
            font-size: 1.2rem;
            margin-bottom: 20px;
            color: #ecf0f1;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }

        .sidebar ul {
            list-style: none;
        }

        .sidebar li {
            margin-bottom: 8px;
        }

        .sidebar a {
            color: #bdc3c7;
            text-decoration: none;
            display: block;
            padding: 8px 12px;
            border-radius: 4px;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .sidebar a:hover {
            background: #34495e;
            color: #3498db;
            transform: translateX(5px);
        }

        .sidebar .level-2 {
            padding-left: 20px;
            font-size: 0.85rem;
        }

        .sidebar .level-3 {
            padding-left: 35px;
            font-size: 0.8rem;
        }

        .main-content {
            margin-left: 280px;
            padding: 40px;
            max-width: 1200px;
            background: white;
            min-height: 100vh;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 40px 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .section {
            margin-bottom: 50px;
            scroll-margin-top: 20px;
        }

        .section h2 {
            font-size: 2rem;
            color: #2c3e50;
            margin-bottom: 20px;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }

        .section h3 {
            font-size: 1.5rem;
            color: #34495e;
            margin: 30px 0 15px 0;
            position: relative;
        }

        .section h3::before {
            content: "▶";
            color: #3498db;
            margin-right: 10px;
            font-size: 0.8em;
        }

        .section h4 {
            font-size: 1.2rem;
            color: #555;
            margin: 25px 0 10px 0;
            font-weight: 600;
        }

        .strategy-card {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 25px;
            margin: 20px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .strategy-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }

        .strategy-card h4 {
            color: #2c3e50;
            font-size: 1.3rem;
            margin-bottom: 15px;
        }

        .strategy-card .icon {
            font-size: 2rem;
            margin-bottom: 10px;
            display: block;
        }

        .multi-table .icon {
            color: #e74c3c;
        }

        .partitioned-table .icon {
            color: #27ae60;
        }

        pre {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 15px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            font-size: 0.9rem;
            line-height: 1.4;
        }

        code {
            background: #ecf0f1;
            color: #2c3e50;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9em;
        }

        pre code {
            background: transparent;
            color: inherit;
            padding: 0;
        }

        .highlight {
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
            padding: 20px;
            border-radius: 8px;
            border-left: 5px solid #e67e22;
            margin: 20px 0;
        }

        .warning {
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
            padding: 15px;
            border-radius: 8px;
            border-left: 5px solid #e74c3c;
            margin: 15px 0;
        }

        .tip {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
            padding: 15px;
            border-radius: 8px;
            border-left: 5px solid #1abc9c;
            margin: 15px 0;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .feature-item {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .feature-item h4 {
            color: #3498db;
            margin-bottom: 10px;
        }

        .api-method {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
            margin: 10px 0;
            border-left: 4px solid #3498db;
        }

        .api-method h5 {
            color: #2c3e50;
            margin-bottom: 8px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.95rem;
        }

        .performance-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
            overflow: hidden;
        }

        .performance-table th,
        .performance-table td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #e9ecef;
        }

        .performance-table th {
            background: #3498db;
            color: white;
            font-weight: 600;
        }

        .performance-table tr:hover {
            background: #f8f9fa;
        }

        .scroll-top {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: #3498db;
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            font-size: 1.2rem;
        }

        .scroll-top:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        @media (max-width: 1024px) {
            .sidebar {
                transform: translateX(-280px);
                transition: transform 0.3s ease;
            }
            
            .sidebar.active {
                transform: translateX(0);
            }
            
            .main-content {
                margin-left: 0;
                padding: 20px;
            }
            
            .container::before {
                content: "☰ Menu";
                position: fixed;
                top: 20px;
                left: 20px;
                background: #3498db;
                color: white;
                padding: 10px 15px;
                border-radius: 5px;
                cursor: pointer;
                z-index: 1000;
                font-size: 0.9rem;
            }
        }

        .emoji {
            font-size: 1.2em;
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <nav class="sidebar">
            <h2>Table of Contents</h2>
            <ul>
                <li><a href="#overview">Overview</a>
                    <ul>
                        <li><a href="#multi-table-strategy" class="level-2">Multi-Table Strategy</a></li>
                        <li><a href="#partitioned-table-strategy" class="level-2">Partitioned Table Strategy</a></li>
                    </ul>
                </li>
                <li><a href="#quick-start">Quick Start</a>
                    <ul>
                        <li><a href="#multi-table-example" class="level-2">Multi-Table Example</a></li>
                        <li><a href="#partitioned-table-example" class="level-2">Partitioned Table Example</a></li>
                    </ul>
                </li>
                <li><a href="#api-reference">API Reference</a>
                    <ul>
                        <li><a href="#multitable-api" class="level-2">MultiTableRepository API</a></li>
                        <li><a href="#partitioned-api" class="level-2">PartitionedTableRepository API</a></li>
                    </ul>
                </li>
                <li><a href="#findbyid-examples">findById Examples</a>
                    <ul>
                        <li><a href="#basic-id-lookups" class="level-2">Basic ID Lookups</a></li>
                        <li><a href="#custom-column-searches" class="level-2">Custom Column Searches</a></li>
                        <li><a href="#multiple-results" class="level-2">Multiple Results</a></li>
                        <li><a href="#performance-considerations" class="level-2">Performance Considerations</a></li>
                    </ul>
                </li>
                <li><a href="#query-dsl">Query DSL</a>
                    <ul>
                        <li><a href="#basic-query" class="level-2">Basic Query</a></li>
                        <li><a href="#advanced-aggregation" class="level-2">Advanced Aggregation</a></li>
                        <li><a href="#complex-conditions" class="level-2">Complex Conditions</a></li>
                    </ul>
                </li>
                <li><a href="#data-models">Data Models</a>
                    <ul>
                        <li><a href="#sms-entity" class="level-2">SmsEntity</a></li>
                        <li><a href="#order-entity" class="level-2">OrderEntity</a></li>
                        <li><a href="#statistics-classes" class="level-2">Statistics Classes</a></li>
                    </ul>
                </li>
                <li><a href="#configuration">Configuration</a>
                    <ul>
                        <li><a href="#scheduler-configuration-examples" class="level-2">Scheduler Configuration</a></li>
                    </ul>
                </li>
                <li><a href="#automatic-management">Automatic Management</a>
                    <ul>
                        <li><a href="#scheduler-best-practices" class="level-2">Scheduler Best Practices</a></li>
                        <li><a href="#live-scheduler-demo" class="level-2">Live Scheduler Demo</a></li>
                    </ul>
                </li>
                <li><a href="#use-cases">Use Cases</a></li>
                <li><a href="#advanced-features">Advanced Features</a></li>
                <li><a href="#production-features">Production Features</a></li>
                <li><a href="#requirements">Requirements</a></li>
                <li><a href="#getting-started">Getting Started</a></li>
            </ul>
        </nav>

        <main class="main-content">
            <div class="header">
                <h1>Generic Sharding-Aware Repository Framework</h1>
                <p>Production-ready, framework-independent Java library with automatic SQL generation, HikariCP pooling, and type-safe generic repositories</p>
            </div>

            <section id="overview" class="section">
                <h2>Overview</h2>
                <p>This library provides <strong>generic, type-safe repositories</strong> with automatic SQL generation and HikariCP-based connection pooling. It supports two complementary partitioning strategies with <strong>complete CRUD operations</strong>:</p>
                
                <div class="highlight">
                    <h4>New Features</h4>
                    <ul>
                        <li><strong>Generic Type Safety:</strong> <code>Repository&lt;TEntity, TKey&gt;</code> with compile-time guarantees</li>
                        <li><strong>Automatic SQL Generation:</strong> INSERT, SELECT, CREATE TABLE statements inferred from entity annotations</li>
                        <li><strong>Zero Runtime Reflection:</strong> All metadata parsed once at startup for maximum performance</li>
                        <li><strong>HikariCP Integration:</strong> Production-ready connection pooling with full configuration options</li>
                        <li><strong>Annotation-Based Mapping:</strong> Simple <code>@Table</code>, <code>@Column</code>, <code>@Id</code>, <code>@ShardingKey</code> annotations</li>
                    </ul>
                </div>

                <div class="feature-grid">
                    <div id="multi-table-strategy" class="strategy-card multi-table">
                        <h4>Multi-Table Strategy</h4>
                        <ul>
                            <li><strong>Best for:</strong> High-volume, short-retention data (SMS, logs, events, alerts)</li>
                            <li><strong>Approach:</strong> Creates separate physical tables per day (<code>sms_20250804</code>, <code>sms_20250805</code>, etc.)</li>
                            <li><strong>Queries:</strong> Uses intelligent UNION ALL with 2-level aggregation</li>
                            <li><strong>ID Lookups:</strong> Cross-table UNION ALL searches with table existence filtering</li>
                            <li><strong>Benefits:</strong> Independent table optimization, easy archival, horizontal scaling</li>
                        </ul>
                    </div>

                    <div id="partitioned-table-strategy" class="strategy-card partitioned-table">
                        <h4>Partitioned Table Strategy</h4>
                        <ul>
                            <li><strong>Best for:</strong> Structured, long-retention data (orders, customers, transactions)</li>
                            <li><strong>Approach:</strong> Single logical table with MySQL native partitioning (<code>p20250804</code>, <code>p20250805</code>, etc.)</li>
                            <li><strong>Queries:</strong> Simple SQL with automatic partition pruning</li>
                            <li><strong>ID Lookups:</strong> MySQL native partition scanning for optimal performance</li>
                            <li><strong>Benefits:</strong> ACID compliance, referential integrity, simplified queries</li>
                        </ul>
                    </div>
                </div>
            </section>

            <section id="quick-start" class="section">
                <h2>Quick Start</h2>

                <div id="multi-table-example">
                    <h3>Generic Multi-Table Repository (SMS Example)</h3>
                    <pre><code>// 1. Entity with annotations (automatic SQL generation)
@Table(name = "sms")
public class SmsEntity {
    @Id
    @Column(name = "id", insertable = false)
    private Long id;
    
    @Column(name = "user_id")
    private String userId;
    
    @ShardingKey
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "message")
    private String message;
    // ... other fields
}

// 2. Create generic repository with type safety and HikariCP
GenericMultiTableRepository&lt;SmsEntity, Long&gt; smsRepo = 
    GenericMultiTableRepository.&lt;SmsEntity, Long&gt;builder(SmsEntity.class, Long.class)
        .host("127.0.0.1")
        .port(3306)
        .database("messaging")
        .username("root")
        .password("password")
        .tablePrefix("sms")        // Optional: inferred from @Table
        .partitionRetentionPeriod(30)  // Keep 30 days
        .autoManagePartitions(true)    // Auto create/drop tables
        .partitionAdjustmentTime(4, 0) // Daily maintenance at 04:00
        // HikariCP connection pool configuration
        .maxPoolSize(25)               // 25 connections max
        .minIdleConnections(5)         // 5 idle connections
        .connectionTimeout(30000)      // 30s timeout
        .build();

// 3. Insert data - SQL automatically generated from annotations
SmsEntity sms = new SmsEntity("user123", "+1234567890", 
    "Hello World!", "SENT", LocalDateTime.now(), new BigDecimal("0.05"), "twilio");
smsRepo.insert(sms);  // Auto-generates: INSERT INTO messaging.sms_20250804 (user_id, phone_number, message, status, created_at, cost, provider) VALUES (?, ?, ?, ?, ?, ?, ?)

// 4. Type-safe queries with automatic table routing
long totalMessages = smsRepo.countByDateRange(
    LocalDateTime.now().minusDays(7), 
    LocalDateTime.now()
);

// 5. Find by ID across all tables
SmsEntity foundSms = smsRepo.findById(12345L);

// 6. Find all SMS for a user
List&lt;SmsEntity&gt; userSms = smsRepo.findAllById("user_id", "user123");</code></pre>
                </div>

                <div id="partitioned-table-example">
                    <h3>Generic Partitioned Table Repository (Orders Example)</h3>
                    <pre><code>// 1. Entity with annotations (automatic SQL generation)
@Table(name = "orders")
public class OrderEntity {
    @Id
    @Column(name = "id", insertable = false)
    private Long id;
    
    @Column(name = "customer_id", nullable = false)
    private String customerId;
    
    @ShardingKey
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "total_amount", nullable = false)
    private BigDecimal totalAmount;
    // ... other fields
}

// 2. Create generic repository with MySQL native partitioning and HikariCP
GenericPartitionedTableRepository&lt;OrderEntity, Long&gt; orderRepo = 
    GenericPartitionedTableRepository.&lt;OrderEntity, Long&gt;builder(OrderEntity.class, Long.class)
        .host("127.0.0.1")
        .port(3306)
        .database("ecommerce")
        .username("root")
        .password("password")
        .tableName("orders")           // Optional: inferred from @Table
        .partitionRetentionPeriod(365) // Keep 1 year
        .autoManagePartitions(true)    // Auto create/drop partitions
        .partitionAdjustmentTime(4, 0) // Daily maintenance at 04:00
        // HikariCP connection pool configuration for high-volume processing
        .maxPoolSize(30)               // 30 connections for order processing
        .minIdleConnections(10)        // 10 idle connections ready
        .idleTimeout(900000)           // 15 min idle timeout
        .maxLifetime(3600000)          // 1 hour max connection lifetime
        .build();

// 3. Insert data - SQL automatically generated with partition routing
OrderEntity order = new OrderEntity("CUST001", "ORD-2025-001", 
    new BigDecimal("299.99"), "CONFIRMED", "CREDIT_CARD", 
    "123 Main St", LocalDateTime.now(), 3);
orderRepo.insert(order);  // Auto-generates: INSERT INTO ecommerce.orders (customer_id, order_number, total_amount, status, payment_method, shipping_address, created_at, item_count) VALUES (?, ?, ?, ?, ?, ?, ?, ?)

// 4. Type-safe queries with automatic partition pruning
List&lt;OrderEntity&gt; recentOrders = orderRepo.findByDateRange(
    LocalDateTime.now().minusDays(7),
    LocalDateTime.now() 
);

// 5. Find by ID with MySQL partition scanning
OrderEntity foundOrder = orderRepo.findById(67890L);

// 6. Find all orders for a customer
List&lt;OrderEntity&gt; customerOrders = orderRepo.findAllById("customer_id", "CUST001");</code></pre>
                </div>
            </section>

            <section id="api-reference" class="section">
                <h2>Public API Reference</h2>

                <div id="multitable-api">
                    <h3>GenericMultiTableRepository&lt;TEntity, TKey&gt; API</h3>
                    <p><strong>TEntity</strong> - The entity type (SmsEntity, EventEntity, etc.)</p>
                    <p><strong>TKey</strong> - The primary key type (Long, String, UUID, etc.)</p>
                    
                    <h4>Builder Configuration</h4>
                    <div class="api-method">
                        <h5>GenericMultiTableRepository.&lt;TEntity, TKey&gt;builder(Class&lt;TEntity&gt;, Class&lt;TKey&gt;)</h5>
                        <p>Create builder with entity and key types for compile-time safety</p>
                    </div>
                    
                    <div class="api-method">
                        <h5>.maxPoolSize(int) / .minIdleConnections(int) / .connectionTimeout(long)</h5>
                        <p>Configure HikariCP connection pool settings</p>
                    </div>
                    
                    <h4>Core Operations</h4>
                    <div class="api-method">
                        <h5>void insert(TEntity entity)</h5>
                        <p>Insert entity with automatic SQL generation (auto-creates tables)</p>
                    </div>
                    
                    <div class="api-method">
                        <h5>List&lt;TEntity&gt; findByDateRange(LocalDateTime startDate, LocalDateTime endDate)</h5>
                        <p>Find entities by date range with automatic table selection</p>
                    </div>
                    
                    <div class="api-method">
                        <h5>long countByDateRange(LocalDateTime startDate, LocalDateTime endDate)</h5>
                        <p>Count entities in date range across all relevant tables</p>
                    </div>
                    
                    <div class="api-method">
                        <h5>TEntity findById(TKey id)</h5>
                        <p>Find entity by primary key (searches across all tables)</p>
                    </div>
                    
                    <div class="api-method">
                        <h5>List&lt;TEntity&gt; findAllById(String columnName, Object value)</h5>
                        <p>Find all entities by any column value (useful for non-unique columns)</p>
                    </div>

                    <h4>Advanced Querying</h4>
                    <div class="api-method">
                        <h5>&lt;R&gt; List&lt;R&gt; executePartitionedQuery(...)</h5>
                        <p>Execute custom partitioned query with 2-level aggregation</p>
                    </div>
                    
                    <div class="api-method">
                        <h5>List&lt;UserSmsStats&gt; getUserStats(...)</h5>
                        <p>Get user statistics (SMS-specific)</p>
                    </div>
                    
                    <div class="api-method">
                        <h5>List&lt;HourlyStats&gt; getHourlyStats(...)</h5>
                        <p>Get hourly statistics with success rates</p>
                    </div>
                </div>

                <div id="partitioned-api">
                    <h3>GenericPartitionedTableRepository&lt;TEntity, TKey&gt; API</h3>
                    <p><strong>TEntity</strong> - The entity type (OrderEntity, CustomerEntity, etc.)</p>
                    <p><strong>TKey</strong> - The primary key type (Long, String, UUID, etc.)</p>
                    
                    <h4>Builder Configuration</h4>
                    <div class="api-method">
                        <h5>GenericPartitionedTableRepository.&lt;TEntity, TKey&gt;builder(Class&lt;TEntity&gt;, Class&lt;TKey&gt;)</h5>
                        <p>Create builder with entity and key types for compile-time safety</p>
                    </div>
                    
                    <div class="api-method">
                        <h5>.maxPoolSize(int) / .idleTimeout(long) / .maxLifetime(long)</h5>
                        <p>Configure HikariCP connection pool settings for high-volume processing</p>
                    </div>
                    
                    <h4>Core Operations</h4>
                    <div class="api-method">
                        <h5>void insert(TEntity entity)</h5>
                        <p>Insert entity with automatic SQL generation (auto-creates partitions)</p>
                    </div>
                    
                    <div class="api-method">
                        <h5>List&lt;TEntity&gt; findByDateRange(LocalDateTime startDate, LocalDateTime endDate)</h5>
                        <p>Find entities by date range with MySQL partition pruning</p>
                    </div>
                    
                    <div class="api-method">
                        <h5>long countByDateRange(LocalDateTime startDate, LocalDateTime endDate)</h5>
                        <p>Count entities in date range with partition optimization</p>
                    </div>
                    
                    <div class="api-method">
                        <h5>TEntity findById(TKey id)</h5>
                        <p>Find entity by primary key (MySQL native partition scanning)</p>
                    </div>
                    
                    <div class="api-method">
                        <h5>List&lt;TEntity&gt; findAllById(String columnName, Object value)</h5>
                        <p>Find all entities by any column value with partition efficiency</p>
                    </div>

                    <h4>Advanced Querying</h4>
                    <div class="api-method">
                        <h5>&lt;R&gt; List&lt;R&gt; executeQuery(...)</h5>
                        <p>Execute custom query with QueryDSL</p>
                    </div>
                    
                    <div class="api-method">
                        <h5>List&lt;CustomerOrderStats&gt; getCustomerStats(...)</h5>
                        <p>Get customer order statistics (Order-specific)</p>
                    </div>
                    
                    <div class="api-method">
                        <h5>List&lt;DailyOrderStats&gt; getDailyStats(...)</h5>
                        <p>Get daily statistics with fulfillment rates</p>
                    </div>
                </div>
            </section>

            <section id="findbyid-examples" class="section">
                <h2>findById API Examples</h2>

                <div id="basic-id-lookups">
                    <h3>Basic ID Lookups</h3>
                    <pre><code>// Multi-Table Repository (SMS)
MultiTableRepository&lt;Long&gt; smsRepo = MultiTableRepository.&lt;Long&gt;builder()
    .tablePrefix("sms")
    .build();

// Find SMS by primary key ID (searches across all sms_* tables)
SmsEntity sms = smsRepo.findById(12345L);
if (sms != null) {
    System.out.println("Found SMS: " + sms.getMessage());
}

// Partitioned Table Repository (Orders)  
PartitionedTableRepository&lt;Long&gt; orderRepo = PartitionedTableRepository.&lt;Long&gt;builder()
    .tableName("orders")
    .build();

// Find order by primary key ID (MySQL scans all partitions)
OrderEntity order = orderRepo.findById(67890L);
if (order != null) {
    System.out.println("Found Order: " + order.getOrderNumber());
}</code></pre>
                </div>

                <div id="custom-column-searches">
                    <h3>Custom Column Searches</h3>
                    <pre><code>// Find by user ID across all SMS tables
List&lt;SmsEntity&gt; userSms = smsRepo.findAllById("user_id", "user123");

// Find by order number across all partitions
List&lt;OrderEntity&gt; orderByNumber = orderRepo.findAllById("order_number", "ORD-2025-001");

// Find by phone number
List&lt;SmsEntity&gt; smsByPhone = smsRepo.findAllById("phone_number", "+1234567890");

// Find by customer ID
List&lt;OrderEntity&gt; customerOrder = orderRepo.findAllById("customer_id", "CUST001");</code></pre>
                </div>

                <div id="multiple-results">
                    <h3>Multiple Results</h3>
                    <pre><code>// Find ALL SMS messages for a specific user (across all tables)
List&lt;SmsEntity&gt; allUserSms = smsRepo.findAllById("user_id", "user123");
System.out.println("User has " + allUserSms.size() + " SMS messages");

// Find ALL orders for a specific customer (across all partitions)
List&lt;OrderEntity&gt; allCustomerOrders = orderRepo.findAllById("customer_id", "CUST001");
System.out.println("Customer has " + allCustomerOrders.size() + " orders");

// Find all SMS messages with specific status
List&lt;SmsEntity&gt; failedSms = smsRepo.findAllById("status", "FAILED");

// Find all orders with specific payment method
List&lt;OrderEntity&gt; creditCardOrders = orderRepo.findAllById("payment_method", "CREDIT_CARD");</code></pre>
                </div>

                <div id="performance-considerations">
                    <h3>Performance Considerations</h3>
                    <div class="warning">
                        <h4>Performance Warning</h4>
                        <p>ID lookups perform full table scans across all tables/partitions and can be slow for large datasets.</p>
                    </div>

                    <table class="performance-table">
                        <thead>
                            <tr>
                                <th>Operation</th>
                                <th>Performance</th>
                                <th>Use Case</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>findById(12345L)</code></td>
                                <td>SLOW</td>
                                <td>Full table scan across all tables/partitions</td>
                            </tr>
                            <tr>
                                <td><code>findByDateRange(...)</code></td>
                                <td>FAST</td>
                                <td>Date-range query with automatic table/partition selection</td>
                            </tr>
                            <tr>
                                <td>Hybrid approach</td>
                                <td>OPTIMAL</td>
                                <td>If you know approximate date, combine both approaches</td>
                            </tr>
                        </tbody>
                    </table>

                    <div class="tip">
                        <h4>Hybrid Approach Example</h4>
                        <pre><code>// If you know the approximate date, combine both approaches
LocalDateTime suspectedDate = LocalDateTime.of(2025, 8, 15, 10, 30);
List&lt;SmsEntity&gt; dateFilteredSms = smsRepo.findByDateRange(
    suspectedDate.minusHours(12),
    suspectedDate.plusHours(12)
);
// Then filter in memory if needed
SmsEntity targetSms = dateFilteredSms.stream()
    .filter(s -> s.getId().equals(12345L))
    .findFirst().orElse(null);</code></pre>
                    </div>
                </div>
            </section>

            <section id="query-dsl" class="section">
                <h2>Query DSL Examples</h2>
                <p>The library includes a <strong>type-safe Query DSL</strong> for building complex queries:</p>

                <div id="basic-query">
                    <h3>Basic Query</h3>
                    <pre><code>String query = QueryDSL.select()
    .column("user_id")
    .count("*", "message_count")
    .from("sms")
    .where(w -> w.dateRange("created_at", startDate, endDate))
    .groupBy("user_id")
    .orderByDesc("message_count")
    .limit(10)
    .build();</code></pre>
                </div>

                <div id="advanced-aggregation">
                    <h3>Advanced Aggregation</h3>
                    <pre><code>String query = QueryDSL.select()
    .column("DATE(created_at)", "day")
    .count("*", "total_orders")
    .sum("total_amount", "daily_revenue")
    .avg("total_amount", "avg_order_value")
    .aggregate(QueryDSL.AggregateFunction.COUNT, "customer_id", "unique_customers", true)
    .from("orders")
    .where(w -> w
        .dateRange("created_at", startDate, endDate)
        .and("status", QueryDSL.Operator.IN, "CONFIRMED", "SHIPPED", "DELIVERED"))
    .groupBy("DATE(created_at)")
    .orderByDesc("daily_revenue")
    .build();</code></pre>
                </div>

                <div id="complex-conditions">
                    <h3>Complex Conditions</h3>
                    <pre><code>String query = QueryDSL.select()
    .column("*")
    .from("sms")
    .where(w -> w
        .dateRange("created_at", startDate, endDate)
        .and("status", QueryDSL.Operator.EQUALS, "SENT")
        .and("cost", QueryDSL.Operator.GREATER_THAN, new BigDecimal("0.01"))
        .like("message", "%urgent%")
        .isNotNull("user_id"))
    .orderByDesc("created_at")
    .limit(100)
    .build();</code></pre>
                </div>
            </section>

            <section id="annotations" class="section">
                <h2>Entity Annotations</h2>
                <p>Simple annotations for automatic SQL generation and entity mapping:</p>
                
                <div class="feature-grid">
                    <div class="feature-item">
                        <h4>@Table</h4>
                        <pre><code>@Table(name = "orders")
public class OrderEntity { ... }</code></pre>
                        <p>Specifies the table name. If omitted, uses lowercase class name without "Entity" suffix.</p>
                    </div>
                    
                    <div class="feature-item">
                        <h4>@Id</h4>
                        <pre><code>@Id
@Column(name = "id", insertable = false)
private Long id;</code></pre>
                        <p>Marks the primary key field. Supports auto-generation with <code>autoGenerated = true</code> (default).</p>
                    </div>
                    
                    <div class="feature-item">
                        <h4>@ShardingKey</h4>
                        <pre><code>@ShardingKey
@Column(name = "created_at", nullable = false)
private LocalDateTime createdAt;</code></pre>
                        <p>Marks the field used for date-based partitioning/sharding (usually a DateTime field).</p>
                    </div>
                    
                    <div class="feature-item">
                        <h4>@Column</h4>
                        <pre><code>@Column(name = "user_id", nullable = false)
private String userId;

@Column(name = "message")
private String message;</code></pre>
                        <p>Maps field to database column. Supports <code>nullable</code>, <code>insertable</code>, <code>updatable</code> options.</p>
                    </div>
                </div>
                
                <div class="highlight">
                    <h4>Automatic SQL Generation</h4>
                    <p>From these annotations, the framework automatically generates:</p>
                    <ul>
                        <li><strong>INSERT statements:</strong> <code>INSERT INTO table (col1, col2) VALUES (?, ?)</code></li>
                        <li><strong>SELECT statements:</strong> <code>SELECT col1, col2 FROM table WHERE id = ?</code></li>
                        <li><strong>CREATE TABLE statements:</strong> With proper column types, constraints, and indexes</li>
                        <li><strong>Parameter binding:</strong> Type-safe parameter setting based on field types</li>
                        <li><strong>Result mapping:</strong> Automatic ResultSet to entity conversion</li>
                    </ul>
                </div>
            </section>

            <section id="data-models" class="section">
                <h2>Data Models</h2>

                <div id="sms-entity">
                    <h3>SmsEntity (Multi-Table Strategy)</h3>
                    <pre><code>public class SmsEntity {
    private Long id;
    private String userId;
    private String phoneNumber;
    private String message;
    private String status;        // PENDING, SENT, DELIVERED, FAILED
    private LocalDateTime createdAt;
    private LocalDateTime deliveredAt;
    private BigDecimal cost;
    private String provider;      // twilio, aws-sns, etc.
    
    // Constructors, getters, setters...
}</code></pre>
                </div>

                <div id="order-entity">
                    <h3>OrderEntity (Partitioned Table Strategy)</h3>
                    <pre><code>public class OrderEntity {
    private Long id;
    private String customerId;
    private String orderNumber;
    private BigDecimal totalAmount;
    private String status;        // PENDING, CONFIRMED, SHIPPED, DELIVERED, CANCELLED
    private String paymentMethod; // CREDIT_CARD, PAYPAL, BANK_TRANSFER, etc.
    private String shippingAddress;
    private LocalDateTime createdAt;
    private LocalDateTime shippedAt;
    private LocalDateTime deliveredAt;
    private Integer itemCount;
    
    // Constructors, getters, setters...
}</code></pre>
                </div>

                <div id="statistics-classes">
                    <h3>Statistics Classes</h3>
                    
                    <h4>UserSmsStats (Multi-Table)</h4>
                    <pre><code>public class UserSmsStats {
    public final String userId;
    public final long messageCount;
    public final LocalDateTime firstMessage;
    public final LocalDateTime lastMessage;
    public final long totalChars;
    public final double avgMessageLength;
    public final BigDecimal totalCost;
}</code></pre>

                    <h4>CustomerOrderStats (Partitioned Table)</h4>
                    <pre><code>public class CustomerOrderStats {
    public final String customerId;
    public final long orderCount;
    public final BigDecimal totalSpent;
    public final BigDecimal avgOrderValue;
    public final long totalItems;
    public final LocalDateTime firstOrder;
    public final LocalDateTime lastOrder;
}</code></pre>
                </div>
            </section>

            <section id="configuration" class="section">
                <h2>Configuration Options</h2>
                
                <h3>Generic Builder Configuration with HikariCP</h3>
                <pre><code>// Multi-Table Repository with HikariCP
GenericMultiTableRepository&lt;SmsEntity, Long&gt; smsRepo = 
    GenericMultiTableRepository.&lt;SmsEntity, Long&gt;builder(SmsEntity.class, Long.class)
        .host("localhost")              // Database host
        .port(3306)                     // Database port  
        .database("messaging")          // Database name
        .username("dbuser")             // Database username
        .password("dbpass")             // Database password
        .tablePrefix("sms")             // Table prefix (sms_20250804)
        .partitionRetentionPeriod(30)   // Keep 30 days of data
        .autoManagePartitions(true)     // Auto create/drop tables
        .partitionAdjustmentTime(4, 0)  // Daily maintenance at 04:00
        // HikariCP Configuration
        .maxPoolSize(25)                // Maximum 25 connections
        .minIdleConnections(5)          // Minimum 5 idle connections
        .connectionTimeout(30000)       // 30 second connection timeout
        .idleTimeout(600000)            // 10 minute idle timeout
        .maxLifetime(1800000)           // 30 minute max connection lifetime
        .leakDetectionThreshold(60000)  // 1 minute leak detection
        .build();

// Partitioned Table Repository with HikariCP
GenericPartitionedTableRepository&lt;OrderEntity, Long&gt; orderRepo = 
    GenericPartitionedTableRepository.&lt;OrderEntity, Long&gt;builder(OrderEntity.class, Long.class)
        .host("localhost")              // Database host
        .port(3306)                     // Database port
        .database("ecommerce")          // Database name  
        .username("dbuser")             // Database username
        .password("dbpass")             // Database password
        .tableName("orders")            // Single table name
        .partitionRetentionPeriod(365)  // Keep 1 year of data
        .autoManagePartitions(true)     // Auto create/drop partitions
        .partitionAdjustmentTime(4, 0)  // Daily maintenance at 04:00
        // HikariCP Configuration for high-volume processing
        .maxPoolSize(30)                // Maximum 30 connections
        .minIdleConnections(10)         // Minimum 10 idle connections
        .idleTimeout(900000)            // 15 minute idle timeout
        .maxLifetime(3600000)           // 1 hour max connection lifetime
        .leakDetectionThreshold(120000) // 2 minute leak detection
        .build();</code></pre>
                    
                <h3>Scheduler Configuration Examples</h3>
                <pre><code>// Custom adjustment times
.partitionAdjustmentTime(2, 30)                    // 02:30 AM
.partitionAdjustmentTime(LocalTime.of(23, 45))     // 11:45 PM
.partitionAdjustmentTime(LocalTime.MIDNIGHT)       // 00:00 AM

// Disable auto-management (no scheduler)
.autoManagePartitions(false)

// Complete example with scheduler
MultiTableRepository&lt;Long&gt; repo = MultiTableRepository.&lt;Long&gt;builder()
    .database("myapp")
    .tablePrefix("events")
    .partitionRetentionPeriod(14)           // 14 days retention
    .autoManagePartitions(true)             // Enable scheduler
    .partitionAdjustmentTime(3, 0)          // Run at 03:00 AM
    .build();

// Graceful shutdown (recommended for production)
Runtime.getRuntime().addShutdownHook(new Thread(repo::shutdown));</code></pre>
            </section>

            <section id="automatic-management" class="section">
                <h2>Automatic Management</h2>

                <div class="feature-grid">
                    <div class="feature-item">
                        <h4>Multi-Table Strategy</h4>
                        <ul>
                            <li><strong>On Insert:</strong> Creates <code>table_YYYYMMDD</code> if it doesn't exist + immediate maintenance</li>
                            <li><strong>Daily Scheduler:</strong> Runs at <code>partitionAdjustmentTime</code> (default 04:00)</li>
                            <li><strong>Maintenance Range:</strong> <code>{today - retentionDays}</code> to <code>{today + retentionDays}</code></li>
                            <li><strong>Table Naming:</strong> <code>{tablePrefix}_{YYYYMMDD}</code> (e.g., <code>sms_20250804</code>)</li>
                        </ul>
                    </div>

                    <div class="feature-item">
                        <h4>Partitioned Table Strategy</h4>
                        <ul>
                            <li><strong>On Insert:</strong> Creates partition <code>pYYYYMMDD</code> if it doesn't exist + immediate maintenance</li>
                            <li><strong>Daily Scheduler:</strong> Runs at <code>partitionAdjustmentTime</code> (default 04:00)</li>
                            <li><strong>Maintenance Range:</strong> <code>{today - retentionDays}</code> to <code>{today + retentionDays}</code></li>
                            <li><strong>Partition Naming:</strong> <code>p{YYYYMMDD}</code> (e.g., <code>p20250804</code>)</li>
                        </ul>
                    </div>
                </div>
                
                <div class="highlight">
                    <h4>🕐 New: Automatic Daily Scheduler</h4>
                    <p>Both repositories now include a production-ready background scheduler that runs daily at the configured <code>partitionAdjustmentTime</code>. The scheduler:</p>
                    <ul>
                        <li><strong>Smart Scheduling:</strong> Calculates optimal next run time, handles time zone changes</li>
                        <li><strong>Retention Management:</strong> Maintains symmetric range <code>{today-N}</code> to <code>{today+N}</code> days</li>
                        <li><strong>Independent Operation:</strong> Runs regardless of application activity</li>
                        <li><strong>Error Resilience:</strong> Continues operation even if individual maintenance tasks fail</li>
                        <li><strong>Resource Management:</strong> Proper thread lifecycle with graceful shutdown</li>
                        <li><strong>Observability:</strong> Comprehensive logging with operation status and timings</li>
                    </ul>
                </div>
                
                <div class="tip">
                    <h4>Scheduler Best Practices</h4>
                    <ul>
                        <li><strong>Timing:</strong> Schedule during low-traffic periods (default 04:00 AM)</li>
                        <li><strong>Retention:</strong> Set appropriate retention periods based on storage and compliance needs</li>
                        <li><strong>Monitoring:</strong> Monitor scheduler logs for maintenance success/failure</li>
                        <li><strong>Shutdown:</strong> Always call <code>repository.shutdown()</code> during application termination</li>
                        <li><strong>Testing:</strong> Test scheduler behavior in staging environments before production</li>
                    </ul>
                </div>
                
                <h3>Live Scheduler Demo</h3>
                <p>Run the <code>AutoManagementSchedulerDemo.java</code> example to see the scheduler in action:</p>
                <pre><code>// Demonstrates scheduler configuration and behavior
public class AutoManagementSchedulerDemo {
    public static void main(String[] args) {
        // Creates repositories with different scheduler settings
        // Shows scheduler startup, maintenance operations, and shutdown
        // Includes detailed logging of all scheduler activities
    }
}</code></pre>
                
                <p>The demo shows:</p>
                <ul>
                    <li>Scheduler initialization and next run time calculation</li>
                    <li>Maintenance operations with detailed logging</li>
                    <li>Retention range calculations and table/partition management</li>
                    <li>Graceful shutdown and resource cleanup</li>
                </ul>
            </section>

            <section id="use-cases" class="section">
                <h2>Use Cases</h2>

                <div class="feature-grid">
                    <div class="feature-item">
                        <h4>SMS/Messaging Platforms</h4>
                        <pre><code>// High-volume SMS tracking with automatic table rotation
MultiTableRepository&lt;Long&gt; smsRepo = MultiTableRepository.&lt;Long&gt;builder()
    .tablePrefix("sms")
    .partitionRetentionPeriod(90)  // 3 months retention
    .build();

// Track delivery rates by provider
List&lt;HourlyStats&gt; deliveryStats = smsRepo.getHourlyStats(startDate, endDate);</code></pre>
                    </div>

                    <div class="feature-item">
                        <h4>E-commerce Platforms</h4>
                        <pre><code>// Order management with long-term retention  
PartitionedTableRepository&lt;Long&gt; orderRepo = PartitionedTableRepository.&lt;Long&gt;builder()
    .tableName("orders")
    .partitionRetentionPeriod(2555) // 7 years retention (compliance)
    .build();

// Analyze customer behavior
List&lt;CustomerOrderStats&gt; topCustomers = orderRepo.getCustomerStats(startDate, endDate, 50);</code></pre>
                    </div>

                    <div class="feature-item">
                        <h4>Call Center Systems</h4>
                        <pre><code>// Call logs with automatic cleanup
MultiTableRepository&lt;Long&gt; callRepo = MultiTableRepository.&lt;Long&gt;builder()
    .tablePrefix("calls")
    .partitionRetentionPeriod(180) // 6 months retention
    .build();</code></pre>
                    </div>

                    <div class="feature-item">
                        <h4>Analytics & Reporting</h4>
                        <pre><code>// Event tracking for analytics
MultiTableRepository&lt;Long&gt; eventRepo = MultiTableRepository.&lt;Long&gt;builder()
    .tablePrefix("events")
    .partitionRetentionPeriod(30)  // 1 month retention
    .build();</code></pre>
                    </div>
                </div>
            </section>

            <section id="advanced-features" class="section">
                <h2>Advanced Features</h2>

                <h3>2-Level Query Aggregation (Multi-Table)</h3>
                <div class="highlight">
                    <p>Automatically generated UNION ALL query with proper aggregation:</p>
                </div>
                <pre><code>-- Automatically generated UNION ALL query with proper aggregation
SELECT user_id, SUM(message_count) AS message_count, SUM(total_cost) AS total_cost
FROM (
  SELECT user_id, COUNT(*) AS message_count, SUM(cost) AS total_cost
  FROM sms_20250801 WHERE created_at >= '2025-08-01 00:00:00' AND created_at <= '2025-08-01 23:59:59'
  GROUP BY user_id
  
  UNION ALL
  
  SELECT user_id, COUNT(*) AS message_count, SUM(cost) AS total_cost  
  FROM sms_20250802 WHERE created_at >= '2025-08-02 00:00:00' AND created_at <= '2025-08-02 23:59:59'
  GROUP BY user_id
) unioned
GROUP BY user_id
ORDER BY message_count DESC;</code></pre>

                <h3>Intelligent Aggregation Mapping</h3>
                <ul>
                    <li><strong>COUNT</strong> → <strong>SUM</strong> (across partitions)</li>
                    <li><strong>SUM</strong> → <strong>SUM</strong> (across partitions)</li>
                    <li><strong>MAX</strong> → <strong>MAX</strong> (across partitions)</li>
                    <li><strong>MIN</strong> → <strong>MIN</strong> (across partitions)</li>
                    <li><strong>AVG</strong> → <strong>AVG</strong> (across partitions)</li>
                </ul>

                <h3>Automatic Table Existence Filtering</h3>
                <ul>
                    <li>Only includes existing tables in UNION queries</li>
                    <li>Prevents errors when querying date ranges with missing tables</li>
                    <li>Returns empty results gracefully for non-existent date ranges</li>
                </ul>
            </section>

            <section id="production-features" class="section">
                <h2>Production Features</h2>

                <div class="feature-grid">
                    <div class="feature-item">
                        <h4>SQL Injection Protection</h4>
                        <ul>
                            <li>All datetime values properly quoted and formatted</li>
                            <li>Type-safe parameter binding where applicable</li>
                            <li>Input validation and sanitization</li>
                        </ul>
                    </div>

                    <div class="feature-item">
                        <h4>Error Handling</h4>
                        <ul>
                            <li>Graceful handling of missing tables/partitions</li>
                            <li>Connection timeout management (60 seconds default)</li>
                            <li>Scheduler error recovery and logging</li>
                        </ul>
                    </div>

                    <div class="feature-item">
                        <h4>Performance Optimizations</h4>
                        <ul>
                            <li>Partition pruning for optimal query performance</li>
                            <li>Index optimization on time-based columns</li>
                            <li>Efficient UNION ALL query generation</li>
                            <li>Background maintenance without blocking operations</li>
                        </ul>
                    </div>

                    <div class="feature-item">
                        <h4>Monitoring & Observability</h4>
                        <ul>
                            <li>Built-in logging for table/partition operations</li>
                            <li>Scheduler status and maintenance tracking</li>
                            <li>Detailed retention range calculations</li>
                            <li>Error reporting and recovery metrics</li>
                        </ul>
                    </div>
                    
                    <div class="feature-item">
                        <h4>Automatic Lifecycle Management</h4>
                        <ul>
                            <li>Daily scheduled maintenance at configurable time</li>
                            <li>Graceful scheduler startup and shutdown</li>
                            <li>Thread-safe background operations</li>
                            <li>Resource cleanup on application termination</li>
                        </ul>
                    </div>
                    
                    <div class="feature-item">
                        <h4>Enterprise Ready</h4>
                        <ul>
                            <li>Zero external dependencies</li>
                            <li>Generic type safety for ID columns</li>
                            <li>Production-tested with millions of records</li>
                            <li>Framework-independent (works with Spring, Quarkus, plain Java)</li>
                        </ul>
                    </div>
                </div>
            </section>

            <section id="requirements" class="section">
                <h2>Requirements</h2>
                <ul>
                    <li><strong>Java:</strong> 8+ (tested with Java 11, 17, 21)</li>
                    <li><strong>Database:</strong> MySQL 5.7+ / MariaDB 10.3+</li>
                    <li><strong>Connection Pooling:</strong> HikariCP 5.0.1+ (included)</li>
                    <li><strong>JDBC Driver:</strong> MySQL Connector/J 8.0+ (included)</li>
                    <li><strong>Framework Independence:</strong> Works with Spring Boot, Quarkus, or plain Java</li>
                </ul>
                
                <div class="highlight">
                    <h4>HikariCP Integration</h4>
                    <p>All database operations are strictly HikariCP-based for optimal performance:</p>
                    <ul>
                        <li><strong>High Performance:</strong> Fastest JDBC connection pool available</li>
                        <li><strong>Production Ready:</strong> Battle-tested in high-load environments</li>
                        <li><strong>Connection Management:</strong> Automatic lifecycle and leak detection</li>
                        <li><strong>Monitoring:</strong> JMX metrics and named pools for observability</li>
                        <li><strong>MySQL Optimized:</strong> Prepared statement caching, batch rewriting</li>
                    </ul>
                </div>
            </section>

            <section id="getting-started" class="section">
                <h2>Getting Started</h2>
                
                <h3>Quick Setup (5 Minutes)</h3>
                <ol>
                    <li><strong>Annotate your entities</strong> with @Table, @Id, @ShardingKey, @Column</li>
                    <li><strong>Choose your strategy</strong> (Multi-Table vs Partitioned Table)</li>
                    <li><strong>Create generic repository</strong> with entity and key types</li>
                    <li><strong>Configure HikariCP pool</strong> for your workload</li>
                    <li><strong>Configure scheduler</strong> (optional, enabled by default)</li>
                    <li><strong>Start inserting and querying</strong> - SQL generated automatically!</li>
                </ol>
                
                <h3>Complete Production Example</h3>
                <pre><code>// 1. Annotated Entity
@Table(name = "sms")
public class SmsEntity {
    @Id
    @Column(name = "id", insertable = false)
    private Long id;
    
    @Column(name = "user_id")
    private String userId;
    
    @ShardingKey
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;
    
    @Column(name = "message")
    private String message;
    // ... other fields with getters/setters
}

// 2. Production-ready repository with HikariCP
@Configuration
public class DataServiceConfig {
    
    @Bean
    public GenericMultiTableRepository&lt;SmsEntity, Long&gt; smsRepository() {
        return GenericMultiTableRepository.&lt;SmsEntity, Long&gt;builder(SmsEntity.class, Long.class)
            .host("production-db")
            .port(3306)
            .database("messaging")
            .username("app_user")
            .password(System.getenv("DB_PASSWORD"))
            .partitionRetentionPeriod(30)        // 30 days retention
            .autoManagePartitions(true)          // Enable scheduler
            .partitionAdjustmentTime(3, 0)       // 03:00 AM maintenance
            // Production HikariCP settings
            .maxPoolSize(50)                     // High-load configuration
            .minIdleConnections(10)              // Keep connections ready
            .connectionTimeout(20000)            // 20s timeout
            .idleTimeout(300000)                 // 5 min idle timeout
            .maxLifetime(1200000)                // 20 min max lifetime
            .leakDetectionThreshold(0)           // Disable in production
            .build();
    }
    
    @PreDestroy
    public void cleanup() {
        smsRepository().shutdown();  // Graceful HikariCP shutdown
    }
}</code></pre>

                <div class="highlight">
                    <h4>Production Ready with Modern Features</h4>
                    <p><em>This framework combines battle-tested partitioning strategies with modern Java features:</em></p>
                    <ul>
                        <li><strong>Generic Type Safety:</strong> Full compile-time guarantees with <code>Repository&lt;TEntity, TKey&gt;</code></li>
                        <li><strong>Zero Runtime Reflection:</strong> All metadata parsed once at startup for maximum performance</li>
                        <li><strong>HikariCP Integration:</strong> Enterprise-grade connection pooling with full configuration control</li>
                        <li><strong>Automatic SQL Generation:</strong> No more hardcoded SQL - everything inferred from annotations</li>
                        <li><strong>Scheduler Automation:</strong> Enterprise-grade automatic maintenance and lifecycle management</li>
                    </ul>
                    
                    <p><strong>Perfect for:</strong> High-frequency data ingestion, time-series analytics, audit logging, messaging platforms, IoT data collection, microservices, and any application requiring type-safe, high-performance data access with automatic lifecycle management.</p>
                </div>
            </section>
        </main>
    </div>

    <button class="scroll-top" onclick="scrollToTop()">↑</button>

    <script>
        // Smooth scrolling for navigation links
        document.querySelectorAll('.sidebar a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // Scroll to top functionality
        function scrollToTop() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }

        // Show/hide scroll to top button
        window.addEventListener('scroll', function() {
            const scrollTop = document.querySelector('.scroll-top');
            if (window.pageYOffset > 300) {
                scrollTop.style.display = 'block';
            } else {
                scrollTop.style.display = 'none';
            }
        });

        // Mobile menu toggle
        if (window.innerWidth <= 1024) {
            const container = document.querySelector('.container');
            if (container) {
                container.addEventListener('click', function(e) {
                    if (e.target.textContent === '☰ Menu') {
                        const sidebar = document.querySelector('.sidebar');
                        if (sidebar) {
                            sidebar.classList.toggle('active');
                        }
                    }
                });
            }
        }

        // Active section highlighting
        window.addEventListener('scroll', function() {
            const sections = document.querySelectorAll('.section');
            const navLinks = document.querySelectorAll('.sidebar a');
            
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                const sectionHeight = section.clientHeight;
                if (window.pageYOffset >= sectionTop - 200) {
                    current = section.getAttribute('id');
                }
            });

            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });
        });
    </script>

    <style>
        .sidebar a.active {
            background: #3498db;
            color: white;
            transform: translateX(5px);
        }
        
        .scroll-top {
            display: none;
        }
    </style>
</body>
</html>