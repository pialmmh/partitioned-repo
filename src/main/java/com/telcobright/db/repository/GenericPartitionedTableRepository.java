package com.telcobright.db.repository;

import com.telcobright.db.metadata.EntityMetadata;
import com.telcobright.db.query.QueryDSL;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;

import javax.sql.DataSource;
import java.sql.*;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.logging.Logger;

/**
 * Generic Partitioned Table Repository implementation
 * Uses MySQL native partitioning on a single table
 * 
 * @param <T> Entity type
 * @param <K> Primary key type
 */
public class GenericPartitionedTableRepository<T, K> {
    private static final Logger LOGGER = Logger.getLogger(GenericPartitionedTableRepository.class.getName());
    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern("yyyyMMdd");
    
    private final HikariDataSource dataSource;
    private final String database;
    private final String tableName;
    private final int partitionRetentionPeriod;
    private final boolean autoManagePartitions;
    private final LocalTime partitionAdjustmentTime;
    private final boolean initializePartitionsOnStart;
    private final EntityMetadata<T, K> metadata;
    private final Class<T> entityClass;
    private final Class<K> keyClass;
    
    private ScheduledExecutorService scheduler;
    
    private GenericPartitionedTableRepository(Builder<T, K> builder) {
        this.database = builder.database;
        this.partitionRetentionPeriod = builder.partitionRetentionPeriod;
        this.autoManagePartitions = builder.autoManagePartitions;
        this.partitionAdjustmentTime = builder.partitionAdjustmentTime;
        this.initializePartitionsOnStart = builder.initializePartitionsOnStart;
        this.entityClass = builder.entityClass;
        this.keyClass = builder.keyClass;
        
        // Initialize entity metadata (performs reflection once)
        this.metadata = new EntityMetadata<>(entityClass, keyClass);
        
        // Use provided table name or derive from entity
        this.tableName = builder.tableName != null ? builder.tableName : metadata.getTableName();
        
        // Create DataSource
        this.dataSource = createDataSource(builder);
        
        // Initialize table and partitions if needed
        if (initializePartitionsOnStart) {
            try {
                initializeTable();
                initializePartitions();
            } catch (SQLException e) {
                throw new RuntimeException("Failed to initialize partitioned table", e);
            }
        }
        
        // Start scheduler if auto-management is enabled
        if (autoManagePartitions) {
            startScheduler();
        }
    }
    
    /**
     * Insert entity into partitioned table (MySQL handles routing)
     */
    public void insert(T entity) throws SQLException {
        LocalDateTime shardingKeyValue = metadata.getShardingKeyValue(entity);
        
        // Ensure partition exists for the date
        ensurePartitionExistsForDate(shardingKeyValue);
        
        String fullTableName = database + "." + tableName;
        String sql = String.format(metadata.getInsertSQL(), fullTableName);
        
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            
            metadata.setInsertParameters(stmt, entity);
            stmt.executeUpdate();
            
            // Set generated ID if applicable
            if (metadata.getIdField() != null && metadata.getIdField().isAutoGenerated()) {
                try (ResultSet keys = stmt.getGeneratedKeys()) {
                    if (keys.next()) {
                        @SuppressWarnings("unchecked")
                        K id = (K) Long.valueOf(keys.getLong(1));
                        metadata.setId(entity, id);
                    }
                }
            }
        }
    }
    
    /**
     * Insert multiple entities
     */
    public void insertMultiple(List<T> entities) throws SQLException {
        if (entities == null || entities.isEmpty()) {
            return;
        }
        
        // Ensure partitions exist for all dates
        Set<LocalDateTime> dates = new HashSet<>();
        for (T entity : entities) {
            LocalDateTime shardingKeyValue = metadata.getShardingKeyValue(entity);
            dates.add(shardingKeyValue);
        }
        
        for (LocalDateTime date : dates) {
            ensurePartitionExistsForDate(date);
        }
        
        String fullTableName = database + "." + tableName;
        String sql = String.format(metadata.getInsertSQL(), fullTableName);
        
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            
            for (T entity : entities) {
                metadata.setInsertParameters(stmt, entity);
                stmt.addBatch();
            }
            
            stmt.executeBatch();
            
            // Set generated IDs if applicable
            if (metadata.getIdField() != null && metadata.getIdField().isAutoGenerated()) {
                try (ResultSet keys = stmt.getGeneratedKeys()) {
                    for (T entity : entities) {
                        if (keys.next()) {
                            @SuppressWarnings("unchecked")
                            K id = (K) Long.valueOf(keys.getLong(1));
                            metadata.setId(entity, id);
                        }
                    }
                }
            }
        }
    }
    
    /**
     * Find entities by date range (with partition pruning)
     */
    public List<T> findByDateRange(LocalDateTime startDate, LocalDateTime endDate) throws SQLException {
        String shardingColumn = metadata.getShardingKeyField().getColumnName();
        String fullTableName = database + "." + tableName;
        
        String sql = String.format("SELECT * FROM %s WHERE %s BETWEEN ? AND ?", 
            fullTableName, shardingColumn);
        
        List<T> results = new ArrayList<>();
        
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setTimestamp(1, Timestamp.valueOf(startDate));
            stmt.setTimestamp(2, Timestamp.valueOf(endDate));
            
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    results.add(metadata.mapResultSet(rs));
                }
            }
        }
        
        return results;
    }
    
    /**
     * Find entity by ID (MySQL scans all partitions)
     */
    public T findById(K id) throws SQLException {
        String fullTableName = database + "." + tableName;
        String sql = String.format(metadata.getSelectByIdSQL(), fullTableName);
        
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            setIdParameter(stmt, 1, id);
            
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return metadata.mapResultSet(rs);
                }
            }
        }
        
        return null;
    }
    
    /**
     * Find entity by ID within a date range
     */
    public T findByIdAndDateRange(LocalDateTime startDate, LocalDateTime endDate) throws SQLException {
        // Returns the first entity found in the date range
        List<T> entities = findByDateRange(startDate, endDate);
        return entities.isEmpty() ? null : entities.get(0);
    }
    
    /**
     * Find entities before a specific date
     */
    public List<T> findBeforeDate(LocalDateTime beforeDate) throws SQLException {
        String shardingColumn = metadata.getShardingKeyField().getColumnName();
        String fullTableName = database + "." + tableName;
        
        String sql = String.format("SELECT * FROM %s WHERE %s < ?", fullTableName, shardingColumn);
        
        List<T> results = new ArrayList<>();
        
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setTimestamp(1, Timestamp.valueOf(beforeDate));
            
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    results.add(metadata.mapResultSet(rs));
                }
            }
        }
        
        return results;
    }
    
    private void initializeTable() throws SQLException {
        String fullTableName = database + "." + tableName;
        String createSQL = String.format(metadata.getCreateTableSQL(), fullTableName);
        
        // Modify the create table SQL to add partitioning
        String shardingColumn = metadata.getShardingKeyField().getColumnName();
        createSQL = createSQL.replace(") ENGINE=InnoDB", 
            ") ENGINE=InnoDB\nPARTITION BY RANGE (TO_DAYS(" + shardingColumn + "))");
        
        try (Connection conn = dataSource.getConnection();
             Statement stmt = conn.createStatement()) {
            
            // Check if table exists
            DatabaseMetaData metaData = conn.getMetaData();
            try (ResultSet rs = metaData.getTables(database, null, tableName, null)) {
                if (!rs.next()) {
                    // Table doesn't exist, create it with initial partition
                    LocalDateTime now = LocalDateTime.now();
                    String partitionName = "p" + now.format(DATE_FORMAT);
                    int partitionValue = (int) (now.toLocalDate().toEpochDay() + 719528); // MySQL epoch offset
                    
                    createSQL += " (\n  PARTITION " + partitionName + 
                                " VALUES LESS THAN (" + (partitionValue + 1) + ")\n)";
                    
                    stmt.execute(createSQL);
                    LOGGER.info("Created partitioned table: " + fullTableName);
                }
            }
        }
    }
    
    private void ensurePartitionExistsForDate(LocalDateTime date) throws SQLException {
        String partitionName = "p" + date.format(DATE_FORMAT);
        
        if (!partitionExists(partitionName)) {
            createPartition(partitionName, date);
        }
        
        if (autoManagePartitions) {
            performAutomaticMaintenance(date);
        }
    }
    
    private boolean partitionExists(String partitionName) throws SQLException {
        String sql = "SELECT partition_name FROM information_schema.partitions " +
                    "WHERE table_schema = ? AND table_name = ? AND partition_name = ?";
        
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setString(1, database);
            stmt.setString(2, tableName);
            stmt.setString(3, partitionName);
            
            try (ResultSet rs = stmt.executeQuery()) {
                return rs.next();
            }
        }
    }
    
    private void createPartition(String partitionName, LocalDateTime date) throws SQLException {
        int partitionValue = (int) (date.toLocalDate().toEpochDay() + 719528 + 1); // MySQL epoch offset
        
        String sql = String.format("ALTER TABLE %s.%s ADD PARTITION (PARTITION %s VALUES LESS THAN (%d))",
            database, tableName, partitionName, partitionValue);
        
        try (Connection conn = dataSource.getConnection();
             Statement stmt = conn.createStatement()) {
            stmt.execute(sql);
            LOGGER.info("Created partition: " + partitionName);
        }
    }
    
    private void dropPartition(String partitionName) throws SQLException {
        String sql = String.format("ALTER TABLE %s.%s DROP PARTITION %s",
            database, tableName, partitionName);
        
        try (Connection conn = dataSource.getConnection();
             Statement stmt = conn.createStatement()) {
            stmt.execute(sql);
            LOGGER.info("Dropped partition: " + partitionName);
        }
    }
    
    private List<String> getPartitions() throws SQLException {
        String sql = "SELECT partition_name FROM information_schema.partitions " +
                    "WHERE table_schema = ? AND table_name = ? AND partition_name IS NOT NULL " +
                    "ORDER BY partition_ordinal_position";
        
        List<String> partitions = new ArrayList<>();
        
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            stmt.setString(1, database);
            stmt.setString(2, tableName);
            
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    partitions.add(rs.getString("partition_name"));
                }
            }
        }
        
        return partitions;
    }
    
    private void setIdParameter(PreparedStatement stmt, int index, K id) throws SQLException {
        if (keyClass == Long.class) {
            stmt.setLong(index, (Long) id);
        } else if (keyClass == String.class) {
            stmt.setString(index, (String) id);
        } else if (keyClass == Integer.class) {
            stmt.setInt(index, (Integer) id);
        } else {
            stmt.setObject(index, id);
        }
    }
    
    private <R> List<R> executeQuery(String sql, Map<String, Object> parameters, 
                                    ResultSetMapper<R> mapper) throws SQLException {
        List<R> results = new ArrayList<>();
        
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            if (parameters != null) {
                int index = 1;
                for (Object value : parameters.values()) {
                    stmt.setObject(index++, value);
                }
            }
            
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    results.add(mapper.map(rs));
                }
            }
        }
        
        return results;
    }
    
    private void performAutomaticMaintenance(LocalDateTime referenceDate) throws SQLException {
        LocalDateTime startDate = referenceDate.minusDays(partitionRetentionPeriod);
        LocalDateTime endDate = referenceDate.plusDays(partitionRetentionPeriod);
        
        createPartitionsForDateRange(startDate, endDate);
        
        LocalDateTime cutoffDate = referenceDate.minusDays(partitionRetentionPeriod);
        dropOldPartitions(cutoffDate);
    }
    
    public void createPartitionsForDateRange(LocalDateTime startDate, LocalDateTime endDate) throws SQLException {
        LocalDateTime current = startDate;
        while (!current.isAfter(endDate)) {
            String partitionName = "p" + current.format(DATE_FORMAT);
            if (!partitionExists(partitionName)) {
                createPartition(partitionName, current);
            }
            current = current.plusDays(1);
        }
    }
    
    public void dropOldPartitions(LocalDateTime cutoffDate) throws SQLException {
        if (!autoManagePartitions) {
            return;
        }
        
        String cutoffDateStr = cutoffDate.format(DATE_FORMAT);
        List<String> partitions = getPartitions();
        
        for (String partitionName : partitions) {
            if (partitionName.startsWith("p") && partitionName.length() > 1) {
                String dateStr = partitionName.substring(1);
                if (dateStr.compareTo(cutoffDateStr) < 0) {
                    dropPartition(partitionName);
                }
            }
        }
    }
    
    private void initializePartitions() throws SQLException {
        LocalDateTime now = LocalDateTime.now();
        LocalDateTime startDate = now.minusDays(partitionRetentionPeriod);
        LocalDateTime endDate = now.plusDays(partitionRetentionPeriod);
        
        createPartitionsForDateRange(startDate, endDate);
    }
    
    private void startScheduler() {
        scheduler = Executors.newSingleThreadScheduledExecutor(r -> {
            Thread thread = new Thread(r, "PartitionedTableRepository-Scheduler-" + tableName);
            thread.setDaemon(true);
            return thread;
        });
        
        scheduleNextRun();
    }
    
    private void scheduleNextRun() {
        LocalDateTime now = LocalDateTime.now();
        LocalDateTime nextRun = now.toLocalDate().plusDays(1).atTime(partitionAdjustmentTime);
        
        if (nextRun.isBefore(now)) {
            nextRun = nextRun.plusDays(1);
        }
        
        long delay = java.time.Duration.between(now, nextRun).toMillis();
        
        scheduler.schedule(() -> {
            try {
                performScheduledMaintenance();
                scheduleNextRun();
            } catch (Exception e) {
                LOGGER.severe("Failed to perform scheduled maintenance: " + e.getMessage());
                scheduleNextRun();
            }
        }, delay, TimeUnit.MILLISECONDS);
    }
    
    private void performScheduledMaintenance() throws SQLException {
        LocalDateTime now = LocalDateTime.now();
        performAutomaticMaintenance(now);
    }
    
    public void shutdown() {
        // Shutdown scheduler first
        if (scheduler != null && !scheduler.isShutdown()) {
            scheduler.shutdown();
            try {
                if (!scheduler.awaitTermination(60, TimeUnit.SECONDS)) {
                    scheduler.shutdownNow();
                }
            } catch (InterruptedException e) {
                scheduler.shutdownNow();
                Thread.currentThread().interrupt();
            }
        }
        
        // Close HikariCP connection pool
        if (dataSource != null && !dataSource.isClosed()) {
            dataSource.close();
            LOGGER.info("HikariCP connection pool closed");
        }
    }
    
    private HikariDataSource createDataSource(Builder<T, K> builder) {
        HikariConfig config = new HikariConfig();
        
        // Basic connection settings
        config.setJdbcUrl(String.format("jdbc:mysql://%s:%d/%s", builder.host, builder.port, builder.database));
        config.setUsername(builder.username);
        config.setPassword(builder.password);
        config.setDriverClassName("com.mysql.cj.jdbc.Driver");
        
        // HikariCP pool settings
        config.setMaximumPoolSize(builder.maxPoolSize);
        config.setMinimumIdle(builder.minIdleConnections);
        config.setConnectionTimeout(builder.connectionTimeoutMs);
        config.setIdleTimeout(builder.idleTimeoutMs);
        config.setMaxLifetime(builder.maxLifetimeMs);
        config.setLeakDetectionThreshold(builder.leakDetectionThresholdMs);
        
        // MySQL specific settings
        config.addDataSourceProperty("serverTimezone", "UTC");
        config.addDataSourceProperty("useSSL", "false");
        config.addDataSourceProperty("allowPublicKeyRetrieval", "true");
        config.addDataSourceProperty("useUnicode", "true");
        config.addDataSourceProperty("characterEncoding", "UTF-8");
        config.addDataSourceProperty("autoReconnect", "true");
        config.addDataSourceProperty("failOverReadOnly", "false");
        config.addDataSourceProperty("maxReconnects", "3");
        
        // Performance settings
        config.addDataSourceProperty("cachePrepStmts", "true");
        config.addDataSourceProperty("prepStmtCacheSize", "250");
        config.addDataSourceProperty("prepStmtCacheSqlLimit", "2048");
        config.addDataSourceProperty("useServerPrepStmts", "true");
        config.addDataSourceProperty("rewriteBatchedStatements", "true");
        
        // Pool name for monitoring
        config.setPoolName("PartitionedTableRepository-" + (tableName != null ? tableName : "unknown"));
        
        return new HikariDataSource(config);
    }
    
    /**
     * Functional interface for mapping ResultSet to entity
     */
    @FunctionalInterface
    public interface ResultSetMapper<R> {
        R map(ResultSet rs) throws SQLException;
    }
    
    /**
     * Builder for GenericPartitionedTableRepository
     */
    public static class Builder<T, K> {
        private final Class<T> entityClass;
        private final Class<K> keyClass;
        private String host = "localhost";
        private int port = 3306;
        private String database;
        private String username;
        private String password;
        private String tableName;
        private int partitionRetentionPeriod = 365;
        private boolean autoManagePartitions = true;
        private LocalTime partitionAdjustmentTime = LocalTime.of(4, 0);
        private boolean initializePartitionsOnStart = true;
        
        // HikariCP configuration
        private int maxPoolSize = 20;
        private int minIdleConnections = 5;
        private long connectionTimeoutMs = 30000; // 30 seconds
        private long idleTimeoutMs = 600000; // 10 minutes  
        private long maxLifetimeMs = 1800000; // 30 minutes
        private long leakDetectionThresholdMs = 60000; // 1 minute
        
        public Builder(Class<T> entityClass, Class<K> keyClass) {
            this.entityClass = entityClass;
            this.keyClass = keyClass;
        }
        
        public Builder<T, K> host(String host) {
            this.host = host;
            return this;
        }
        
        public Builder<T, K> port(int port) {
            this.port = port;
            return this;
        }
        
        public Builder<T, K> database(String database) {
            this.database = database;
            return this;
        }
        
        public Builder<T, K> username(String username) {
            this.username = username;
            return this;
        }
        
        public Builder<T, K> password(String password) {
            this.password = password;
            return this;
        }
        
        public Builder<T, K> tableName(String tableName) {
            this.tableName = tableName;
            return this;
        }
        
        public Builder<T, K> partitionRetentionPeriod(int days) {
            this.partitionRetentionPeriod = days;
            return this;
        }
        
        public Builder<T, K> autoManagePartitions(boolean enable) {
            this.autoManagePartitions = enable;
            return this;
        }
        
        public Builder<T, K> partitionAdjustmentTime(int hour, int minute) {
            this.partitionAdjustmentTime = LocalTime.of(hour, minute);
            return this;
        }
        
        public Builder<T, K> partitionAdjustmentTime(LocalTime time) {
            this.partitionAdjustmentTime = time;
            return this;
        }
        
        public Builder<T, K> initializePartitionsOnStart(boolean initialize) {
            this.initializePartitionsOnStart = initialize;
            return this;
        }
        
        // HikariCP configuration methods
        public Builder<T, K> maxPoolSize(int maxPoolSize) {
            this.maxPoolSize = maxPoolSize;
            return this;
        }
        
        public Builder<T, K> minIdleConnections(int minIdleConnections) {
            this.minIdleConnections = minIdleConnections;
            return this;
        }
        
        public Builder<T, K> connectionTimeout(long timeoutMs) {
            this.connectionTimeoutMs = timeoutMs;
            return this;
        }
        
        public Builder<T, K> idleTimeout(long timeoutMs) {
            this.idleTimeoutMs = timeoutMs;
            return this;
        }
        
        public Builder<T, K> maxLifetime(long lifetimeMs) {
            this.maxLifetimeMs = lifetimeMs;
            return this;
        }
        
        public Builder<T, K> leakDetectionThreshold(long thresholdMs) {
            this.leakDetectionThresholdMs = thresholdMs;
            return this;
        }
        
        public GenericPartitionedTableRepository<T, K> build() {
            if (database == null || username == null || password == null) {
                throw new IllegalStateException("Database, username, and password are required");
            }
            return new GenericPartitionedTableRepository<>(this);
        }
    }
    
    /**
     * Create a new builder
     */
    public static <T, K> Builder<T, K> builder(Class<T> entityClass, Class<K> keyClass) {
        return new Builder<>(entityClass, keyClass);
    }
}