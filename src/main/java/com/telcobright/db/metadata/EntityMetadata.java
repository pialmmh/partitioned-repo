package com.telcobright.db.metadata;

import com.telcobright.db.annotation.*;
import java.lang.reflect.Field;
import java.math.BigDecimal;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.util.*;

/**
 * Metadata holder for entity class information, parsed once at startup
 */
public class EntityMetadata<T, K> {
    private final Class<T> entityClass;
    private final Class<K> keyClass;
    private final String tableName;
    private final List<FieldMetadata> fields;
    private final FieldMetadata idField;
    private final FieldMetadata shardingKeyField;
    private final String insertSQL;
    private final String selectByIdSQL;
    private final String createTableSQL;
    private final Map<String, Integer> insertParameterIndex;

    public EntityMetadata(Class<T> entityClass, Class<K> keyClass) {
        this.entityClass = entityClass;
        this.keyClass = keyClass;
        this.fields = new ArrayList<>();
        this.insertParameterIndex = new HashMap<>();
        
        // Parse class annotations
        Table tableAnnotation = entityClass.getAnnotation(Table.class);
        if (tableAnnotation == null) {
            // Use simple class name if no annotation
            this.tableName = entityClass.getSimpleName().toLowerCase().replace("entity", "");
        } else {
            this.tableName = tableAnnotation.name();
        }
        
        // Parse fields
        FieldMetadata tempIdField = null;
        FieldMetadata tempShardingField = null;
        int paramIndex = 1;
        
        for (Field field : entityClass.getDeclaredFields()) {
            field.setAccessible(true);
            
            // Skip static or transient fields
            if (java.lang.reflect.Modifier.isStatic(field.getModifiers()) || 
                java.lang.reflect.Modifier.isTransient(field.getModifiers())) {
                continue;
            }
            
            FieldMetadata fieldMeta = new FieldMetadata(field);
            fields.add(fieldMeta);
            
            if (fieldMeta.isId()) {
                tempIdField = fieldMeta;
            }
            if (fieldMeta.isShardingKey()) {
                tempShardingField = fieldMeta;
            }
            
            // Build parameter index for insert
            if (fieldMeta.isInsertable() && !fieldMeta.isAutoGenerated()) {
                insertParameterIndex.put(fieldMeta.getFieldName(), paramIndex++);
            }
        }
        
        this.idField = tempIdField;
        this.shardingKeyField = tempShardingField;
        
        // Enforce required columns
        validateRequiredColumns();
        
        // Generate SQL statements
        this.insertSQL = generateInsertSQL();
        this.selectByIdSQL = generateSelectByIdSQL();
        this.createTableSQL = generateCreateTableSQL();
    }
    
    /**
     * Validates that the entity has required columns for repository operations
     */
    private void validateRequiredColumns() {
        // Validate ID field exists
        if (idField == null) {
            throw new IllegalArgumentException(
                String.format("Entity %s must have a field annotated with @Id", entityClass.getSimpleName())
            );
        }
        
        // Validate sharding key field exists (created_at)
        if (shardingKeyField == null) {
            throw new IllegalArgumentException(
                String.format("Entity %s must have a field annotated with @ShardingKey (typically 'created_at')", entityClass.getSimpleName())
            );
        }
        
        // Validate sharding key is LocalDateTime type
        if (!LocalDateTime.class.isAssignableFrom(shardingKeyField.getType())) {
            throw new IllegalArgumentException(
                String.format("Entity %s sharding key field '%s' must be of type LocalDateTime", 
                    entityClass.getSimpleName(), shardingKeyField.getFieldName())
            );
        }
        
        // Validate sharding key is named "created_at" (convention enforcement)
        if (!"created_at".equals(shardingKeyField.getColumnName())) {
            throw new IllegalArgumentException(
                String.format("Entity %s sharding key field must map to column 'created_at' (found: '%s')", 
                    entityClass.getSimpleName(), shardingKeyField.getColumnName())
            );
        }
        
        // Validate ID field is named "id" (convention enforcement)  
        if (!"id".equals(idField.getColumnName())) {
            throw new IllegalArgumentException(
                String.format("Entity %s ID field must map to column 'id' (found: '%s')", 
                    entityClass.getSimpleName(), idField.getColumnName())
            );
        }
    }
    
    private String generateInsertSQL() {
        StringBuilder columns = new StringBuilder();
        StringBuilder values = new StringBuilder();
        boolean first = true;
        
        for (FieldMetadata field : fields) {
            if (field.isInsertable() && !field.isAutoGenerated()) {
                if (!first) {
                    columns.append(", ");
                    values.append(", ");
                }
                columns.append(field.getColumnName());
                values.append("?");
                first = false;
            }
        }
        
        return String.format("INSERT INTO %%s (%s) VALUES (%s)", 
            columns.toString(), values.toString());
    }
    
    private String generateSelectByIdSQL() {
        if (idField == null) {
            return null;
        }
        
        StringBuilder columns = new StringBuilder();
        boolean first = true;
        
        for (FieldMetadata field : fields) {
            if (!first) {
                columns.append(", ");
            }
            columns.append(field.getColumnName());
            first = false;
        }
        
        return String.format("SELECT %s FROM %%s WHERE %s = ?", 
            columns.toString(), idField.getColumnName());
    }
    
    private String generateCreateTableSQL() {
        StringBuilder sql = new StringBuilder("CREATE TABLE IF NOT EXISTS %s (");
        boolean first = true;
        
        for (FieldMetadata field : fields) {
            if (!first) {
                sql.append(", ");
            }
            sql.append(field.getColumnName()).append(" ").append(field.getSqlType());
            
            if (field.isId()) {
                sql.append(" PRIMARY KEY");
                if (field.isAutoGenerated()) {
                    sql.append(" AUTO_INCREMENT");
                }
            }
            
            if (!field.isNullable()) {
                sql.append(" NOT NULL");
            }
            
            first = false;
        }
        
        // Add indexes - ID already has PRIMARY KEY, but add explicit index for created_at
        if (shardingKeyField != null) {
            sql.append(", KEY idx_").append(shardingKeyField.getColumnName())
               .append(" (").append(shardingKeyField.getColumnName()).append(")");
        }
        
        // Add composite index for common query patterns (id, created_at)
        if (idField != null && shardingKeyField != null) {
            sql.append(", KEY idx_id_created_at (")
               .append(idField.getColumnName()).append(", ")
               .append(shardingKeyField.getColumnName()).append(")");
        }
        
        sql.append(") ENGINE=InnoDB DEFAULT CHARSET=utf8mb4");
        
        return sql.toString();
    }
    
    public void setInsertParameters(PreparedStatement stmt, T entity) throws SQLException {
        for (FieldMetadata field : fields) {
            if (field.isInsertable() && !field.isAutoGenerated()) {
                Integer index = insertParameterIndex.get(field.getFieldName());
                if (index != null) {
                    setParameter(stmt, index, field.getValue(entity), field.getType());
                }
            }
        }
    }
    
    public T mapResultSet(ResultSet rs) throws SQLException {
        try {
            T entity = entityClass.getDeclaredConstructor().newInstance();
            
            for (FieldMetadata field : fields) {
                Object value = getResultSetValue(rs, field.getColumnName(), field.getType());
                field.setValue(entity, value);
            }
            
            return entity;
        } catch (Exception e) {
            throw new SQLException("Failed to map result set to entity", e);
        }
    }
    
    private void setParameter(PreparedStatement stmt, int index, Object value, Class<?> type) throws SQLException {
        if (value == null) {
            stmt.setNull(index, java.sql.Types.NULL);
        } else if (type == String.class) {
            stmt.setString(index, (String) value);
        } else if (type == Long.class || type == long.class) {
            stmt.setLong(index, (Long) value);
        } else if (type == Integer.class || type == int.class) {
            stmt.setInt(index, (Integer) value);
        } else if (type == LocalDateTime.class) {
            stmt.setTimestamp(index, Timestamp.valueOf((LocalDateTime) value));
        } else if (type == BigDecimal.class) {
            stmt.setBigDecimal(index, (BigDecimal) value);
        } else if (type == Boolean.class || type == boolean.class) {
            stmt.setBoolean(index, (Boolean) value);
        } else if (type == Double.class || type == double.class) {
            stmt.setDouble(index, (Double) value);
        } else {
            stmt.setObject(index, value);
        }
    }
    
    private Object getResultSetValue(ResultSet rs, String columnName, Class<?> type) throws SQLException {
        if (type == String.class) {
            return rs.getString(columnName);
        } else if (type == Long.class || type == long.class) {
            long value = rs.getLong(columnName);
            return rs.wasNull() ? null : value;
        } else if (type == Integer.class || type == int.class) {
            int value = rs.getInt(columnName);
            return rs.wasNull() ? null : value;
        } else if (type == LocalDateTime.class) {
            Timestamp ts = rs.getTimestamp(columnName);
            return ts != null ? ts.toLocalDateTime() : null;
        } else if (type == BigDecimal.class) {
            return rs.getBigDecimal(columnName);
        } else if (type == Boolean.class || type == boolean.class) {
            return rs.getBoolean(columnName);
        } else if (type == Double.class || type == double.class) {
            double value = rs.getDouble(columnName);
            return rs.wasNull() ? null : value;
        } else {
            return rs.getObject(columnName);
        }
    }
    
    // Getters
    public String getTableName() { return tableName; }
    public String getInsertSQL() { return insertSQL; }
    public String getSelectByIdSQL() { return selectByIdSQL; }
    public String getCreateTableSQL() { return createTableSQL; }
    public FieldMetadata getIdField() { return idField; }
    public FieldMetadata getShardingKeyField() { return shardingKeyField; }
    public List<FieldMetadata> getFields() { return fields; }
    
    @SuppressWarnings("unchecked")
    public K getId(T entity) {
        if (idField == null) {
            return null;
        }
        return (K) idField.getValue(entity);
    }
    
    public void setId(T entity, K id) {
        if (idField != null) {
            idField.setValue(entity, id);
        }
    }
    
    public LocalDateTime getShardingKeyValue(T entity) {
        if (shardingKeyField == null) {
            throw new IllegalStateException("No sharding key field found in entity");
        }
        return (LocalDateTime) shardingKeyField.getValue(entity);
    }
}