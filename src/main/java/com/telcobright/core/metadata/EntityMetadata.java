package com.telcobright.core.metadata;

import com.telcobright.core.annotation.*;
import com.telcobright.core.entity.ShardingEntity;
import java.lang.reflect.Field;
import java.math.BigDecimal;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.util.*;

/**
 * Metadata holder for entity class information, parsed once at startup
 */
public class EntityMetadata<T> {
    private final Class<T> entityClass;
    private final String tableName;
    private final List<FieldMetadata> fields;
    private final FieldMetadata idField;
    private final FieldMetadata shardingKeyField;
    private final String partitionColumnName;  // Cached partition column name
    private final String insertSQL;
    private final String selectByIdSQL;
    private final String updateByIdSQL;
    private final String createTableSQL;
    private final Map<String, Integer> insertParameterIndex;
    private final Map<String, Integer> updateParameterIndex;

    public EntityMetadata(Class<T> entityClass) {
        this.entityClass = entityClass;
        this.fields = new ArrayList<>();
        this.insertParameterIndex = new HashMap<>();
        this.updateParameterIndex = new HashMap<>();
        
        // Parse class annotations
        Table tableAnnotation = entityClass.getAnnotation(Table.class);
        if (tableAnnotation == null) {
            // Use simple class name if no annotation
            this.tableName = entityClass.getSimpleName().toLowerCase().replace("entity", "");
        } else {
            this.tableName = tableAnnotation.name();
        }
        
        // Parse fields
        FieldMetadata tempIdField = null;
        FieldMetadata tempShardingField = null;
        int idFieldCount = 0;
        int shardingKeyCount = 0;
        int paramIndex = 1;
        
        for (Field field : entityClass.getDeclaredFields()) {
            field.setAccessible(true);
            
            // Skip static or transient fields
            if (java.lang.reflect.Modifier.isStatic(field.getModifiers()) || 
                java.lang.reflect.Modifier.isTransient(field.getModifiers())) {
                continue;
            }
            
            FieldMetadata fieldMeta = new FieldMetadata(field);
            fields.add(fieldMeta);
            
            if (fieldMeta.isId()) {
                idFieldCount++;
                tempIdField = fieldMeta;
            }
            if (fieldMeta.isShardingKey()) {
                shardingKeyCount++;
                tempShardingField = fieldMeta;
            }
            
            // Build parameter index for insert
            if (fieldMeta.isInsertable() && !fieldMeta.isAutoGenerated()) {
                insertParameterIndex.put(fieldMeta.getFieldName(), paramIndex++);
            }
        }
        
        this.idField = tempIdField;
        this.shardingKeyField = tempShardingField;

        // Cache partition column name from @ShardingKey field
        if (tempShardingField != null) {
            this.partitionColumnName = tempShardingField.getColumnName();
        } else {
            this.partitionColumnName = null;
        }

        // Enforce required columns
        validateRequiredColumns();
        
        // Generate SQL statements
        this.insertSQL = generateInsertSQL();
        this.selectByIdSQL = generateSelectByIdSQL();
        this.updateByIdSQL = generateUpdateByIdSQL();
        this.createTableSQL = generateCreateTableSQL();
    }
    
    /**
     * Validates that the entity has required fields for repository operations
     */
    private void validateRequiredColumns() {
        // Count annotations for validation
        int idCount = 0;
        int shardingCount = 0;
        for (FieldMetadata field : fields) {
            if (field.isId()) idCount++;
            if (field.isShardingKey()) shardingCount++;
        }
        
        // Validate exactly ONE @Id field
        if (idField == null) {
            throw new IllegalArgumentException(
                String.format("Entity %s must have exactly ONE field annotated with @Id", entityClass.getSimpleName())
            );
        }
        if (idCount > 1) {
            throw new IllegalArgumentException(
                String.format("Entity %s has %d fields annotated with @Id, but only ONE is allowed", 
                    entityClass.getSimpleName(), idCount)
            );
        }
        
        // Validate ID field is String type
        if (!String.class.equals(idField.getType())) {
            throw new IllegalArgumentException(
                String.format("Entity %s @Id field '%s' must be of type String for Split-Verse (found: %s). " +
                    "Split-Verse requires String IDs for consistent hash-based sharding.", 
                    entityClass.getSimpleName(), idField.getFieldName(), idField.getType().getSimpleName())
            );
        }
        
        // Validate exactly ONE @ShardingKey field
        if (shardingKeyField == null) {
            throw new IllegalArgumentException(
                String.format("Entity %s must have exactly ONE field annotated with @ShardingKey for date-based partitioning", 
                    entityClass.getSimpleName())
            );
        }
        if (shardingCount > 1) {
            throw new IllegalArgumentException(
                String.format("Entity %s has %d fields annotated with @ShardingKey, but only ONE is allowed", 
                    entityClass.getSimpleName(), shardingCount)
            );
        }
        
        // Validate sharding key is a Comparable type for range queries
        if (!Comparable.class.isAssignableFrom(shardingKeyField.getType())) {
            throw new IllegalArgumentException(
                String.format("Entity %s @ShardingKey field '%s' must implement Comparable for range partitioning (found: %s)",
                    entityClass.getSimpleName(), shardingKeyField.getFieldName(), shardingKeyField.getType().getSimpleName())
            );
        }

        // Validate that NO fields use unsupported date/time types
        validateDateTimeTypes();
        
        // Validate that @Id is not auto-generated
        if (idField.isAutoGenerated()) {
            throw new IllegalArgumentException(
                String.format("Entity %s @Id field '%s' must have autoGenerated=false. " +
                    "Split-Verse requires externally generated String IDs (UUID, ULID, etc.)", 
                    entityClass.getSimpleName(), idField.getFieldName())
            );
        }
    }
    
    private String generateInsertSQL() {
        StringBuilder columns = new StringBuilder();
        StringBuilder values = new StringBuilder();
        boolean first = true;
        
        for (FieldMetadata field : fields) {
            if (field.isInsertable() && !field.isAutoGenerated()) {
                if (!first) {
                    columns.append(", ");
                    values.append(", ");
                }
                columns.append(field.getColumnName());
                values.append("?");
                first = false;
            }
        }
        
        return String.format("INSERT INTO %%s (%s) VALUES (%s)", 
            columns.toString(), values.toString());
    }
    
    private String generateSelectByIdSQL() {
        if (idField == null) {
            return null;
        }
        
        StringBuilder columns = new StringBuilder();
        boolean first = true;
        
        for (FieldMetadata field : fields) {
            if (!first) {
                columns.append(", ");
            }
            columns.append(field.getColumnName());
            first = false;
        }
        
        return String.format("SELECT %s FROM %%s WHERE %s = ?", 
            columns.toString(), idField.getColumnName());
    }
    
    private String generateUpdateByIdSQL() {
        StringBuilder setClause = new StringBuilder();
        boolean first = true;
        int paramIndex = 1;
        
        for (FieldMetadata field : fields) {
            // Skip ID field and non-updatable fields
            if (field.isId() || !field.isUpdatable()) {
                continue;
            }
            
            if (!first) {
                setClause.append(", ");
            }
            setClause.append(field.getColumnName()).append(" = ?");
            updateParameterIndex.put(field.getFieldName(), paramIndex++);
            first = false;
        }
        
        // ID field is the last parameter for WHERE clause
        updateParameterIndex.put(idField.getFieldName(), paramIndex);
        
        return String.format("UPDATE %%s SET %s WHERE %s = ?",
            setClause.toString(), idField.getColumnName());
    }
    
    private String generateCreateTableSQL() {
        StringBuilder sql = new StringBuilder("CREATE TABLE IF NOT EXISTS %s (");
        boolean first = true;
        
        for (FieldMetadata field : fields) {
            if (!first) {
                sql.append(", ");
            }
            sql.append(field.getColumnName()).append(" ").append(field.getSqlType());
            
            if (field.isId()) {
                sql.append(" PRIMARY KEY");
                if (field.isAutoGenerated()) {
                    sql.append(" AUTO_INCREMENT");
                }
            }
            
            if (!field.isNullable()) {
                sql.append(" NOT NULL");
            }
            
            first = false;
        }
        
        // Add automatic indexes - ID already has PRIMARY KEY, but add explicit index for sharding key
        if (shardingKeyField != null) {
            sql.append(", KEY idx_").append(shardingKeyField.getColumnName())
               .append(" (").append(shardingKeyField.getColumnName()).append(")");
        }
        
        // No composite index needed - single String ID only
        
        // Add custom indexes from @Index annotations
        for (FieldMetadata field : fields) {
            if (field.hasIndex()) {
                String indexKeyword = field.getIndexAnnotation().unique() ? "UNIQUE KEY" : "KEY";
                String indexName = field.getIndexName();
                String comment = field.getIndexAnnotation().comment();
                
                sql.append(", ").append(indexKeyword).append(" ").append(indexName)
                   .append(" (").append(field.getColumnName()).append(")");
                
                if (!comment.isEmpty()) {
                    sql.append(" COMMENT '").append(comment).append("'");
                }
            }
        }
        
        sql.append(") ENGINE=InnoDB DEFAULT CHARSET=utf8mb4");
        
        return sql.toString();
    }
    
    public void setInsertParameters(PreparedStatement stmt, T entity) throws SQLException {
        for (FieldMetadata field : fields) {
            if (field.isInsertable() && !field.isAutoGenerated()) {
                Integer index = insertParameterIndex.get(field.getFieldName());
                if (index != null) {
                    setParameter(stmt, index, field.getValue(entity), field.getType());
                }
            }
        }
    }

    /**
     * Set parameters for batch insert (MySQL extended insert syntax)
     * For multiple entities in one INSERT statement: INSERT INTO t (cols) VALUES (?,?), (?,?), (?,?)
     */
    public void setBatchInsertParameters(PreparedStatement stmt, List<T> entities) throws SQLException {
        int paramIndex = 1;
        for (T entity : entities) {
            for (FieldMetadata field : fields) {
                if (field.isInsertable() && !field.isAutoGenerated()) {
                    setParameter(stmt, paramIndex++, field.getValue(entity), field.getType());
                }
            }
        }
    }

    public void setUpdateParameters(PreparedStatement stmt, T entity, String id) throws SQLException {
        // Set all updatable field values
        for (FieldMetadata field : fields) {
            if (!field.isId() && field.isUpdatable()) {
                Integer index = updateParameterIndex.get(field.getFieldName());
                if (index != null) {
                    setParameter(stmt, index, field.getValue(entity), field.getType());
                }
            }
        }
        
        // Set ID value for WHERE clause (last parameter)
        Integer idIndex = updateParameterIndex.get(idField.getFieldName());
        if (idIndex != null) {
            setParameter(stmt, idIndex, id, idField.getType());
        }
    }
    
    public T mapResultSet(ResultSet rs) throws SQLException {
        try {
            T entity = entityClass.getDeclaredConstructor().newInstance();
            
            for (FieldMetadata field : fields) {
                Object value = getResultSetValue(rs, field.getColumnName(), field.getType());
                field.setValue(entity, value);
            }
            
            return entity;
        } catch (Exception e) {
            throw new SQLException("Failed to map result set to entity", e);
        }
    }
    
    private void setParameter(PreparedStatement stmt, int index, Object value, Class<?> type) throws SQLException {
        if (value == null) {
            stmt.setNull(index, java.sql.Types.NULL);
        } else if (type == String.class) {
            stmt.setString(index, (String) value);
        } else if (type == Long.class || type == long.class) {
            stmt.setLong(index, (Long) value);
        } else if (type == Integer.class || type == int.class) {
            stmt.setInt(index, (Integer) value);
        } else if (type == LocalDateTime.class) {
            // Use Timestamp.valueOf which preserves the LocalDateTime exactly as is
            // Do NOT use Calendar to avoid timezone conversions
            Timestamp timestamp = Timestamp.valueOf((LocalDateTime) value);
            stmt.setTimestamp(index, timestamp);
        } else if (type == BigDecimal.class) {
            stmt.setBigDecimal(index, (BigDecimal) value);
        } else if (type == Boolean.class || type == boolean.class) {
            stmt.setBoolean(index, (Boolean) value);
        } else if (type == Double.class || type == double.class) {
            stmt.setDouble(index, (Double) value);
        } else {
            stmt.setObject(index, value);
        }
    }
    
    private Object getResultSetValue(ResultSet rs, String columnName, Class<?> type) throws SQLException {
        if (type == String.class) {
            return rs.getString(columnName);
        } else if (type == Long.class || type == long.class) {
            long value = rs.getLong(columnName);
            return rs.wasNull() ? null : value;
        } else if (type == Integer.class || type == int.class) {
            int value = rs.getInt(columnName);
            return rs.wasNull() ? null : value;
        } else if (type == LocalDateTime.class) {
            // Get timestamp without Calendar to avoid timezone conversion
            // toLocalDateTime() preserves the exact date/time from the database
            Timestamp ts = rs.getTimestamp(columnName);
            return ts != null ? ts.toLocalDateTime() : null;
        } else if (type == BigDecimal.class) {
            return rs.getBigDecimal(columnName);
        } else if (type == Boolean.class || type == boolean.class) {
            return rs.getBoolean(columnName);
        } else if (type == Double.class || type == double.class) {
            double value = rs.getDouble(columnName);
            return rs.wasNull() ? null : value;
        } else {
            return rs.getObject(columnName);
        }
    }
    
    // Getters
    public String getTableName() { return tableName; }
    public String getInsertSQL() { return insertSQL; }
    public String getSelectByIdSQL() { return selectByIdSQL; }
    public String getUpdateByIdSQL() { return updateByIdSQL; }
    public String getCreateTableSQL() { return createTableSQL; }
    public FieldMetadata getIdField() { return idField; }
    public FieldMetadata getShardingKeyField() { return shardingKeyField; }
    public List<FieldMetadata> getFields() { return fields; }
    public String getPartitionColumnName() { return partitionColumnName; }
    
    public String getId(T entity) {
        if (idField == null) {
            return null;
        }
        return (String) idField.getValue(entity);
    }
    
    public void setId(T entity, String id) {
        if (idField != null) {
            idField.setValue(entity, id);
        }
    }
    
    public LocalDateTime getShardingKeyValue(T entity) {
        if (shardingKeyField == null) {
            throw new IllegalStateException("No sharding key field found in entity");
        }
        Object value = shardingKeyField.getValue(entity);
        if (value instanceof LocalDateTime) {
            return (LocalDateTime) value;
        }
        // Use the interface method if available
        if (entity instanceof ShardingEntity) {
            Object partitionValue = ((ShardingEntity) entity).getPartitionColValue();
            if (partitionValue instanceof LocalDateTime) {
                return (LocalDateTime) partitionValue;
            }
        }
        throw new ClassCastException("Sharding key value is not LocalDateTime: " + value.getClass());
    }

    /**
     * Get the partition column value from the entity (generic type support).
     */
    @SuppressWarnings("unchecked")
    public <V extends Comparable<V>> V getPartitionColValue(T entity) {
        if (shardingKeyField == null) {
            throw new IllegalStateException("No sharding key field found in entity");
        }
        Object value = shardingKeyField.getValue(entity);
        if (value == null) {
            return null;
        }
        if (!Comparable.class.isAssignableFrom(value.getClass())) {
            throw new ClassCastException("Partition column value must be Comparable: " + value.getClass());
        }
        return (V) value;
    }

    private void validateDateTimeTypes() {
        // IMPORTANT: Only validate @Id and @ShardingKey fields
        // Regular fields can use any date/time types

        // Validate @Id field - must be String
        if (idField != null) {
            Class<?> idType = idField.getType();
            if (idType != String.class) {
                throw new IllegalArgumentException(
                    String.format("Entity %s @Id field must be String type for consistent sharding. " +
                        "Found: %s. See doc/supported-data-types.md for details.",
                        entityClass.getSimpleName(), idType.getSimpleName())
                );
            }
        }

        // Validate @ShardingKey field - restricted types only
        if (shardingKeyField != null) {
            Class<?> shardingType = shardingKeyField.getType();

            // Check for allowed types first
            if (shardingType == LocalDateTime.class ||
                shardingType == String.class ||
                shardingType == Long.class ||
                shardingType == Integer.class) {
                // These types are allowed
                return;
            }

            // Now check for specific unsupported date/time types to provide helpful error messages
            if (shardingType == java.util.Date.class) {
                throw new IllegalArgumentException(
                    String.format("Entity %s @ShardingKey field '%s' uses unsupported type java.util.Date. " +
                        "Only LocalDateTime is supported for date-based partitioning. " +
                        "See doc/supported-data-types.md for details.",
                        entityClass.getSimpleName(), shardingKeyField.getFieldName())
                );
            }
            if (shardingType == java.sql.Date.class) {
                throw new IllegalArgumentException(
                    String.format("Entity %s @ShardingKey field '%s' uses unsupported type java.sql.Date. " +
                        "Only LocalDateTime is supported for date-based partitioning. " +
                        "See doc/supported-data-types.md for details.",
                        entityClass.getSimpleName(), shardingKeyField.getFieldName())
                );
            }
            if (shardingType == java.sql.Timestamp.class) {
                throw new IllegalArgumentException(
                    String.format("Entity %s @ShardingKey field '%s' uses unsupported type java.sql.Timestamp. " +
                        "Only LocalDateTime is supported for date-based partitioning. " +
                        "See doc/supported-data-types.md for details.",
                        entityClass.getSimpleName(), shardingKeyField.getFieldName())
                );
            }
            if (shardingType == java.sql.Time.class) {
                throw new IllegalArgumentException(
                    String.format("Entity %s @ShardingKey field '%s' uses unsupported type java.sql.Time. " +
                        "Only LocalDateTime is supported for date-based partitioning. " +
                        "See doc/supported-data-types.md for details.",
                        entityClass.getSimpleName(), shardingKeyField.getFieldName())
                );
            }
            if (shardingType == java.time.ZonedDateTime.class) {
                throw new IllegalArgumentException(
                    String.format("Entity %s @ShardingKey field '%s' uses unsupported type ZonedDateTime. " +
                        "Only LocalDateTime is supported for date-based partitioning. " +
                        "See doc/supported-data-types.md for details.",
                        entityClass.getSimpleName(), shardingKeyField.getFieldName())
                );
            }
            if (shardingType == java.time.OffsetDateTime.class) {
                throw new IllegalArgumentException(
                    String.format("Entity %s @ShardingKey field '%s' uses unsupported type OffsetDateTime. " +
                        "Only LocalDateTime is supported for date-based partitioning. " +
                        "See doc/supported-data-types.md for details.",
                        entityClass.getSimpleName(), shardingKeyField.getFieldName())
                );
            }
            if (shardingType == java.time.Instant.class) {
                throw new IllegalArgumentException(
                    String.format("Entity %s @ShardingKey field '%s' uses unsupported type Instant. " +
                        "Only LocalDateTime is supported for date-based partitioning. " +
                        "See doc/supported-data-types.md for details.",
                        entityClass.getSimpleName(), shardingKeyField.getFieldName())
                );
            }

            // Generic error for any other unsupported type
            throw new IllegalArgumentException(
                String.format("Entity %s @ShardingKey field '%s' uses unsupported type %s. " +
                    "Supported types: LocalDateTime (for date-based), String, Long, Integer. " +
                    "See doc/supported-data-types.md for details.",
                    entityClass.getSimpleName(), shardingKeyField.getFieldName(), shardingType.getSimpleName())
            );
        }
    }
}