package com.telcobright.core.metadata;

import com.telcobright.core.annotation.*;
import java.lang.reflect.Field;
import java.math.BigDecimal;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.util.*;

/**
 * Metadata holder for entity class information, parsed once at startup
 */
public class EntityMetadata<T> {
    private final Class<T> entityClass;
    private final String tableName;
    private final List<FieldMetadata> fields;
    private final FieldMetadata idField;
    private final FieldMetadata shardingKeyField;
    private final String insertSQL;
    private final String selectByIdSQL;
    private final String updateByIdSQL;
    private final String createTableSQL;
    private final Map<String, Integer> insertParameterIndex;
    private final Map<String, Integer> updateParameterIndex;

    public EntityMetadata(Class<T> entityClass) {
        this.entityClass = entityClass;
        this.fields = new ArrayList<>();
        this.insertParameterIndex = new HashMap<>();
        this.updateParameterIndex = new HashMap<>();
        
        // Parse class annotations
        Table tableAnnotation = entityClass.getAnnotation(Table.class);
        if (tableAnnotation == null) {
            // Use simple class name if no annotation
            this.tableName = entityClass.getSimpleName().toLowerCase().replace("entity", "");
        } else {
            this.tableName = tableAnnotation.name();
        }
        
        // Parse fields
        FieldMetadata tempIdField = null;
        FieldMetadata tempShardingField = null;
        int paramIndex = 1;
        
        for (Field field : entityClass.getDeclaredFields()) {
            field.setAccessible(true);
            
            // Skip static or transient fields
            if (java.lang.reflect.Modifier.isStatic(field.getModifiers()) || 
                java.lang.reflect.Modifier.isTransient(field.getModifiers())) {
                continue;
            }
            
            FieldMetadata fieldMeta = new FieldMetadata(field);
            fields.add(fieldMeta);
            
            if (fieldMeta.isId()) {
                tempIdField = fieldMeta;
            }
            if (fieldMeta.isShardingKey()) {
                tempShardingField = fieldMeta;
            }
            
            // Build parameter index for insert
            if (fieldMeta.isInsertable() && !fieldMeta.isAutoGenerated()) {
                insertParameterIndex.put(fieldMeta.getFieldName(), paramIndex++);
            }
        }
        
        this.idField = tempIdField;
        this.shardingKeyField = tempShardingField;
        
        // Enforce required columns
        validateRequiredColumns();
        
        // Generate SQL statements
        this.insertSQL = generateInsertSQL();
        this.selectByIdSQL = generateSelectByIdSQL();
        this.updateByIdSQL = generateUpdateByIdSQL();
        this.createTableSQL = generateCreateTableSQL();
    }
    
    /**
     * Validates that the entity has required fields for repository operations
     */
    private void validateRequiredColumns() {
        // Validate ID field exists
        if (idField == null) {
            throw new IllegalArgumentException(
                String.format("Entity %s must have a field annotated with @Id", entityClass.getSimpleName())
            );
        }
        
        // Validate sharding key field exists
        if (shardingKeyField == null) {
            throw new IllegalArgumentException(
                String.format("Entity %s must have a field annotated with @ShardingKey for date-based partitioning", entityClass.getSimpleName())
            );
        }
        
        // Validate sharding key is LocalDateTime type
        if (!LocalDateTime.class.isAssignableFrom(shardingKeyField.getType())) {
            throw new IllegalArgumentException(
                String.format("Entity %s sharding key field '%s' must be of type LocalDateTime, found: %s", 
                    entityClass.getSimpleName(), shardingKeyField.getFieldName(), shardingKeyField.getType().getSimpleName())
            );
        }
        
        // Note: Column names are now flexible and determined by @Column annotations
        // No longer enforcing specific column names like "id" or "created_at"
    }
    
    private String generateInsertSQL() {
        StringBuilder columns = new StringBuilder();
        StringBuilder values = new StringBuilder();
        boolean first = true;
        
        for (FieldMetadata field : fields) {
            if (field.isInsertable() && !field.isAutoGenerated()) {
                if (!first) {
                    columns.append(", ");
                    values.append(", ");
                }
                columns.append(field.getColumnName());
                values.append("?");
                first = false;
            }
        }
        
        return String.format("INSERT INTO %%s (%s) VALUES (%s)", 
            columns.toString(), values.toString());
    }
    
    private String generateSelectByIdSQL() {
        if (idField == null) {
            return null;
        }
        
        StringBuilder columns = new StringBuilder();
        boolean first = true;
        
        for (FieldMetadata field : fields) {
            if (!first) {
                columns.append(", ");
            }
            columns.append(field.getColumnName());
            first = false;
        }
        
        return String.format("SELECT %s FROM %%s WHERE %s = ?", 
            columns.toString(), idField.getColumnName());
    }
    
    private String generateUpdateByIdSQL() {
        StringBuilder setClause = new StringBuilder();
        boolean first = true;
        int paramIndex = 1;
        
        for (FieldMetadata field : fields) {
            // Skip ID field and non-updatable fields
            if (field.isId() || !field.isUpdatable()) {
                continue;
            }
            
            if (!first) {
                setClause.append(", ");
            }
            setClause.append(field.getColumnName()).append(" = ?");
            updateParameterIndex.put(field.getFieldName(), paramIndex++);
            first = false;
        }
        
        // ID field is the last parameter for WHERE clause
        updateParameterIndex.put(idField.getFieldName(), paramIndex);
        
        return String.format("UPDATE %%s SET %s WHERE %s = ?",
            setClause.toString(), idField.getColumnName());
    }
    
    private String generateCreateTableSQL() {
        StringBuilder sql = new StringBuilder("CREATE TABLE IF NOT EXISTS %s (");
        boolean first = true;
        
        for (FieldMetadata field : fields) {
            if (!first) {
                sql.append(", ");
            }
            sql.append(field.getColumnName()).append(" ").append(field.getSqlType());
            
            if (field.isId()) {
                sql.append(" PRIMARY KEY");
                if (field.isAutoGenerated()) {
                    sql.append(" AUTO_INCREMENT");
                }
            }
            
            if (!field.isNullable()) {
                sql.append(" NOT NULL");
            }
            
            first = false;
        }
        
        // Add automatic indexes - ID already has PRIMARY KEY, but add explicit index for sharding key
        if (shardingKeyField != null) {
            sql.append(", KEY idx_").append(shardingKeyField.getColumnName())
               .append(" (").append(shardingKeyField.getColumnName()).append(")");
        }
        
        // No composite index needed - single String ID only
        
        // Add custom indexes from @Index annotations
        for (FieldMetadata field : fields) {
            if (field.hasIndex()) {
                String indexKeyword = field.getIndexAnnotation().unique() ? "UNIQUE KEY" : "KEY";
                String indexName = field.getIndexName();
                String comment = field.getIndexAnnotation().comment();
                
                sql.append(", ").append(indexKeyword).append(" ").append(indexName)
                   .append(" (").append(field.getColumnName()).append(")");
                
                if (!comment.isEmpty()) {
                    sql.append(" COMMENT '").append(comment).append("'");
                }
            }
        }
        
        sql.append(") ENGINE=InnoDB DEFAULT CHARSET=utf8mb4");
        
        return sql.toString();
    }
    
    public void setInsertParameters(PreparedStatement stmt, T entity) throws SQLException {
        for (FieldMetadata field : fields) {
            if (field.isInsertable() && !field.isAutoGenerated()) {
                Integer index = insertParameterIndex.get(field.getFieldName());
                if (index != null) {
                    setParameter(stmt, index, field.getValue(entity), field.getType());
                }
            }
        }
    }
    
    public void setUpdateParameters(PreparedStatement stmt, T entity, String id) throws SQLException {
        // Set all updatable field values
        for (FieldMetadata field : fields) {
            if (!field.isId() && field.isUpdatable()) {
                Integer index = updateParameterIndex.get(field.getFieldName());
                if (index != null) {
                    setParameter(stmt, index, field.getValue(entity), field.getType());
                }
            }
        }
        
        // Set ID value for WHERE clause (last parameter)
        Integer idIndex = updateParameterIndex.get(idField.getFieldName());
        if (idIndex != null) {
            setParameter(stmt, idIndex, id, idField.getType());
        }
    }
    
    public T mapResultSet(ResultSet rs) throws SQLException {
        try {
            T entity = entityClass.getDeclaredConstructor().newInstance();
            
            for (FieldMetadata field : fields) {
                Object value = getResultSetValue(rs, field.getColumnName(), field.getType());
                field.setValue(entity, value);
            }
            
            return entity;
        } catch (Exception e) {
            throw new SQLException("Failed to map result set to entity", e);
        }
    }
    
    private void setParameter(PreparedStatement stmt, int index, Object value, Class<?> type) throws SQLException {
        if (value == null) {
            stmt.setNull(index, java.sql.Types.NULL);
        } else if (type == String.class) {
            stmt.setString(index, (String) value);
        } else if (type == Long.class || type == long.class) {
            stmt.setLong(index, (Long) value);
        } else if (type == Integer.class || type == int.class) {
            stmt.setInt(index, (Integer) value);
        } else if (type == LocalDateTime.class) {
            // Create Timestamp from LocalDateTime and explicitly set with local Calendar
            // to prevent MySQL JDBC driver from applying timezone conversion
            Timestamp timestamp = Timestamp.valueOf((LocalDateTime) value);
            stmt.setTimestamp(index, timestamp, java.util.Calendar.getInstance());
        } else if (type == BigDecimal.class) {
            stmt.setBigDecimal(index, (BigDecimal) value);
        } else if (type == Boolean.class || type == boolean.class) {
            stmt.setBoolean(index, (Boolean) value);
        } else if (type == Double.class || type == double.class) {
            stmt.setDouble(index, (Double) value);
        } else {
            stmt.setObject(index, value);
        }
    }
    
    private Object getResultSetValue(ResultSet rs, String columnName, Class<?> type) throws SQLException {
        if (type == String.class) {
            return rs.getString(columnName);
        } else if (type == Long.class || type == long.class) {
            long value = rs.getLong(columnName);
            return rs.wasNull() ? null : value;
        } else if (type == Integer.class || type == int.class) {
            int value = rs.getInt(columnName);
            return rs.wasNull() ? null : value;
        } else if (type == LocalDateTime.class) {
            // Get timestamp with local Calendar to prevent timezone conversion
            Timestamp ts = rs.getTimestamp(columnName, java.util.Calendar.getInstance());
            return ts != null ? ts.toLocalDateTime() : null;
        } else if (type == BigDecimal.class) {
            return rs.getBigDecimal(columnName);
        } else if (type == Boolean.class || type == boolean.class) {
            return rs.getBoolean(columnName);
        } else if (type == Double.class || type == double.class) {
            double value = rs.getDouble(columnName);
            return rs.wasNull() ? null : value;
        } else {
            return rs.getObject(columnName);
        }
    }
    
    // Getters
    public String getTableName() { return tableName; }
    public String getInsertSQL() { return insertSQL; }
    public String getSelectByIdSQL() { return selectByIdSQL; }
    public String getUpdateByIdSQL() { return updateByIdSQL; }
    public String getCreateTableSQL() { return createTableSQL; }
    public FieldMetadata getIdField() { return idField; }
    public FieldMetadata getShardingKeyField() { return shardingKeyField; }
    public List<FieldMetadata> getFields() { return fields; }
    
    public String getId(T entity) {
        if (idField == null) {
            return null;
        }
        return (String) idField.getValue(entity);
    }
    
    public void setId(T entity, String id) {
        if (idField != null) {
            idField.setValue(entity, id);
        }
    }
    
    public LocalDateTime getShardingKeyValue(T entity) {
        if (shardingKeyField == null) {
            throw new IllegalStateException("No sharding key field found in entity");
        }
        return (LocalDateTime) shardingKeyField.getValue(entity);
    }
}