package com.telcobright.splitverse.tests;

import com.telcobright.core.repository.SplitVerseRepository;
import com.telcobright.core.repository.GenericMultiTableRepository;
import com.telcobright.splitverse.config.RepositoryMode;
import com.telcobright.splitverse.config.ShardConfig;
import com.telcobright.core.annotation.Table;
import com.telcobright.core.annotation.Id;
import com.telcobright.core.annotation.Column;
import com.telcobright.core.annotation.ShardingKey;
import com.telcobright.core.entity.ShardingEntity;
import org.junit.jupiter.api.*;
import java.sql.*;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.*;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Test 100% retrieval using findById (no date range)
 */
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class SmsRetrieveByIdOnlyTest {
    private static final String TEST_DB = "sms_id_test";
    private static SplitVerseRepository<SmsRecord, LocalDateTime> repository;
    private static final int TOTAL_RECORDS = 1000;
    private static final Map<String, SmsRecord> storedRecords = new HashMap<>();

    @Table(name = "sms")
    public static class SmsRecord implements ShardingEntity<LocalDateTime> {
        @Id(autoGenerated = false)
        private String id;

        @ShardingKey
        @Column(name = "created_at")
        private LocalDateTime createdAt;

        @Column(name = "message")
        private String message;

        public SmsRecord() {}

        public SmsRecord(String id, LocalDateTime createdAt, String message) {
            this.id = id;
            this.createdAt = createdAt;
            this.message = message;
        }

        @Override
        public String getId() { return id; }
        @Override
        public void setId(String id) { this.id = id; }
        @Override
        public LocalDateTime getPartitionColValue() { return createdAt; }
        @Override
        public void setPartitionColValue(LocalDateTime value) { this.createdAt = value; }

        public LocalDateTime getCreatedAt() { return createdAt; }
        public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }
    }

    @BeforeAll
    static void setup() throws Exception {
        System.out.println("=== SMS ID-Only Retrieval Test ===");

        // Create test database
        try (Connection conn = DriverManager.getConnection(
                "jdbc:mysql://127.0.0.1:3306?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=UTC",
                "root", "123456");
             Statement stmt = conn.createStatement()) {
            stmt.execute("DROP DATABASE IF EXISTS " + TEST_DB);
            stmt.execute("CREATE DATABASE " + TEST_DB);
        }

        // Configure shard
        ShardConfig shardConfig = ShardConfig.builder()
            .shardId("shard_01")
            .database(TEST_DB)
            .host("127.0.0.1")
            .port(3306)
            .username("root")
            .password("123456")
            .enabled(true)
            .build();

        // Build repository
        repository = SplitVerseRepository.<SmsRecord, LocalDateTime>builder()
            .withSingleShard(shardConfig)
            .withEntityClass(SmsRecord.class)
            .withRepositoryMode(RepositoryMode.MULTI_TABLE)
            .withTableGranularity(GenericMultiTableRepository.TableGranularity.DAILY)
            .withPartitionType(com.telcobright.core.partition.PartitionType.DATE_BASED)
            .build();

        System.out.println("âœ“ Repository initialized");
    }

    @Test
    @Order(1)
    void testInsertRecords() throws Exception {
        System.out.println("\n=== Test 1: Insert " + TOTAL_RECORDS + " Records ===");
        storedRecords.clear();

        LocalDateTime baseTime = LocalDateTime.now(ZoneOffset.UTC).withHour(12).withMinute(0).withSecond(0).withNano(0);
        Random random = new Random(42);

        for (int i = 0; i < TOTAL_RECORDS; i++) {
            String id = UUID.randomUUID().toString();

            // Distribute across several days
            int dayOffset = i % 7;
            int hourOffset = random.nextInt(24);
            LocalDateTime timestamp = baseTime.minusDays(dayOffset).plusHours(hourOffset);

            String message = "Test message #" + i;
            SmsRecord sms = new SmsRecord(id, timestamp, message);

            repository.insert(sms);
            storedRecords.put(id, sms);

            if ((i + 1) % 100 == 0) {
                System.out.println("  Progress: " + (i + 1) + "/" + TOTAL_RECORDS);
            }
        }

        System.out.println("âœ“ Inserted " + TOTAL_RECORDS + " records");
        System.out.println("âœ“ Stored " + storedRecords.size() + " records in HashMap");
    }

    @Test
    @Order(2)
    void testRetrieveAllById() throws Exception {
        System.out.println("\n=== Test 2: Retrieve All Records by ID ===");

        int successCount = 0;
        int failureCount = 0;

        for (Map.Entry<String, SmsRecord> entry : storedRecords.entrySet()) {
            String id = entry.getKey();
            SmsRecord expected = entry.getValue();

            try {
                // Use findById instead of findByIdAndPartitionColRange
                SmsRecord found = repository.findById(id);

                if (found != null) {
                    // Verify fields match
                    if (id.equals(found.getId()) &&
                        expected.getMessage().equals(found.getMessage())) {
                        successCount++;
                    } else {
                        failureCount++;
                        System.err.println("Field mismatch for ID: " + id);
                    }
                } else {
                    failureCount++;
                    if (failureCount <= 5) { // Only print first few failures
                        System.err.println("Failed to retrieve ID: " + id);
                    }
                }
            } catch (Exception e) {
                failureCount++;
                System.err.println("Error retrieving ID: " + id + " - " + e.getMessage());
            }

            if ((successCount + failureCount) % 100 == 0) {
                System.out.printf("  Progress: %d/%d tested (%.1f%% success rate so far)\n",
                    successCount + failureCount, storedRecords.size(),
                    (successCount * 100.0) / (successCount + failureCount));
            }
        }

        // Final results
        System.out.println("\n=== FINAL RESULTS ===");
        System.out.println("Total records tested: " + storedRecords.size());
        System.out.println("Successfully retrieved: " + successCount);
        System.out.println("Failed to retrieve: " + failureCount);

        double successRate = (successCount * 100.0) / storedRecords.size();
        System.out.printf("SUCCESS RATE: %.2f%%\n", successRate);

        // For this test, we expect 100% success with findById
        assertEquals(storedRecords.size(), successCount,
            String.format("Should retrieve ALL entities. Failed to retrieve %d out of %d",
                failureCount, storedRecords.size()));

        if (successRate == 100.0) {
            System.out.println("\nðŸŽ¯ 100% SUCCESS RATE ACHIEVED! ðŸŽ¯");
            System.out.println("All " + TOTAL_RECORDS + " records retrieved successfully using findById!");
        }
    }

    @AfterAll
    static void cleanup() {
        System.out.println("\n=== Test Complete ===");
        System.out.println("Database: " + TEST_DB);
        System.out.println("Records tested: " + storedRecords.size());
    }
}