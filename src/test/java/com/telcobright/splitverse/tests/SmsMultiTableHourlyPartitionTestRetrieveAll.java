package com.telcobright.splitverse.tests;

import com.telcobright.core.repository.SplitVerseRepository;
import com.telcobright.core.repository.GenericMultiTableRepository;
import com.telcobright.splitverse.config.RepositoryMode;
import com.telcobright.splitverse.config.ShardConfig;
import com.telcobright.core.annotation.Table;
import com.telcobright.core.annotation.Id;
import com.telcobright.core.annotation.Column;
import com.telcobright.core.annotation.ShardingKey;
import com.telcobright.core.entity.ShardingEntity;
import org.junit.jupiter.api.*;
import java.sql.*;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Test Scenario: SMS with Multi-Table Daily and Hourly Native Partitioning
 * This test ensures we can retrieve 100% of entities with findByIdAndPartitionColRange
 */
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class SmsMultiTableHourlyPartitionTestRetrieveAll {
    private static final String TEST_DB = "sms_shard_01";
    private static SplitVerseRepository<SmsRecord, LocalDateTime> repository;
    private static final int TOTAL_RECORDS = 5000; // Reduced for faster test execution
    private static final int TEST_DAYS = 3; // Distribute across 3 days
    private static final int RETENTION_DAYS = 5; // Create 5 days of tables
    private static final Random random = new Random(42); // Fixed seed for reproducibility
    private static LocalDateTime baseTime;
    private static LocalDateTime maxPartitionDate; // Track the max partition boundary
    private static final Map<String, SmsRecord> smsEntityMapRetrieveAll = new HashMap<>(); // Store ALL entities
    private static com.telcobright.core.connection.ConnectionProvider connectionProvider;

    @Table(name = "sms")
    public static class SmsRecord implements ShardingEntity<LocalDateTime> {
        @Id(autoGenerated = false)
        private String id;

        @ShardingKey
        @Column(name = "created_at")
        private LocalDateTime createdAt;

        @Column(name = "sender_number")
        private String senderNumber;

        @Column(name = "recipient_number")
        private String recipientNumber;

        @Column(name = "message_content")
        private String messageContent;

        @Column(name = "message_type")
        private String messageType;

        @Column(name = "delivery_status")
        private String deliveryStatus;

        @Column(name = "message_length")
        private Integer messageLength;

        @Column(name = "retry_count")
        private Integer retryCount;

        public SmsRecord() {}

        public SmsRecord(LocalDateTime createdAt, String senderNumber, String recipientNumber,
                        String messageContent, String messageType, String deliveryStatus,
                        Integer messageLength, Integer retryCount) {
            this.createdAt = createdAt;
            this.senderNumber = senderNumber;
            this.recipientNumber = recipientNumber;
            this.messageContent = messageContent;
            this.messageType = messageType;
            this.deliveryStatus = deliveryStatus;
            this.messageLength = messageLength;
            this.retryCount = retryCount;
        }

        @Override
        public String getId() { return id; }
        @Override
        public void setId(String id) { this.id = id; }
        @Override
        public LocalDateTime getPartitionColValue() { return createdAt; }
        @Override
        public void setPartitionColValue(LocalDateTime value) { this.createdAt = value; }

        // Getters and setters
        public LocalDateTime getCreatedAt() { return createdAt; }
        public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
        public String getSenderNumber() { return senderNumber; }
        public void setSenderNumber(String senderNumber) { this.senderNumber = senderNumber; }
        public String getRecipientNumber() { return recipientNumber; }
        public void setRecipientNumber(String recipientNumber) { this.recipientNumber = recipientNumber; }
        public String getMessageContent() { return messageContent; }
        public void setMessageContent(String content) { this.messageContent = content; }
        public String getMessageType() { return messageType; }
        public void setMessageType(String type) { this.messageType = type; }
        public String getDeliveryStatus() { return deliveryStatus; }
        public void setDeliveryStatus(String status) { this.deliveryStatus = status; }
        public Integer getMessageLength() { return messageLength; }
        public void setMessageLength(Integer length) { this.messageLength = length; }
        public Integer getRetryCount() { return retryCount; }
        public void setRetryCount(Integer count) { this.retryCount = count; }
    }

    @BeforeAll
    static void setup() throws Exception {
        System.out.println("\n=== SMS 100% Retrieval Test Setup ===");
        System.out.println("Database: " + TEST_DB);
        System.out.println("Mode: Multi-table with daily tables, hourly native partitions");
        System.out.println("Goal: Achieve 100% retrieval success rate");
        System.out.println("Total records: " + TOTAL_RECORDS);

        // Create test database
        try (Connection conn = DriverManager.getConnection(
                "jdbc:mysql://127.0.0.1:3306?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=UTC",
                "root", "123456");
             Statement stmt = conn.createStatement()) {
            stmt.execute("DROP DATABASE IF EXISTS " + TEST_DB);
            stmt.execute("CREATE DATABASE " + TEST_DB);
            System.out.println("✓ Database created");
        }

        // Initialize ConnectionProvider
        connectionProvider = new com.telcobright.core.connection.ConnectionProvider.Builder()
            .host("127.0.0.1")
            .port(3306)
            .database(TEST_DB)
            .username("root")
            .password("123456")
            .build();

        // Configure shard
        ShardConfig shardConfig = ShardConfig.builder()
            .shardId("shard_01")
            .database(TEST_DB)
            .host("127.0.0.1")
            .port(3306)
            .username("root")
            .password("123456")
            .enabled(true)
            .build();

        // Set base time to midnight today
        baseTime = LocalDateTime.now().withHour(0).withMinute(0).withSecond(0).withNano(0);

        // Build repository with MULTI_TABLE mode and enable nested partitions
        repository = SplitVerseRepository.<SmsRecord, LocalDateTime>builder()
            .withSingleShard(shardConfig)
            .withEntityClass(SmsRecord.class)
            .withRepositoryMode(RepositoryMode.MULTI_TABLE)
            .withTableGranularity(GenericMultiTableRepository.TableGranularity.DAILY)
            .withRetentionDays(RETENTION_DAYS)
            .withPartitionType(com.telcobright.core.partition.PartitionType.DATE_BASED)
            .withNestedPartitions(true) // Enable nested partitions
            .withNestedPartitionCount(24) // 24 hourly partitions per day
            .build();

        System.out.println("✓ Repository configured with daily tables and hourly partitions");

        // Read the max partition limit
        readMaxPartitionLimit();
    }

    private static void readMaxPartitionLimit() throws SQLException {
        System.out.println("\n=== Reading Max Partition Limit ===");

        try (Connection conn = connectionProvider.getConnection();
             Statement stmt = conn.createStatement()) {

            // Query for the maximum date table
            String query = String.format(
                "SELECT table_name FROM information_schema.tables " +
                "WHERE table_schema = '%s' AND table_name LIKE 'sms_%%' " +
                "ORDER BY table_name DESC LIMIT 1",
                TEST_DB
            );

            try (ResultSet rs = stmt.executeQuery(query)) {
                if (rs.next()) {
                    String maxTable = rs.getString("table_name");
                    // Extract date from table name (format: sms_20250921)
                    String dateStr = maxTable.substring(4); // Remove "sms_" prefix
                    maxPartitionDate = LocalDateTime.parse(dateStr + " 23:59:59",
                        DateTimeFormatter.ofPattern("yyyyMMdd HH:mm:ss"));
                    System.out.println("Max partition date: " + maxPartitionDate);
                    System.out.println("Max table: " + maxTable);
                }
            }
        }
    }

    @Test
    @Order(1)
    void testInsertOneMillionSmsRecords() throws Exception {
        System.out.println("\n=== Phase 1: Insert 1 Million SMS Records ===");
        System.out.println("Storing ALL entities in HashMap for later verification...");

        // Clear the HashMap to ensure clean state
        smsEntityMapRetrieveAll.clear();
        System.out.println("Cleared HashMap - starting fresh");

        String[] messageTypes = {"SMS", "MMS"};
        String[] deliveryStatuses = {"SENT", "DELIVERED", "FAILED", "PENDING"};
        String[] messageTemplates = {
            "Hello, this is test message #",
            "Important notification: ",
            "Reminder: Your appointment is scheduled for ",
            "Thank you for your purchase. Order ID: ",
            "Verification code: "
        };

        System.out.println("Starting insertion of " + TOTAL_RECORDS + " SMS records across " + TEST_DAYS + " days...");
        long startTime = System.currentTimeMillis();
        long lastReportTime = startTime;

        for (int i = 0; i < TOTAL_RECORDS; i++) {
            // Distribute records across 7 days
            int dayOffset = i % TEST_DAYS;
            int hourOffset = random.nextInt(24);
            int minuteOffset = random.nextInt(60);

            LocalDateTime timestamp = baseTime.minusDays(dayOffset)
                .plusHours(hourOffset)
                .plusMinutes(minuteOffset);

            // Ensure timestamp doesn't exceed max partition
            if (maxPartitionDate != null && timestamp.isAfter(maxPartitionDate)) {
                // Adjust to stay within bounds
                timestamp = maxPartitionDate.minusHours(random.nextInt(24));
            }

            // Generate phone numbers
            String senderNumber = String.format("+1%03d%03d%04d",
                200 + random.nextInt(800), random.nextInt(1000), random.nextInt(10000));
            String recipientNumber = String.format("+1%03d%03d%04d",
                200 + random.nextInt(800), random.nextInt(1000), random.nextInt(10000));

            // Generate message content
            String template = messageTemplates[random.nextInt(messageTemplates.length)];
            String messageContent = template + UUID.randomUUID().toString().substring(0, 8);
            int messageLength = messageContent.length();

            // Random message type and delivery status
            String messageType = messageTypes[random.nextInt(messageTypes.length)];
            String deliveryStatus = deliveryStatuses[random.nextInt(deliveryStatuses.length)];
            int retryCount = deliveryStatus.equals("FAILED") ? random.nextInt(5) : 0;

            SmsRecord sms = new SmsRecord(
                timestamp,
                senderNumber,
                recipientNumber,
                messageContent,
                messageType,
                deliveryStatus,
                messageLength,
                retryCount
            );

            // Generate ID for the SMS record
            String smsId = UUID.randomUUID().toString();
            sms.setId(smsId);

            repository.insert(sms);

            // CRITICAL: Store complete SMS entity in HashMap
            smsEntityMapRetrieveAll.put(smsId, sms);

            // Debug first few inserts AND test immediate retrieval
            if (i < 3) {
                System.out.println("DEBUG Insert #" + i + ": ID=" + smsId + ", timestamp=" + timestamp);
                System.out.println("  HashMap now contains " + smsEntityMapRetrieveAll.size() + " entities");

                // Test immediate retrieval
                try {
                    SmsRecord retrieved = repository.findByIdAndPartitionColRange(
                        smsId,
                        timestamp.minusMinutes(1),
                        timestamp.plusMinutes(1)
                    );
                    if (retrieved != null) {
                        System.out.println("  ✓ Immediate retrieval successful for ID: " + smsId);
                    } else {
                        System.out.println("  ✗ Immediate retrieval FAILED for ID: " + smsId);
                    }
                } catch (Exception e) {
                    System.out.println("  ✗ Error during immediate retrieval: " + e.getMessage());
                }
            }

            // Report progress every 10,000 records (10% for 100k)
            if ((i + 1) % 10000 == 0 || i == TOTAL_RECORDS - 1) {
                long currentTime = System.currentTimeMillis();
                long elapsed = currentTime - startTime;
                long intervalTime = currentTime - lastReportTime;
                double overallRate = (i + 1) * 1000.0 / elapsed;
                double intervalRate = 10000.0 * 1000.0 / intervalTime;

                System.out.printf("[INSERTION] Progress: %,d/%,d (%.1f%%) - Overall rate: %,.0f rec/sec - Last 50k rate: %,.0f rec/sec%n",
                    (i + 1), TOTAL_RECORDS, ((i + 1) * 100.0 / TOTAL_RECORDS), overallRate, intervalRate);

                lastReportTime = currentTime;
            }
        }

        long totalTime = System.currentTimeMillis() - startTime;
        double avgRate = TOTAL_RECORDS * 1000.0 / totalTime;

        System.out.println("\n=== Insertion Phase Complete ===");
        System.out.printf("✓ Successfully inserted %,d SMS records in %.2f seconds%n", TOTAL_RECORDS, totalTime / 1000.0);
        System.out.printf("✓ Average insertion rate: %,.0f records/second%n", avgRate);
        System.out.printf("✓ All %,d entities stored in HashMap for verification%n", smsEntityMapRetrieveAll.size());
    }

    @Test
    @Order(2)
    void testVerifyTablesCreated() throws SQLException {
        System.out.println("\n=== Test 2: Verify Daily Tables Creation ===");

        try (Connection conn = connectionProvider.getConnection();
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(
                 "SELECT table_name FROM information_schema.tables " +
                 "WHERE table_schema = '" + TEST_DB + "' AND table_name LIKE 'sms_%' " +
                 "ORDER BY table_name")) {

            System.out.println("\nCreated tables:");
            int tableCount = 0;
            while (rs.next()) {
                System.out.println("  ✓ " + rs.getString(1));
                tableCount++;
            }

            assertTrue(tableCount > 0, "Should have created daily tables");
            System.out.println("\n✓ Verified " + tableCount + " daily tables created");
        }
    }

    @Test
    @Order(3)
    void testRetrieveAllEntitiesWithValidRanges() throws Exception {
        System.out.println("\n=== Test 3: 100% Entity Retrieval with Valid Ranges ===");
        System.out.println("Testing retrieval of ALL " + smsEntityMapRetrieveAll.size() + " entities...");

        // Debug: show first few IDs in the HashMap
        System.out.println("\nFirst 5 IDs in HashMap:");
        int debugCount = 0;
        for (Map.Entry<String, SmsRecord> entry : smsEntityMapRetrieveAll.entrySet()) {
            if (debugCount++ < 5) {
                System.out.println("  " + entry.getKey() + " -> timestamp: " + entry.getValue().getCreatedAt());
            } else {
                break;
            }
        }

        // Look for specific ID we inserted
        if (smsEntityMapRetrieveAll.containsKey("eb5e1851-d09c-471e-be8b-ca83eb9f1e9a")) {
            System.out.println("Found the ID eb5e1851-d09c-471e-be8b-ca83eb9f1e9a in HashMap!");
        } else {
            System.out.println("WARNING: ID eb5e1851-d09c-471e-be8b-ca83eb9f1e9a NOT found in HashMap!");
            System.out.println("HashMap size: " + smsEntityMapRetrieveAll.size());
        }
        System.out.println();

        int successCount = 0;
        int failureCount = 0;
        int progressInterval = 100;

        // Test ALL entities from the HashMap
        List<Map.Entry<String, SmsRecord>> allEntities = new ArrayList<>(smsEntityMapRetrieveAll.entrySet());

        for (int i = 0; i < allEntities.size(); i++) {
            Map.Entry<String, SmsRecord> entry = allEntities.get(i);
            String smsId = entry.getKey();
            SmsRecord expectedSms = entry.getValue();
            LocalDateTime actualDateTime = expectedSms.getCreatedAt();

            // Generate VALID ranges that ALWAYS contain the entity's timestamp
            // Use different offset types for variety
            LocalDateTime startRange, endRange;

            int offsetType = i % 6;
            switch (offsetType) {
                case 0: // ±1 second
                    startRange = actualDateTime.minusSeconds(1);
                    endRange = actualDateTime.plusSeconds(1);
                    break;
                case 1: // ±1 minute
                    startRange = actualDateTime.minusMinutes(1);
                    endRange = actualDateTime.plusMinutes(1);
                    break;
                case 2: // ±5 minutes
                    startRange = actualDateTime.minusMinutes(5);
                    endRange = actualDateTime.plusMinutes(5);
                    break;
                case 3: // ±30 minutes
                    startRange = actualDateTime.minusMinutes(30);
                    endRange = actualDateTime.plusMinutes(30);
                    break;
                case 4: // ±1 hour
                    startRange = actualDateTime.minusHours(1);
                    endRange = actualDateTime.plusHours(1);
                    break;
                default: // ±2 hours
                    startRange = actualDateTime.minusHours(2);
                    endRange = actualDateTime.plusHours(2);
                    break;
            }

            // Ensure ranges don't exceed partition boundaries
            if (maxPartitionDate != null) {
                if (endRange.isAfter(maxPartitionDate)) {
                    endRange = maxPartitionDate;
                }
                // Still ensure the range contains the actual timestamp
                if (startRange.isAfter(actualDateTime)) {
                    startRange = actualDateTime.minusMinutes(1);
                }
                if (endRange.isBefore(actualDateTime)) {
                    endRange = actualDateTime.plusMinutes(1);
                }
            }

            // Retrieve using findByIdAndPartitionColRange
            try {
                // Debug: print first few attempts
                if (i < 5) {
                    System.out.println("DEBUG Retrieve #" + i + ": Searching for ID: " + smsId);
                    System.out.println("  Expected entity exists in HashMap: " + (expectedSms != null));
                    System.out.println("  Actual timestamp: " + actualDateTime);
                    System.out.println("  Search range: " + startRange + " to " + endRange);

                    // Check if this ID was from our inserts
                    if (smsId.equals("f716af58-497d-4ca7-9f53-cf8e266c4d50")) {
                        System.out.println("  *** THIS IS THE ID WE INSERTED FIRST! ***");
                    }
                }

                SmsRecord foundSms = repository.findByIdAndPartitionColRange(smsId, startRange, endRange);

                if (foundSms != null) {
                    // Verify all fields match exactly
                    boolean allFieldsMatch = verifyAllFieldsMatch(expectedSms, foundSms);

                    if (allFieldsMatch) {
                        successCount++;
                    } else {
                        failureCount++;
                        System.err.println("Field mismatch for SMS ID: " + smsId);
                    }
                } else {
                    failureCount++;
                    System.err.println("Failed to retrieve SMS ID: " + smsId +
                                     " (timestamp: " + actualDateTime +
                                     ", range: " + startRange + " to " + endRange + ")");
                }
            } catch (Exception e) {
                failureCount++;
                System.err.println("Error retrieving SMS ID: " + smsId + " - " + e.getMessage());
            }

            // Progress reporting
            if ((i + 1) % progressInterval == 0) {
                System.out.printf("Progress: %d/%d tested (%.1f%% success rate so far)\n",
                    i + 1, allEntities.size(),
                    (successCount * 100.0) / (i + 1));
            }
        }

        // Final results
        System.out.println("\n=== FINAL RESULTS ===");
        System.out.println("Total entities tested: " + allEntities.size());
        System.out.println("Successfully retrieved: " + successCount);
        System.out.println("Failed to retrieve: " + failureCount);

        double successRate = (successCount * 100.0) / allEntities.size();
        System.out.printf("SUCCESS RATE: %.2f%%\n", successRate);

        // Assert 100% success
        assertEquals(allEntities.size(), successCount,
            String.format("Should retrieve ALL entities. Failed to retrieve %d out of %d",
                failureCount, allEntities.size()));

        if (successRate == 100.0) {
            System.out.println("\n🎯 100% SUCCESS RATE ACHIEVED! 🎯");
            System.out.println("All " + TOTAL_RECORDS + " entities retrieved successfully!");
        }
    }

    private boolean verifyAllFieldsMatch(SmsRecord expected, SmsRecord actual) {
        return expected.getId().equals(actual.getId()) &&
               expected.getCreatedAt().equals(actual.getCreatedAt()) &&
               expected.getSenderNumber().equals(actual.getSenderNumber()) &&
               expected.getRecipientNumber().equals(actual.getRecipientNumber()) &&
               expected.getMessageContent().equals(actual.getMessageContent()) &&
               expected.getMessageType().equals(actual.getMessageType()) &&
               expected.getDeliveryStatus().equals(actual.getDeliveryStatus()) &&
               Objects.equals(expected.getMessageLength(), actual.getMessageLength()) &&
               Objects.equals(expected.getRetryCount(), actual.getRetryCount());
    }

    @AfterAll
    static void cleanup() throws Exception {
        System.out.println("\n=== Test Summary ===");
        System.out.println("Database: " + TEST_DB);
        System.out.println("Total records tested: " + smsEntityMapRetrieveAll.size());
        System.out.println("Test goal: 100% retrieval success rate");
        System.out.println("Database retained for inspection");

        // Cleanup resources
        if (connectionProvider != null) {
            connectionProvider.shutdown();
        }
    }
}