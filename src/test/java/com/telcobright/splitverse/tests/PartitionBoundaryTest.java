package com.telcobright.splitverse.tests;

import com.telcobright.core.repository.SplitVerseRepository;
import com.telcobright.splitverse.config.RepositoryMode;
import com.telcobright.splitverse.config.ShardConfig;
import com.telcobright.core.annotation.Table;
import com.telcobright.core.annotation.Id;
import com.telcobright.core.annotation.Column;
import com.telcobright.core.entity.ShardingEntity;
import org.junit.jupiter.api.*;
import java.sql.*;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.time.format.DateTimeFormatter;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;

/**
 * TEST GOALS: Verify MySQL-style partition boundary behavior
 * - Values below minimum range go into the lowest table
 * - Values above maximum range throw an exception
 * - Normal range values work as expected
 *
 * COVERAGE:
 * - Boundary validation in insert operations
 * - Below-minimum value handling
 * - Above-maximum value rejection
 * - Edge cases around partition boundaries
 */
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class PartitionBoundaryTest {
    private static final String TEST_DB = "test_partition_boundary_" + System.currentTimeMillis();
    private static SplitVerseRepository<TestEvent, LocalDateTime> repository;
    private static final DateTimeFormatter DISPLAY_FORMAT = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

    @Table(name = "boundary_events")
    public static class TestEvent implements ShardingEntity<LocalDateTime> {
        @Id(autoGenerated = false)
        private String id;

        @com.telcobright.core.annotation.ShardingKey
        @Column(name = "event_time")
        private LocalDateTime eventTime;

        @Column(name = "description")
        private String description;

        public TestEvent() {}

        public TestEvent(String id, LocalDateTime eventTime, String description) {
            this.id = id;
            this.eventTime = eventTime;
            this.description = description;
        }

        @Override
        public String getId() { return id; }
        @Override
        public void setId(String id) { this.id = id; }
        @Override
        public LocalDateTime getPartitionColValue() { return eventTime; }
        @Override
        public void setPartitionColValue(LocalDateTime value) { this.eventTime = value; }

        public LocalDateTime getEventTime() { return eventTime; }
        public void setEventTime(LocalDateTime time) { this.eventTime = time; }
        public String getDescription() { return description; }
        public void setDescription(String desc) { this.description = desc; }
    }

    @BeforeAll
    static void setup() throws Exception {
        System.out.println("\n=== Partition Boundary Test ===");
        System.out.println("Testing MySQL-style partition boundary behavior");

        // Create test database
        try (Connection conn = DriverManager.getConnection(
                "jdbc:mysql://127.0.0.1:3306", "root", "123456");
             Statement stmt = conn.createStatement()) {
            stmt.executeUpdate("CREATE DATABASE IF NOT EXISTS " + TEST_DB);
            System.out.println("Created test database: " + TEST_DB);
        }

        // Build repository with 7-day retention (creates tables for ±7 days from now)
        ShardConfig shardConfig = ShardConfig.builder()
            .shardId("primary")
            .host("127.0.0.1")
            .port(3306)
            .database(TEST_DB)
            .username("root")
            .password("123456")
            .enabled(true)
            .build();

        repository = SplitVerseRepository.<TestEvent, LocalDateTime>builder()
            .withSingleShard(shardConfig)
            .withEntityClass(TestEvent.class)
            .withRepositoryMode(RepositoryMode.MULTI_TABLE)
            .withRetentionDays(7)  // ±7 days from now
            .build();

        System.out.println("Repository configured with ±7 day retention period");
    }

    @Test
    @Order(1)
    void testNormalRangeInsert() throws Exception {
        System.out.println("\n1. Testing insert within normal partition range:");

        LocalDateTime now = LocalDateTime.now();
        TestEvent event = new TestEvent(
            UUID.randomUUID().toString(),
            now,
            "Normal range event"
        );

        repository.insert(event);
        TestEvent found = repository.findById(event.getId());

        assertNotNull(found, "Should find event inserted within normal range");
        assertEquals(event.getId(), found.getId());
        System.out.println("  ✓ Successfully inserted event at current time");
    }

    @Test
    @Order(2)
    void testBelowMinimumRangeInsert() throws Exception {
        System.out.println("\n2. Testing insert below minimum partition range:");

        // Try to insert an event 30 days in the past (well below the 7-day retention)
        LocalDateTime pastDate = LocalDateTime.now().minusDays(30);
        TestEvent event = new TestEvent(
            UUID.randomUUID().toString(),
            pastDate,
            "Very old event"
        );

        System.out.printf("  Inserting event from %s (30 days ago)\n",
            pastDate.format(DISPLAY_FORMAT));

        // This should succeed - value should go into the minimum table
        repository.insert(event);
        TestEvent found = repository.findById(event.getId());

        assertNotNull(found, "Should find event inserted below minimum range");
        assertEquals(event.getId(), found.getId());

        // The event time should remain unchanged (compare at second precision to avoid MySQL rounding issues)
        assertEquals(pastDate.truncatedTo(ChronoUnit.SECONDS),
            found.getEventTime().truncatedTo(ChronoUnit.SECONDS),
            "Event time should be preserved even when inserted into minimum table");

        System.out.println("  ✓ Successfully inserted old event into minimum partition table");
    }

    @Test
    @Order(3)
    void testAboveMaximumRangeInsert() throws Exception {
        System.out.println("\n3. Testing insert above maximum partition range:");

        // Try to insert an event 30 days in the future (well beyond the 7-day retention)
        LocalDateTime futureDate = LocalDateTime.now().plusDays(30);
        TestEvent event = new TestEvent(
            UUID.randomUUID().toString(),
            futureDate,
            "Far future event"
        );

        System.out.printf("  Attempting to insert event at %s (30 days in future)\n",
            futureDate.format(DISPLAY_FORMAT));

        // This should throw an exception
        SQLException exception = assertThrows(SQLException.class, () -> {
            repository.insert(event);
        });

        assertTrue(exception.getMessage().contains("beyond maximum partition boundary"),
            "Exception message should indicate partition boundary violation");

        System.out.println("  ✓ Correctly rejected event beyond maximum partition boundary");
        System.out.println("  Exception: " + exception.getMessage());
    }

    @Test
    @Order(4)
    void testEdgeCases() throws Exception {
        System.out.println("\n4. Testing edge cases at partition boundaries:");

        LocalDateTime now = LocalDateTime.now();

        // Test close to retention boundary (but not beyond)
        LocalDateTime edgeDate = now.plusDays(6).plusHours(23);
        TestEvent edgeEvent = new TestEvent(
            UUID.randomUUID().toString(),
            edgeDate,
            "Edge case event"
        );

        System.out.printf("  Inserting event near retention edge: %s\n",
            edgeDate.format(DISPLAY_FORMAT));

        repository.insert(edgeEvent);
        TestEvent found = repository.findById(edgeEvent.getId());
        assertNotNull(found, "Should find event near retention boundary");
        System.out.println("  ✓ Successfully inserted event near retention boundary");

        // Test beyond retention boundary (should fail)
        LocalDateTime beyondDate = now.plusDays(8);
        TestEvent beyondEvent = new TestEvent(
            UUID.randomUUID().toString(),
            beyondDate,
            "Just beyond boundary"
        );

        System.out.printf("  Attempting insert just beyond boundary: %s\n",
            beyondDate.format(DISPLAY_FORMAT));

        SQLException exception = assertThrows(SQLException.class, () -> {
            repository.insert(beyondEvent);
        });

        assertTrue(exception.getMessage().contains("beyond maximum partition boundary"));
        System.out.println("  ✓ Correctly rejected event just beyond boundary");
    }

    @Test
    @Order(5)
    void testMultipleOldEvents() throws Exception {
        System.out.println("\n5. Testing multiple below-minimum events:");

        // Insert multiple events with different past dates
        // All should go into the same minimum table
        LocalDateTime[] pastDates = {
            LocalDateTime.now().minusDays(10),
            LocalDateTime.now().minusDays(20),
            LocalDateTime.now().minusDays(50),
            LocalDateTime.now().minusYears(1)
        };

        for (LocalDateTime pastDate : pastDates) {
            TestEvent event = new TestEvent(
                UUID.randomUUID().toString(),
                pastDate,
                "Old event from " + pastDate.toLocalDate()
            );

            repository.insert(event);
            TestEvent found = repository.findById(event.getId());

            assertNotNull(found, "Should find old event from " + pastDate);
            assertEquals(pastDate.truncatedTo(ChronoUnit.SECONDS),
                found.getEventTime().truncatedTo(ChronoUnit.SECONDS),
                "Event time should be preserved");
        }

        System.out.println("  ✓ Successfully inserted multiple old events into minimum partition");
        System.out.println("  All events preserved their original timestamps");
    }

    @AfterAll
    static void cleanup() throws Exception {
        System.out.println("\n=== Cleanup ===");

        if (repository != null) {
            repository.shutdown();
            System.out.println("Repository shut down");
        }

        // Drop test database
        try (Connection conn = DriverManager.getConnection(
                "jdbc:mysql://127.0.0.1:3306", "root", "123456");
             Statement stmt = conn.createStatement()) {
            stmt.executeUpdate("DROP DATABASE IF EXISTS " + TEST_DB);
            System.out.println("Test database dropped: " + TEST_DB);
        }

        System.out.println("✓ Cleanup complete");
    }
}