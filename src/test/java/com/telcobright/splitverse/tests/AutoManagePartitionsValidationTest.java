package com.telcobright.splitverse.tests;

import com.telcobright.core.annotation.Column;
import com.telcobright.core.annotation.Id;
import com.telcobright.core.annotation.ShardingKey;
import com.telcobright.core.annotation.Table;
import com.telcobright.core.entity.ShardingEntity;
import com.telcobright.core.repository.GenericMultiTableRepository;
import com.telcobright.core.repository.GenericPartitionedTableRepository;
import org.junit.jupiter.api.*;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.time.LocalDateTime;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Comprehensive test suite for autoManagePartitions configuration.
 * Tests both GenericPartitionedTableRepository and GenericMultiTableRepository
 * with various configurations and scenarios.
 */
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class AutoManagePartitionsValidationTest {

    private static final String DB_URL = "jdbc:mysql://127.0.0.1:3306/testdb";
    private static final String DB_USER = "root";
    private static final String DB_PASSWORD = "123456";
    private static final String TEST_DB = "testdb";

    private Connection connection;

    @Table(name = "auto_test_events")
    public static class AutoTestEvent implements ShardingEntity<LocalDateTime> {
        @Id(autoGenerated = false)
        @Column(name = "event_id")
        private String eventId;

        @ShardingKey
        @Column(name = "event_time")
        private LocalDateTime eventTime;

        @Column(name = "event_data")
        private String eventData;

        public AutoTestEvent() {}

        public AutoTestEvent(String eventId, LocalDateTime eventTime, String eventData) {
            this.eventId = eventId;
            this.eventTime = eventTime;
            this.eventData = eventData;
        }

        @Override
        public String getId() { return eventId; }
        @Override
        public void setId(String id) { this.eventId = id; }
        @Override
        public LocalDateTime getPartitionColValue() { return eventTime; }
        @Override
        public void setPartitionColValue(LocalDateTime value) { this.eventTime = value; }

        public String getEventId() { return eventId; }
        public void setEventId(String eventId) { this.eventId = eventId; }
        public LocalDateTime getEventTime() { return eventTime; }
        public void setEventTime(LocalDateTime eventTime) { this.eventTime = eventTime; }
        public String getEventData() { return eventData; }
        public void setEventData(String eventData) { this.eventData = eventData; }
    }

    @BeforeEach
    public void setup() throws Exception {
        // Ensure database exists
        try (Connection rootConn = DriverManager.getConnection(
                "jdbc:mysql://127.0.0.1:3306", DB_USER, DB_PASSWORD);
             Statement stmt = rootConn.createStatement()) {
            stmt.executeUpdate("CREATE DATABASE IF NOT EXISTS " + TEST_DB);
        }

        connection = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);
        cleanupAllTestTables();
    }

    @AfterEach
    public void tearDown() throws Exception {
        cleanupAllTestTables();
        if (connection != null && !connection.isClosed()) {
            connection.close();
        }
    }

    private void cleanupAllTestTables() {
        try (Statement stmt = connection.createStatement()) {
            // Drop partitioned table
            stmt.executeUpdate("DROP TABLE IF EXISTS auto_test_events");

            // Drop multi-table pattern tables
            ResultSet rs = stmt.executeQuery(
                "SELECT TABLE_NAME FROM information_schema.TABLES " +
                "WHERE TABLE_SCHEMA = '" + TEST_DB + "' AND TABLE_NAME LIKE 'auto_multi_%'"
            );
            while (rs.next()) {
                String tableName = rs.getString("TABLE_NAME");
                stmt.executeUpdate("DROP TABLE IF EXISTS " + tableName);
            }
        } catch (Exception e) {
            System.err.println("Cleanup error: " + e.getMessage());
        }
    }

    // ==================== GenericPartitionedTableRepository Tests ====================

    @Test
    @Order(1)
    @DisplayName("Partitioned Repo: autoManagePartitions=true creates table automatically")
    public void testPartitionedAutoManagementEnabled() throws Exception {
        System.out.println("\n=== Test 1: Partitioned Repository with Auto-Management Enabled ===");

        GenericPartitionedTableRepository<AutoTestEvent, LocalDateTime> repository =
            GenericPartitionedTableRepository.<AutoTestEvent, LocalDateTime>builder(AutoTestEvent.class)
                .host("127.0.0.1")
                .port(3306)
                .database(TEST_DB)
                .username(DB_USER)
                .password(DB_PASSWORD)
                .tableName("auto_test_events")
                .partitionRetentionPeriod(7)
                .autoManagePartitions(true)  // Explicitly enable (though it's default)
                .build();

        // Verify table was created
        assertTrue(tableExists("auto_test_events"), "Table should be created automatically");

        // Verify partitions were created
        int partitionCount = getPartitionCount("auto_test_events");
        assertTrue(partitionCount > 0, "Partitions should be created automatically");
        System.out.println("✓ Table and " + partitionCount + " partitions created automatically");

        // Test insert operation
        AutoTestEvent event = new AutoTestEvent(
            UUID.randomUUID().toString(),
            LocalDateTime.now(),
            "Test data"
        );
        repository.insert(event);
        System.out.println("✓ Insert operation successful with auto-management");
    }

    @Test
    @Order(2)
    @DisplayName("Partitioned Repo: autoManagePartitions=false with existing table succeeds")
    public void testPartitionedManualManagementWithExistingTable() throws Exception {
        System.out.println("\n=== Test 2: Partitioned Repository with Manual Management (Table Exists) ===");

        // Pre-create the table and partitions manually
        createPartitionedTable();

        GenericPartitionedTableRepository<AutoTestEvent, LocalDateTime> repository =
            GenericPartitionedTableRepository.<AutoTestEvent, LocalDateTime>builder(AutoTestEvent.class)
                .host("127.0.0.1")
                .port(3306)
                .database(TEST_DB)
                .username(DB_USER)
                .password(DB_PASSWORD)
                .tableName("auto_test_events")
                .partitionRetentionPeriod(7)  // Should be ignored
                .autoManagePartitions(false)  // Disable auto-management
                .build();

        // Verify table exists (was not dropped/recreated)
        assertTrue(tableExists("auto_test_events"), "Table should exist");
        System.out.println("✓ Repository initialized with existing table");

        // Test insert operation
        AutoTestEvent event = new AutoTestEvent(
            UUID.randomUUID().toString(),
            LocalDateTime.now(),
            "Manual management test"
        );
        repository.insert(event);
        System.out.println("✓ Insert operation successful with manual management");
    }

    @Test
    @Order(3)
    @DisplayName("Partitioned Repo: autoManagePartitions=false without table fails")
    public void testPartitionedManualManagementWithoutTable() {
        System.out.println("\n=== Test 3: Partitioned Repository with Manual Management (No Table) ===");

        // Ensure table doesn't exist
        assertFalse(tableExists("auto_test_events"), "Table should not exist initially");

        // Attempt to create repository with autoManagePartitions=false
        Exception exception = assertThrows(RuntimeException.class, () -> {
            GenericPartitionedTableRepository.<AutoTestEvent, LocalDateTime>builder(AutoTestEvent.class)
                .host("127.0.0.1")
                .port(3306)
                .database(TEST_DB)
                .username(DB_USER)
                .password(DB_PASSWORD)
                .tableName("auto_test_events")
                .autoManagePartitions(false)
                .build();
        });

        String message = exception.getMessage();
        assertTrue(message.contains("autoManagePartitions=false"),
            "Error message should mention autoManagePartitions configuration");
        assertTrue(message.contains("must already exist") || message.contains("must be created manually"),
            "Error message should explain manual creation requirement");
        System.out.println("✓ Repository initialization failed as expected");
        System.out.println("  Error: " + message);
    }

    // ==================== GenericMultiTableRepository Tests ====================

    @Test
    @Order(4)
    @DisplayName("MultiTable Repo: autoManagePartitions=true creates tables automatically")
    public void testMultiTableAutoManagementEnabled() throws Exception {
        System.out.println("\n=== Test 4: Multi-Table Repository with Auto-Management Enabled ===");

        GenericMultiTableRepository<AutoTestEvent, LocalDateTime> repository =
            GenericMultiTableRepository.<AutoTestEvent, LocalDateTime>builder(AutoTestEvent.class)
                .host("127.0.0.1")
                .port(3306)
                .database(TEST_DB)
                .username(DB_USER)
                .password(DB_PASSWORD)
                .tablePrefix("auto_multi")
                .partitionRetentionPeriod(3)
                .autoManagePartitions(true)  // Enable auto-management
                .build();

        // Verify tables were created
        int tableCount = getTableCount("auto_multi");
        assertTrue(tableCount > 0, "Tables should be created automatically");
        System.out.println("✓ " + tableCount + " tables created automatically");

        // Test insert operation
        AutoTestEvent event = new AutoTestEvent(
            UUID.randomUUID().toString(),
            LocalDateTime.now(),
            "Multi-table test"
        );
        repository.insert(event);
        System.out.println("✓ Insert operation successful with auto-management");
    }

    @Test
    @Order(5)
    @DisplayName("MultiTable Repo: autoManagePartitions=false with existing tables succeeds")
    public void testMultiTableManualManagementWithExistingTables() throws Exception {
        System.out.println("\n=== Test 5: Multi-Table Repository with Manual Management (Tables Exist) ===");

        // Pre-create some tables manually
        createMultiTables("auto_multi", 3);
        int initialCount = getTableCount("auto_multi");
        System.out.println("Pre-created " + initialCount + " tables");

        GenericMultiTableRepository<AutoTestEvent, LocalDateTime> repository =
            GenericMultiTableRepository.<AutoTestEvent, LocalDateTime>builder(AutoTestEvent.class)
                .host("127.0.0.1")
                .port(3306)
                .database(TEST_DB)
                .username(DB_USER)
                .password(DB_PASSWORD)
                .tablePrefix("auto_multi")
                .partitionRetentionPeriod(30)  // Should be ignored
                .autoManagePartitions(false)  // Disable auto-management
                .build();

        // Verify no new tables were created
        int afterCount = getTableCount("auto_multi");
        assertEquals(initialCount, afterCount, "No new tables should be created");
        System.out.println("✓ Repository initialized with existing tables");

        // Test insert into existing table
        AutoTestEvent event = new AutoTestEvent(
            UUID.randomUUID().toString(),
            LocalDateTime.now(),
            "Manual multi-table test"
        );
        repository.insert(event);
        System.out.println("✓ Insert operation successful with manual management");
    }

    @Test
    @Order(6)
    @DisplayName("MultiTable Repo: autoManagePartitions=false without tables fails")
    public void testMultiTableManualManagementWithoutTables() {
        System.out.println("\n=== Test 6: Multi-Table Repository with Manual Management (No Tables) ===");

        // Ensure no tables exist
        assertEquals(0, getTableCount("auto_multi"), "No tables should exist initially");

        // Attempt to create repository with autoManagePartitions=false
        Exception exception = assertThrows(RuntimeException.class, () -> {
            GenericMultiTableRepository.<AutoTestEvent, LocalDateTime>builder(AutoTestEvent.class)
                .host("127.0.0.1")
                .port(3306)
                .database(TEST_DB)
                .username(DB_USER)
                .password(DB_PASSWORD)
                .tablePrefix("auto_multi")
                .autoManagePartitions(false)
                .build();
        });

        String message = exception.getMessage();
        assertTrue(message.contains("autoManagePartitions=false"),
            "Error message should mention autoManagePartitions configuration");
        assertTrue(message.contains("No existing tables found") || message.contains("must be created manually"),
            "Error message should explain the problem");
        System.out.println("✓ Repository initialization failed as expected");
        System.out.println("  Error: " + message);
    }

    @Test
    @Order(7)
    @DisplayName("Verify retention period is ignored when autoManagePartitions=false")
    public void testRetentionIgnoredWithManualManagement() throws Exception {
        System.out.println("\n=== Test 7: Retention Period Ignored with Manual Management ===");

        // Create tables for dates beyond retention period
        LocalDateTime now = LocalDateTime.now();
        for (int i = -10; i <= -8; i++) {
            createTableForDate("auto_multi", now.plusDays(i));
        }
        int initialCount = getTableCount("auto_multi");
        System.out.println("Created " + initialCount + " old tables (beyond retention)");

        // Create repository with short retention but manual management
        GenericMultiTableRepository<AutoTestEvent, LocalDateTime> repository =
            GenericMultiTableRepository.<AutoTestEvent, LocalDateTime>builder(AutoTestEvent.class)
                .host("127.0.0.1")
                .port(3306)
                .database(TEST_DB)
                .username(DB_USER)
                .password(DB_PASSWORD)
                .tablePrefix("auto_multi")
                .partitionRetentionPeriod(1)  // Very short retention
                .autoManagePartitions(false)  // But manual management
                .build();

        // Wait a moment for any potential cleanup (which shouldn't happen)
        Thread.sleep(1000);

        // Verify old tables still exist
        int afterCount = getTableCount("auto_multi");
        assertEquals(initialCount, afterCount,
            "Old tables should NOT be dropped when autoManagePartitions=false");
        System.out.println("✓ Old tables retained despite short retention period");
    }

    // ==================== Helper Methods ====================

    private boolean tableExists(String tableName) {
        try (Statement stmt = connection.createStatement();
             ResultSet rs = stmt.executeQuery(
                 "SELECT COUNT(*) FROM information_schema.TABLES " +
                 "WHERE TABLE_SCHEMA = '" + TEST_DB + "' AND TABLE_NAME = '" + tableName + "'")) {
            return rs.next() && rs.getInt(1) > 0;
        } catch (Exception e) {
            return false;
        }
    }

    private int getPartitionCount(String tableName) {
        try (Statement stmt = connection.createStatement();
             ResultSet rs = stmt.executeQuery(
                 "SELECT COUNT(*) FROM information_schema.PARTITIONS " +
                 "WHERE TABLE_SCHEMA = '" + TEST_DB + "' AND TABLE_NAME = '" + tableName + "' " +
                 "AND PARTITION_NAME IS NOT NULL")) {
            return rs.next() ? rs.getInt(1) : 0;
        } catch (Exception e) {
            return 0;
        }
    }

    private int getTableCount(String prefix) {
        try (Statement stmt = connection.createStatement();
             ResultSet rs = stmt.executeQuery(
                 "SELECT COUNT(*) FROM information_schema.TABLES " +
                 "WHERE TABLE_SCHEMA = '" + TEST_DB + "' AND TABLE_NAME LIKE '" + prefix + "_%'")) {
            return rs.next() ? rs.getInt(1) : 0;
        } catch (Exception e) {
            return 0;
        }
    }

    private void createPartitionedTable() throws Exception {
        LocalDateTime now = LocalDateTime.now();
        try (Statement stmt = connection.createStatement()) {
            String sql = "CREATE TABLE IF NOT EXISTS auto_test_events (" +
                "event_id VARCHAR(255), " +
                "event_time DATETIME, " +
                "event_data VARCHAR(255), " +
                "PRIMARY KEY (event_id, event_time), " +
                "KEY idx_event_time (event_time)" +
                ") ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin " +
                "PARTITION BY RANGE (TO_DAYS(event_time)) (" +
                "PARTITION p" + now.toLocalDate().toString().replace("-", "") +
                " VALUES LESS THAN (TO_DAYS('" + now.plusDays(1).toLocalDate() + "')), " +
                "PARTITION p" + now.plusDays(1).toLocalDate().toString().replace("-", "") +
                " VALUES LESS THAN (TO_DAYS('" + now.plusDays(2).toLocalDate() + "'))" +
                ")";
            stmt.executeUpdate(sql);
        }
    }

    private void createMultiTables(String prefix, int count) throws Exception {
        LocalDateTime now = LocalDateTime.now();
        for (int i = 0; i < count; i++) {
            createTableForDate(prefix, now.minusDays(i));
        }
    }

    private void createTableForDate(String prefix, LocalDateTime date) throws Exception {
        String tableName = prefix + "_" + date.toLocalDate().toString().replace("-", "");
        try (Statement stmt = connection.createStatement()) {
            String sql = "CREATE TABLE IF NOT EXISTS " + tableName + " (" +
                "event_id VARCHAR(255), " +
                "event_time DATETIME, " +
                "event_data VARCHAR(255), " +
                "PRIMARY KEY (event_id), " +
                "KEY idx_event_time (event_time)" +
                ") ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin";
            stmt.executeUpdate(sql);
        }
    }
}