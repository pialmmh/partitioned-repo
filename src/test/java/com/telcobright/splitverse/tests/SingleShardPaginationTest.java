package com.telcobright.splitverse.tests;

import com.telcobright.core.repository.SplitVerseRepository;
import com.telcobright.splitverse.config.ShardConfig;
import com.telcobright.splitverse.config.RepositoryMode;
import com.telcobright.core.entity.ShardingEntity;
import com.telcobright.core.annotation.*;

import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;
import java.time.LocalDateTime;
import java.util.*;

/**
 * Test single-shard pagination optimization
 */
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class SingleShardPaginationTest {

    private static SplitVerseRepository<TestEntity, LocalDateTime> repository;
    private static final String TEST_DB = "test_single_pagination_" + System.currentTimeMillis();

    @Table(name = "test_entity")
    public static class TestEntity implements ShardingEntity<LocalDateTime> {
        @Id(autoGenerated = false)
        @Column(name = "id")
        private String id;

        @Column(name = "name")
        private String name;

        @ShardingKey
        @Column(name = "created_at")
        private LocalDateTime createdAt;

        @Column(name = "sequence")
        private Integer sequence;

        public TestEntity() {}

        public TestEntity(int sequence) {
            // Create IDs that sort properly: TEST_00001, TEST_00002, etc.
            this.id = String.format("TEST_%05d", sequence);
            this.name = "Entity " + sequence;
            this.createdAt = LocalDateTime.now().minusHours(1000 - sequence); // Older entities have lower sequence
            this.sequence = sequence;
        }

        @Override
        public String getId() { return id; }
        @Override
        public void setId(String id) { this.id = id; }
        @Override
        public LocalDateTime getPartitionColValue() { return createdAt; }
        @Override
        public void setPartitionColValue(LocalDateTime value) { this.createdAt = value; }

        public String getName() { return name; }
        public void setName(String name) { this.name = name; }
        public LocalDateTime getCreatedAt() { return createdAt; }
        public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
        public Integer getSequence() { return sequence; }
        public void setSequence(Integer sequence) { this.sequence = sequence; }
    }

    @BeforeAll
    static void setup() throws Exception {
        System.out.println("\n=== Single Shard Pagination Test ===");

        // Create test database
        try (Connection conn = DriverManager.getConnection(
                "jdbc:mysql://127.0.0.1:3306", "root", "123456");
             Statement stmt = conn.createStatement()) {
            stmt.executeUpdate("CREATE DATABASE IF NOT EXISTS " + TEST_DB);
        }

        // Configure single shard
        ShardConfig shardConfig = ShardConfig.builder()
            .shardId("primary")
            .host("127.0.0.1")
            .port(3306)
            .database(TEST_DB)
            .username("root")
            .password("123456")
            .enabled(true)
            .build();

        repository = SplitVerseRepository.<TestEntity, LocalDateTime>builder()
            .withSingleShard(shardConfig)
            .withEntityClass(TestEntity.class)
            .withRepositoryMode(RepositoryMode.MULTI_TABLE)
            .build();

        // Insert test data
        System.out.println("Inserting test data...");
        for (int i = 1; i <= 500; i++) {
            repository.insert(new TestEntity(i));
        }
        System.out.println("Inserted 500 test entities");
    }

    @Test
    @Order(1)
    void testBasicPagination() throws Exception {
        System.out.println("\n1. Testing basic pagination:");

        String cursor = "TEST_00000"; // Start from beginning
        int pageSize = 50;
        int totalFetched = 0;
        int pageCount = 0;

        while (totalFetched < 200) { // Fetch first 200 records in pages of 50
            List<TestEntity> page = repository.findBatchByIdGreaterThan(cursor, pageSize);

            if (page.isEmpty()) {
                break;
            }

            pageCount++;
            totalFetched += page.size();
            cursor = page.get(page.size() - 1).getId(); // Update cursor to last ID

            System.out.printf("  Page %d: Fetched %d records (IDs: %s to %s)\n",
                pageCount, page.size(),
                page.get(0).getId(),
                page.get(page.size() - 1).getId());

            // Verify ordering
            for (int i = 1; i < page.size(); i++) {
                String prevId = page.get(i - 1).getId();
                String currId = page.get(i).getId();
                assertTrue(prevId.compareTo(currId) < 0,
                    "IDs should be in ascending order");
            }
        }

        assertEquals(4, pageCount, "Should have 4 pages of 50 records");
        assertEquals(200, totalFetched, "Should fetch exactly 200 records");
        System.out.println("  ✓ Basic pagination working correctly");
    }

    @Test
    @Order(2)
    void testPaginationWithGaps() throws Exception {
        System.out.println("\n2. Testing pagination with gaps:");

        // Delete some records to create gaps
        for (int i = 100; i <= 150; i += 5) {
            repository.deleteById(String.format("TEST_%05d", i));
        }
        System.out.println("  Deleted 11 records to create gaps");

        // Now paginate through
        String cursor = "TEST_00095";
        List<TestEntity> page = repository.findBatchByIdGreaterThan(cursor, 20);

        System.out.printf("  Fetched %d records after TEST_00095\n", page.size());
        assertEquals(20, page.size(), "Should fetch exactly 20 records despite gaps");

        // Verify we skip the deleted records
        for (TestEntity entity : page) {
            int sequence = entity.getSequence();
            assertFalse(sequence >= 100 && sequence <= 150 && sequence % 5 == 0,
                "Should not include deleted records");
        }

        System.out.println("  ✓ Pagination handles gaps correctly");
    }

    @Test
    @Order(3)
    void testPaginationAcrossTables() throws Exception {
        System.out.println("\n3. Testing pagination across multiple daily tables:");

        // Insert entities across different days
        LocalDateTime now = LocalDateTime.now();
        for (int day = 0; day < 3; day++) {
            for (int i = 1; i <= 10; i++) {
                TestEntity entity = new TestEntity(1000 + day * 10 + i);
                entity.setCreatedAt(now.minusDays(day));
                repository.insert(entity);
            }
        }
        System.out.println("  Inserted 30 entities across 3 days");

        // Paginate through them
        String cursor = "TEST_00999";
        List<TestEntity> page = repository.findBatchByIdGreaterThan(cursor, 25);

        System.out.printf("  Fetched %d records across multiple tables\n", page.size());
        assertTrue(page.size() >= 25, "Should fetch at least 25 records");

        // Verify ordering across tables
        for (int i = 1; i < page.size(); i++) {
            String prevId = page.get(i - 1).getId();
            String currId = page.get(i).getId();
            assertTrue(prevId.compareTo(currId) < 0,
                "IDs should be ordered even across tables");
        }

        System.out.println("  ✓ Pagination works across multiple tables");
    }

    @Test
    @Order(4)
    void testFindNextById() throws Exception {
        System.out.println("\n4. Testing findNextById (single record):");

        TestEntity next = repository.findOneByIdGreaterThan("TEST_00250");
        assertNotNull(next, "Should find next entity");

        // Should be TEST_00251 unless it was deleted
        System.out.println("  Found next entity: " + next.getId());
        assertTrue(next.getId().compareTo("TEST_00250") > 0,
            "Next ID should be greater than TEST_00250");

        System.out.println("  ✓ findNextById works correctly");
    }

    @Test
    @Order(5)
    void testEmptyResults() throws Exception {
        System.out.println("\n5. Testing pagination with no results:");

        // Query beyond last record
        List<TestEntity> page = repository.findBatchByIdGreaterThan("TEST_99999", 10);
        assertTrue(page.isEmpty(), "Should return empty list for cursor beyond data");

        TestEntity next = repository.findOneByIdGreaterThan("TEST_99999");
        assertNull(next, "Should return null when no next record exists");

        System.out.println("  ✓ Empty result handling works correctly");
    }

    @AfterAll
    static void cleanup() throws Exception {
        System.out.println("\n=== Cleanup ===");

        if (repository != null) {
            repository.shutdown();
        }

        // Drop test database
        try (Connection conn = DriverManager.getConnection(
                "jdbc:mysql://127.0.0.1:3306", "root", "123456");
             Statement stmt = conn.createStatement()) {
            stmt.executeUpdate("DROP DATABASE IF EXISTS " + TEST_DB);
        }

        System.out.println("✓ Cleanup complete");
    }
}