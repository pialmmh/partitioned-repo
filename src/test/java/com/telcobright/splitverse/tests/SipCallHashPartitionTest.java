package com.telcobright.splitverse.tests;

import com.telcobright.core.repository.SplitVerseRepository;
import com.telcobright.splitverse.config.RepositoryMode;
import com.telcobright.splitverse.config.ShardConfig;
import com.telcobright.core.annotation.Table;
import com.telcobright.core.annotation.Id;
import com.telcobright.core.annotation.Column;
import com.telcobright.core.annotation.Index;
import com.telcobright.core.entity.ShardingEntity;
import org.junit.jupiter.api.*;
import java.sql.*;
import java.time.LocalDateTime;
import java.util.*;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Test Scenario:
 * - Track SIP call state with callid
 * - No dated or range partitioning, all hash based
 * - Shard based on hash, test with one shard only for now
 * - 2nd level partitioning in native-partition (NOT multi-table), partition based on hash
 * - dbname: sipcall_shard_01
 * - Insert a thousand records
 * - Retrieving records and verify count from db which table
 * - If possible, make advanced query to db to find out if record got inserted to right partition, by hash
 */
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class SipCallHashPartitionTest {
    private static final String TEST_DB = "sipcall_shard_01";
    private static SplitVerseRepository<SipCallRecord, String> repository;
    private static final int TOTAL_RECORDS = 1000;
    private static final int PARTITION_COUNT = 16; // Number of hash partitions
    private static final Random random = new Random();

    @Table(name = "sip_calls")
    public static class SipCallRecord implements ShardingEntity<String> {
        @Id(autoGenerated = false)
        @com.telcobright.core.annotation.ShardingKey  // Use callId as both ID and sharding key
        private String callId;

        @Column(name = "call_state")
        private String callState;

        @Column(name = "from_uri")
        private String fromUri;

        @Column(name = "to_uri")
        private String toUri;

        @Column(name = "start_time")
        private LocalDateTime startTime;

        @Column(name = "end_time")
        private LocalDateTime endTime;

        @Column(name = "duration_seconds")
        private Integer durationSeconds;

        public SipCallRecord() {}

        public SipCallRecord(String callId, String callState, String fromUri, String toUri,
                            LocalDateTime startTime, LocalDateTime endTime, Integer durationSeconds) {
            this.callId = callId;
            this.callState = callState;
            this.fromUri = fromUri;
            this.toUri = toUri;
            this.startTime = startTime;
            this.endTime = endTime;
            this.durationSeconds = durationSeconds;
        }

        @Override
        public String getId() { return callId; }
        @Override
        public void setId(String id) { this.callId = id; }
        @Override
        public String getPartitionColValue() { return callId; }
        @Override
        public void setPartitionColValue(String value) { this.callId = value; }

        // Getters and setters
        public String getCallId() { return callId; }
        public void setCallId(String callId) { this.callId = callId; }
        public String getCallState() { return callState; }
        public void setCallState(String state) { this.callState = state; }
        public String getFromUri() { return fromUri; }
        public void setFromUri(String uri) { this.fromUri = uri; }
        public String getToUri() { return toUri; }
        public void setToUri(String uri) { this.toUri = uri; }
        public LocalDateTime getStartTime() { return startTime; }
        public void setStartTime(LocalDateTime time) { this.startTime = time; }
        public LocalDateTime getEndTime() { return endTime; }
        public void setEndTime(LocalDateTime time) { this.endTime = time; }
        public Integer getDurationSeconds() { return durationSeconds; }
        public void setDurationSeconds(Integer seconds) { this.durationSeconds = seconds; }
    }

    private static void createPartitionedTable() throws SQLException {
        // Drop and recreate table with hash partitions
        String dropTable = "DROP TABLE IF EXISTS " + TEST_DB + ".sip_calls";

        String createTable = """
            CREATE TABLE %s.sip_calls (
              call_id VARCHAR(255) NOT NULL,
              call_state VARCHAR(255),
              from_uri VARCHAR(255),
              to_uri VARCHAR(255),
              start_time DATETIME,
              end_time DATETIME,
              duration_seconds INT,
              PRIMARY KEY (call_id)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin
            PARTITION BY KEY(call_id)
            PARTITIONS %d
            """.formatted(TEST_DB, PARTITION_COUNT);

        try (Connection conn = DriverManager.getConnection(
                "jdbc:mysql://127.0.0.1:3306/" + TEST_DB + "?useSSL=false&serverTimezone=UTC",
                "root", "123456");
             Statement stmt = conn.createStatement()) {

            stmt.execute(dropTable);
            stmt.execute(createTable);
            System.out.println("✓ Created table with " + PARTITION_COUNT + " hash partitions");
        }
    }

    @BeforeAll
    static void setup() throws Exception {
        System.out.println("\n=== SIP Call Hash Partition Test Setup ===");
        System.out.println("Database: " + TEST_DB);
        System.out.println("Mode: Native partitioning (single table with hash partitions)");
        System.out.println("Partitions: " + PARTITION_COUNT + " hash partitions");

        // Create test database
        try (Connection conn = DriverManager.getConnection(
                "jdbc:mysql://127.0.0.1:3306?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=UTC",
                "root", "123456");
             Statement stmt = conn.createStatement()) {
            stmt.execute("DROP DATABASE IF EXISTS " + TEST_DB);
            stmt.execute("CREATE DATABASE " + TEST_DB);
            System.out.println("✓ Database created");
        }

        // Configure shard
        ShardConfig shardConfig = ShardConfig.builder()
            .shardId("shard_01")
            .database(TEST_DB)
            .host("127.0.0.1")
            .port(3306)
            .username("root")
            .password("123456")
            .enabled(true)
            .build();

        // First manually create the table with hash partitioning
        createPartitionedTable();

        // Build repository with PARTITIONED mode
        // The table already exists with the partitions we want
        repository = SplitVerseRepository.<SipCallRecord, String>builder()
            .withSingleShard(shardConfig)
            .withEntityClass(SipCallRecord.class)
            .withRepositoryMode(RepositoryMode.PARTITIONED)  // Use partitioned mode
            .withPartitionType(com.telcobright.core.partition.PartitionType.DATE_BASED) // Required but won't affect existing table
            .build();

        System.out.println("✓ Repository configured with " + PARTITION_COUNT + " hash partitions");
    }

    @Test
    @Order(1)
    void testInsertThousandRecords() throws Exception {
        System.out.println("\n=== Test 1: Insert 1000 SIP Call Records ===");

        List<SipCallRecord> allCalls = new ArrayList<>();
        String[] states = {"INVITE", "TRYING", "RINGING", "ANSWERED", "TERMINATED", "BUSY", "FAILED"};

        System.out.println("Inserting " + TOTAL_RECORDS + " SIP call records...");

        for (int i = 0; i < TOTAL_RECORDS; i++) {
            // Generate unique call ID
            String callId = String.format("CALL-%s-%06d", UUID.randomUUID().toString().substring(0, 8), i);

            // Generate random call data
            String fromUri = String.format("sip:user%d@domain.com", random.nextInt(100));
            String toUri = String.format("sip:user%d@domain.com", random.nextInt(100));
            String callState = states[random.nextInt(states.length)];

            LocalDateTime startTime = LocalDateTime.now().minusMinutes(random.nextInt(1440)); // Within last 24 hours
            int duration = random.nextInt(3600); // Up to 1 hour
            LocalDateTime endTime = callState.equals("ANSWERED") || callState.equals("TERMINATED")
                ? startTime.plusSeconds(duration) : null;

            SipCallRecord call = new SipCallRecord(
                callId,
                callState,
                fromUri,
                toUri,
                startTime,
                endTime,
                callState.equals("ANSWERED") || callState.equals("TERMINATED") ? duration : null
            );

            repository.insert(call);
            allCalls.add(call);

            if ((i + 1) % 100 == 0) {
                System.out.println("  Progress: " + (i + 1) + "/" + TOTAL_RECORDS);
            }
        }

        System.out.println("✓ Successfully inserted " + TOTAL_RECORDS + " SIP call records");

        // Verify all records can be retrieved
        System.out.println("\nVerifying record retrieval...");
        int verifiedCount = 0;
        for (SipCallRecord original : allCalls) {
            SipCallRecord retrieved = repository.findById(original.getCallId());
            assertNotNull(retrieved, "Should find call: " + original.getCallId());
            assertEquals(original.getCallState(), retrieved.getCallState());
            verifiedCount++;
        }
        System.out.println("✓ Successfully verified all " + verifiedCount + " records");
    }

    @Test
    @Order(2)
    void testVerifyHashPartitionDistribution() throws Exception {
        System.out.println("\n=== Test 2: Verify Hash Partition Distribution ===");

        // Query to check partition distribution
        String sql = """
            SELECT
                PARTITION_NAME,
                TABLE_ROWS
            FROM information_schema.PARTITIONS
            WHERE TABLE_SCHEMA = ?
            AND TABLE_NAME = 'sip_calls'
            AND PARTITION_NAME IS NOT NULL
            ORDER BY PARTITION_ORDINAL_POSITION
            """;

        try (Connection conn = DriverManager.getConnection(
                "jdbc:mysql://127.0.0.1:3306/" + TEST_DB + "?useSSL=false&serverTimezone=UTC",
                "root", "123456");
             PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setString(1, TEST_DB);

            System.out.println("\nPartition Distribution:");
            System.out.println("------------------------");

            int totalRows = 0;
            Map<String, Integer> partitionCounts = new TreeMap<>();

            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    String partitionName = rs.getString("PARTITION_NAME");
                    int rows = rs.getInt("TABLE_ROWS");
                    partitionCounts.put(partitionName, rows);
                    totalRows += rows;
                    System.out.printf("  %-10s : %5d rows\n", partitionName, rows);
                }
            }

            System.out.println("------------------------");
            System.out.println("Total rows : " + totalRows);

            // Calculate statistics
            if (!partitionCounts.isEmpty()) {
                int min = Collections.min(partitionCounts.values());
                int max = Collections.max(partitionCounts.values());
                double avg = (double) totalRows / partitionCounts.size();
                double expectedPerPartition = (double) TOTAL_RECORDS / PARTITION_COUNT;

                System.out.println("\nDistribution Statistics:");
                System.out.println("  Min rows in partition: " + min);
                System.out.println("  Max rows in partition: " + max);
                System.out.println("  Average rows per partition: " + String.format("%.2f", avg));
                System.out.println("  Expected rows per partition: " + String.format("%.2f", expectedPerPartition));

                // Verify that data is distributed across partitions
                // KEY partitioning doesn't guarantee even distribution, just that data is spread
                int emptyPartitions = 0;
                for (Map.Entry<String, Integer> entry : partitionCounts.entrySet()) {
                    if (entry.getValue() == 0) {
                        emptyPartitions++;
                    }
                }

                // Ensure most partitions have data (allow a few to be empty)
                assertTrue(emptyPartitions < PARTITION_COUNT / 4,
                    "Too many empty partitions: " + emptyPartitions);

                System.out.println("✓ Data is distributed across partitions (empty partitions: " + emptyPartitions + ")");
            }
        }
    }

    @Test
    @Order(3)
    void testVerifyRecordInCorrectPartition() throws Exception {
        System.out.println("\n=== Test 3: Verify Records in Correct Partitions ===");

        // Select a few random call IDs to verify their partition placement
        String[] testCallIds = {
            "CALL-test0001-000001",
            "CALL-test0002-000002",
            "CALL-test0003-000003"
        };

        System.out.println("Creating test records and verifying partition placement...");

        for (String callId : testCallIds) {
            // Insert a test record
            SipCallRecord testCall = new SipCallRecord(
                callId,
                "TEST_STATE",
                "sip:test@domain.com",
                "sip:dest@domain.com",
                LocalDateTime.now(),
                null,
                null
            );

            repository.insert(testCall);

            // Calculate expected partition (MySQL's hash function)
            int expectedPartition = Math.abs(callId.hashCode()) % PARTITION_COUNT;

            // Query to find which partition contains this record
            String sql = """
                SELECT COUNT(*) as count
                FROM sip_calls PARTITION (p%d)
                WHERE call_id = ?
                """;

            try (Connection conn = DriverManager.getConnection(
                    "jdbc:mysql://127.0.0.1:3306/" + TEST_DB + "?useSSL=false&serverTimezone=UTC",
                    "root", "123456");
                 PreparedStatement stmt = conn.prepareStatement(String.format(sql, expectedPartition))) {

                stmt.setString(1, callId);

                try (ResultSet rs = stmt.executeQuery()) {
                    if (rs.next()) {
                        int count = rs.getInt("count");
                        System.out.println("  Call ID: " + callId);
                        System.out.println("    Expected partition: p" + expectedPartition);
                        System.out.println("    Found in partition: " + (count > 0 ? "YES ✓" : "NO (checking all partitions)"));

                        if (count == 0) {
                            // If not in expected partition, find where it actually is
                            for (int p = 0; p < PARTITION_COUNT; p++) {
                                try (PreparedStatement checkStmt = conn.prepareStatement(
                                        String.format("SELECT COUNT(*) as count FROM sip_calls PARTITION (p%d) WHERE call_id = ?", p))) {
                                    checkStmt.setString(1, callId);
                                    try (ResultSet checkRs = checkStmt.executeQuery()) {
                                        if (checkRs.next() && checkRs.getInt("count") > 0) {
                                            System.out.println("    Actually found in: p" + p);
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        System.out.println("\n✓ Partition placement verification complete");
    }

    @Test
    @Order(4)
    void testTableStructure() throws Exception {
        System.out.println("\n=== Test 4: Verify Table Structure ===");

        // Check table structure
        String sql = "SHOW CREATE TABLE sip_calls";

        try (Connection conn = DriverManager.getConnection(
                "jdbc:mysql://127.0.0.1:3306/" + TEST_DB + "?useSSL=false&serverTimezone=UTC",
                "root", "123456");
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {

            if (rs.next()) {
                String createTable = rs.getString("Create Table");
                System.out.println("Table structure:");
                System.out.println(createTable);

                // Verify partitioning is set up
                assertTrue(createTable.contains("PARTITION BY KEY"), "Table should use KEY partitioning");
                assertTrue(createTable.contains("PARTITIONS " + PARTITION_COUNT),
                    "Table should have " + PARTITION_COUNT + " partitions");

                // Verify structure (index will be on primary key which is the sharding key)
                assertTrue(createTable.contains("call_id"), "Call ID column should exist");

                System.out.println("\n✓ Table structure verified with hash partitioning");
            }
        }
    }

    @AfterAll
    static void cleanup() throws Exception {
        System.out.println("\n=== Test Database Retained for Inspection ===");
        System.out.println("Database: " + TEST_DB);
        System.out.println("Table: sip_calls");
        System.out.println("Total records: " + TOTAL_RECORDS);
        System.out.println("Partitions: " + PARTITION_COUNT + " hash partitions");
    }
}