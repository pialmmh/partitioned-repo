package com.telcobright.splitverse.tests;

import com.telcobright.core.repository.SplitVerseRepository;
import com.telcobright.core.entity.ShardingEntity;
import com.telcobright.core.annotation.Table;
import com.telcobright.core.annotation.Id;
import com.telcobright.core.annotation.Column;
import com.telcobright.core.annotation.ShardingKey;
import com.telcobright.splitverse.config.ShardConfig;
import com.telcobright.splitverse.config.RepositoryMode;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;
import java.sql.*;
import java.time.*;
import java.time.temporal.ChronoUnit;
import java.util.Date;

import static org.junit.jupiter.api.Assertions.*;

public class UnsupportedDataTypeValidationTest {

    private static final String DATABASE = "test_date_validation";

    @BeforeAll
    public static void setup() throws Exception {
        try (Connection conn = DriverManager.getConnection(
                "jdbc:mysql://127.0.0.1:3306?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=UTC",
                "root", "123456");
             Statement stmt = conn.createStatement()) {
            stmt.execute("DROP DATABASE IF EXISTS " + DATABASE);
            stmt.execute("CREATE DATABASE " + DATABASE);
        }
    }

    // Test 1: Entity with java.util.Date as ShardingKey - Should throw exception
    @Table(name = "test_entity")
    public static class DateShardingEntity implements ShardingEntity<Date> {
        @Id(autoGenerated = false)
        private String id;
        @Column(name = "created_date")
        @ShardingKey private Date createdDate;
        private String name;

        public String getId() { return id; }
        public void setId(String id) { this.id = id; }
        public Date getPartitionColValue() { return createdDate; }
        public void setPartitionColValue(Date value) { this.createdDate = value; }
        public Date getCreatedDate() { return createdDate; }
        public void setCreatedDate(Date createdDate) { this.createdDate = createdDate; }
        public String getName() { return name; }
        public void setName(String name) { this.name = name; }
    }

    @Test
    public void testDateAsShardingKeyThrowsException() {
        Exception exception = assertThrows(IllegalStateException.class, () -> {
            ShardConfig shardConfig = ShardConfig.builder()
                .shardId("shard1")
                .database(DATABASE)
                .host("127.0.0.1")
                .port(3306)
                .username("root")
                .password("123456")
                .enabled(true)
                .build();

            SplitVerseRepository<DateShardingEntity, Date> repository =
                SplitVerseRepository.<DateShardingEntity, Date>builder()
                    .withSingleShard(shardConfig)
                    .withEntityClass(DateShardingEntity.class)
                    .withRepositoryMode(RepositoryMode.MULTI_TABLE)
                    .build();
        });

        // Exception is thrown for unsupported Date type
        assertNotNull(exception);
    }

    // Test 2: Entity with java.sql.Timestamp as ShardingKey - Should throw exception
    @Table(name = "test_entity")
    public static class TimestampShardingEntity implements ShardingEntity<Timestamp> {
        @Id(autoGenerated = false)
        private String id;
        @Column(name = "created_at")
        @ShardingKey private Timestamp createdAt;
        private String description;

        public String getId() { return id; }
        public void setId(String id) { this.id = id; }
        public Timestamp getPartitionColValue() { return createdAt; }
        public void setPartitionColValue(Timestamp value) { this.createdAt = value; }
        public Timestamp getCreatedAt() { return createdAt; }
        public void setCreatedAt(Timestamp createdAt) { this.createdAt = createdAt; }
        public String getDescription() { return description; }
        public void setDescription(String description) { this.description = description; }
    }

    @Test
    public void testTimestampAsShardingKeyThrowsException() {
        Exception exception = assertThrows(IllegalStateException.class, () -> {
            ShardConfig shardConfig = ShardConfig.builder()
                .shardId("shard1")
                .database(DATABASE)
                .host("127.0.0.1")
                .port(3306)
                .username("root")
                .password("123456")
                .enabled(true)
                .build();

            SplitVerseRepository<TimestampShardingEntity, Timestamp> repository =
                SplitVerseRepository.<TimestampShardingEntity, Timestamp>builder()
                    .withSingleShard(shardConfig)
                    .withEntityClass(TimestampShardingEntity.class)
                    .withRepositoryMode(RepositoryMode.MULTI_TABLE)
                    .build();
        });

        // Exception is thrown for unsupported Timestamp type
        assertNotNull(exception);
    }

    // Test 3: Entity with ZonedDateTime as ShardingKey - Should throw exception
    @Table(name = "test_entity")
    public static class ZonedDateTimeShardingEntity implements ShardingEntity<ZonedDateTime> {
        @Id(autoGenerated = false)
        private String id;
        @Column(name = "zoned_time")
        @ShardingKey private ZonedDateTime zonedTime;
        private Integer count;

        public String getId() { return id; }
        public void setId(String id) { this.id = id; }
        public ZonedDateTime getPartitionColValue() { return zonedTime; }
        public void setPartitionColValue(ZonedDateTime value) { this.zonedTime = value; }
        public ZonedDateTime getZonedTime() { return zonedTime; }
        public void setZonedTime(ZonedDateTime zonedTime) { this.zonedTime = zonedTime; }
        public Integer getCount() { return count; }
        public void setCount(Integer count) { this.count = count; }
    }

    @Test
    public void testZonedDateTimeAsShardingKeyThrowsException() {
        Exception exception = assertThrows(IllegalStateException.class, () -> {
            ShardConfig shardConfig = ShardConfig.builder()
                .shardId("shard1")
                .database(DATABASE)
                .host("127.0.0.1")
                .port(3306)
                .username("root")
                .password("123456")
                .enabled(true)
                .build();

            SplitVerseRepository<ZonedDateTimeShardingEntity, ZonedDateTime> repository =
                SplitVerseRepository.<ZonedDateTimeShardingEntity, ZonedDateTime>builder()
                    .withSingleShard(shardConfig)
                    .withEntityClass(ZonedDateTimeShardingEntity.class)
                    .withRepositoryMode(RepositoryMode.MULTI_TABLE)
                    .build();
        });

        // Exception is thrown for unsupported ZonedDateTime type
        assertNotNull(exception);
    }

    // Test 4: Entity with Instant as ShardingKey - Should throw exception
    @Table(name = "test_entity")
    public static class InstantShardingEntity implements ShardingEntity<Instant> {
        @Id(autoGenerated = false)
        private String id;
        @Column(name = "instant_time")
        @ShardingKey private Instant instantTime;
        private BigDecimal amount;

        public String getId() { return id; }
        public void setId(String id) { this.id = id; }
        public Instant getPartitionColValue() { return instantTime; }
        public void setPartitionColValue(Instant value) { this.instantTime = value; }
        public Instant getInstantTime() { return instantTime; }
        public void setInstantTime(Instant instantTime) { this.instantTime = instantTime; }
        public BigDecimal getAmount() { return amount; }
        public void setAmount(BigDecimal amount) { this.amount = amount; }
    }

    @Test
    public void testInstantAsShardingKeyThrowsException() {
        Exception exception = assertThrows(IllegalStateException.class, () -> {
            ShardConfig shardConfig = ShardConfig.builder()
                .shardId("shard1")
                .database(DATABASE)
                .host("127.0.0.1")
                .port(3306)
                .username("root")
                .password("123456")
                .enabled(true)
                .build();

            SplitVerseRepository<InstantShardingEntity, Instant> repository =
                SplitVerseRepository.<InstantShardingEntity, Instant>builder()
                    .withSingleShard(shardConfig)
                    .withEntityClass(InstantShardingEntity.class)
                    .withRepositoryMode(RepositoryMode.MULTI_TABLE)
                    .build();
        });

        // Exception is thrown for unsupported Instant type
        assertNotNull(exception);
    }

    // Test 5: Entity with Long as Id - Should throw exception
    @Table(name = "test_entity")
    public static class LongIdEntity implements ShardingEntity<LocalDateTime> {
        @Id(autoGenerated = false)
        private Long id;  // Invalid - must be String
        @Column(name = "created_at")
        @ShardingKey private LocalDateTime createdAt;
        private String content;

        // This won't compile but we need to test the validation
        public String getId() { return String.valueOf(id); }
        public void setId(String id) { this.id = Long.valueOf(id); }
        public LocalDateTime getPartitionColValue() { return createdAt; }
        public void setPartitionColValue(LocalDateTime value) { this.createdAt = value; }
        public LocalDateTime getCreatedAt() { return createdAt; }
        public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
        public String getContent() { return content; }
        public void setContent(String content) { this.content = content; }
    }

    @Test
    public void testLongAsIdThrowsException() {
        Exception exception = assertThrows(IllegalStateException.class, () -> {
            ShardConfig shardConfig = ShardConfig.builder()
                .shardId("shard1")
                .database(DATABASE)
                .host("127.0.0.1")
                .port(3306)
                .username("root")
                .password("123456")
                .enabled(true)
                .build();

            SplitVerseRepository<LongIdEntity, LocalDateTime> repository =
                SplitVerseRepository.<LongIdEntity, LocalDateTime>builder()
                    .withSingleShard(shardConfig)
                    .withEntityClass(LongIdEntity.class)
                    .withRepositoryMode(RepositoryMode.MULTI_TABLE)
                    .build();
        });

        // Exception is thrown for non-String ID type
        assertNotNull(exception);
    }

    // Test 6: Entity with Integer as Id - Should throw exception
    @Table(name = "test_entity")
    public static class IntegerIdEntity implements ShardingEntity<LocalDateTime> {
        @Id(autoGenerated = false)
        private Integer id;  // Invalid - must be String
        @Column(name = "created_at")
        @ShardingKey private LocalDateTime createdAt;
        private String data;

        public String getId() { return String.valueOf(id); }
        public void setId(String id) { this.id = Integer.valueOf(id); }
        public LocalDateTime getPartitionColValue() { return createdAt; }
        public void setPartitionColValue(LocalDateTime value) { this.createdAt = value; }
        public LocalDateTime getCreatedAt() { return createdAt; }
        public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
        public String getData() { return data; }
        public void setData(String data) { this.data = data; }
    }

    @Test
    public void testIntegerAsIdThrowsException() {
        Exception exception = assertThrows(IllegalStateException.class, () -> {
            ShardConfig shardConfig = ShardConfig.builder()
                .shardId("shard1")
                .database(DATABASE)
                .host("127.0.0.1")
                .port(3306)
                .username("root")
                .password("123456")
                .enabled(true)
                .build();

            SplitVerseRepository<IntegerIdEntity, LocalDateTime> repository =
                SplitVerseRepository.<IntegerIdEntity, LocalDateTime>builder()
                    .withSingleShard(shardConfig)
                    .withEntityClass(IntegerIdEntity.class)
                    .withRepositoryMode(RepositoryMode.MULTI_TABLE)
                    .build();
        });

        // Exception is thrown for non-String ID type
        assertNotNull(exception);
    }

    // Test 7: Valid Entity with LocalDateTime ShardingKey - Should initialize successfully
    @Table(name = "test_entity")
    public static class ValidLocalDateTimeEntity implements ShardingEntity<LocalDateTime> {
        @Id(autoGenerated = false)
        private String id;
        @Column(name = "created_at")
        @ShardingKey private LocalDateTime createdAt;
        private Date legacyDate;  // OK in regular field
        private Timestamp someTimestamp;  // OK in regular field
        private String name;

        public String getId() { return id; }
        public void setId(String id) { this.id = id; }
        public LocalDateTime getPartitionColValue() { return createdAt; }
        public void setPartitionColValue(LocalDateTime value) { this.createdAt = value; }
        public LocalDateTime getCreatedAt() { return createdAt; }
        public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
        public Date getLegacyDate() { return legacyDate; }
        public void setLegacyDate(Date legacyDate) { this.legacyDate = legacyDate; }
        public Timestamp getSomeTimestamp() { return someTimestamp; }
        public void setSomeTimestamp(Timestamp someTimestamp) { this.someTimestamp = someTimestamp; }
        public String getName() { return name; }
        public void setName(String name) { this.name = name; }
    }

    @Test
    public void testValidLocalDateTimeEntityInitializesSuccessfully() {
        assertDoesNotThrow(() -> {
            ShardConfig shardConfig = ShardConfig.builder()
                .shardId("shard1")
                .database(DATABASE)
                .host("127.0.0.1")
                .port(3306)
                .username("root")
                .password("123456")
                .enabled(true)
                .build();

            SplitVerseRepository<ValidLocalDateTimeEntity, LocalDateTime> repository =
                SplitVerseRepository.<ValidLocalDateTimeEntity, LocalDateTime>builder()
                    .withSingleShard(shardConfig)
                    .withEntityClass(ValidLocalDateTimeEntity.class)
                    .withRepositoryMode(RepositoryMode.MULTI_TABLE)
                    .build();

            assertNotNull(repository);
        });
    }

    // Test 8 removed - String sharding keys aren't compatible with DATE_BASED partitioning

    // Test 9: Valid Entity with Long ShardingKey - Should initialize successfully
    @Table(name = "test_entity")
    public static class ValidLongShardingEntity implements ShardingEntity<Long> {
        @Id(autoGenerated = false)
        private String id;
        @Column(name = "sequence")
        @ShardingKey private Long sequence;
        private Timestamp timestamp;  // OK in regular field

        public String getId() { return id; }
        public void setId(String id) { this.id = id; }
        public Long getPartitionColValue() { return sequence; }
        public void setPartitionColValue(Long value) { this.sequence = value; }
        public Long getSequence() { return sequence; }
        public void setSequence(Long sequence) { this.sequence = sequence; }
        public Timestamp getTimestamp() { return timestamp; }
        public void setTimestamp(Timestamp timestamp) { this.timestamp = timestamp; }
    }

    @Test
    public void testValidLongShardingEntityInitializesSuccessfully() {
        assertDoesNotThrow(() -> {
            ShardConfig shardConfig = ShardConfig.builder()
                .shardId("shard1")
                .database(DATABASE)
                .host("127.0.0.1")
                .port(3306)
                .username("root")
                .password("123456")
                .enabled(true)
                .build();

            SplitVerseRepository<ValidLongShardingEntity, Long> repository =
                SplitVerseRepository.<ValidLongShardingEntity, Long>builder()
                    .withSingleShard(shardConfig)
                    .withEntityClass(ValidLongShardingEntity.class)
                    .withRepositoryMode(RepositoryMode.MULTI_TABLE)
                    .build();

            assertNotNull(repository);
        });
    }

    // Test 10: Entity with Multiple Date Fields (Mixed Types) - Should initialize successfully
    @Table(name = "test_entity")
    public static class MixedDateFieldEntity implements ShardingEntity<LocalDateTime> {
        @Id(autoGenerated = false)
        private String id;
        @Column(name = "created_at")
        @ShardingKey private LocalDateTime createdAt;
        private Date lastModified;  // OK - regular field
        private Timestamp deletedAt;  // OK - regular field
        private ZonedDateTime scheduledTime;  // OK - regular field
        private Instant processedAt;  // OK - regular field

        public String getId() { return id; }
        public void setId(String id) { this.id = id; }
        public LocalDateTime getPartitionColValue() { return createdAt; }
        public void setPartitionColValue(LocalDateTime value) { this.createdAt = value; }
        public LocalDateTime getCreatedAt() { return createdAt; }
        public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
        public Date getLastModified() { return lastModified; }
        public void setLastModified(Date lastModified) { this.lastModified = lastModified; }
        public Timestamp getDeletedAt() { return deletedAt; }
        public void setDeletedAt(Timestamp deletedAt) { this.deletedAt = deletedAt; }
        public ZonedDateTime getScheduledTime() { return scheduledTime; }
        public void setScheduledTime(ZonedDateTime scheduledTime) { this.scheduledTime = scheduledTime; }
        public Instant getProcessedAt() { return processedAt; }
        public void setProcessedAt(Instant processedAt) { this.processedAt = processedAt; }
    }

    @Test
    public void testMixedDateFieldEntityInitializesSuccessfully() {
        assertDoesNotThrow(() -> {
            ShardConfig shardConfig = ShardConfig.builder()
                .shardId("shard1")
                .database(DATABASE)
                .host("127.0.0.1")
                .port(3306)
                .username("root")
                .password("123456")
                .enabled(true)
                .build();

            SplitVerseRepository<MixedDateFieldEntity, LocalDateTime> repository =
                SplitVerseRepository.<MixedDateFieldEntity, LocalDateTime>builder()
                    .withSingleShard(shardConfig)
                    .withEntityClass(MixedDateFieldEntity.class)
                    .withRepositoryMode(RepositoryMode.MULTI_TABLE)
                    .build();

            assertNotNull(repository);
        });
    }
}