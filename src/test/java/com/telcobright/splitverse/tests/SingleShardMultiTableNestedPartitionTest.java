package com.telcobright.splitverse.tests;

import com.telcobright.core.repository.SplitVerseRepository;
import com.telcobright.splitverse.config.RepositoryMode;
import com.telcobright.splitverse.config.ShardConfig;
import com.telcobright.core.annotation.Table;
import com.telcobright.core.annotation.Id;
import com.telcobright.core.annotation.Column;
import com.telcobright.core.annotation.Index;
import com.telcobright.core.entity.ShardingEntity;
import org.junit.jupiter.api.*;
import java.sql.*;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.UUID;
import java.util.List;
import java.util.ArrayList;
import java.util.Random;

import static org.junit.jupiter.api.Assertions.*;

/**
 * TEST GOALS:
 * - Validate MULTI_TABLE mode with date-based partitioning
 * - Test automatic table creation for different dates
 * - Verify tables are created with native partition for more efficient searching through partition pruning
 * - E.g. for datewise sharding key, one partition for each hour. total 24 partitions
 * - For other dataTypes, split-verse should create 20 partitions by default if not specified other values through the builder.
 * - Test with various data including date, long and int. make sure that data from multiple tables are inserted and retrieved correctly.
 * - Create separate tests for different data types
 * - Make sure when tables are created, sharding key column is indexed.
 * - Perform the test with 7 days retention period
 * - Insert enough sample data, then retrieve data and verify. test with date types.
 */
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class SingleShardMultiTableNestedPartitionTest {
    private static final String TEST_DB = "test_nested_partition_" + System.currentTimeMillis();
    private static SplitVerseRepository<EventRecord, LocalDateTime> dateRepository;
    private static SplitVerseRepository<UserRecord, Long> longRepository;
    private static SplitVerseRepository<ProductRecord, Integer> intRepository;
    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
    private static final Random random = new Random();

    // Date-based entity for events
    @Table(name = "events")
    public static class EventRecord implements ShardingEntity<LocalDateTime> {
        @Id(autoGenerated = false)
        private String id;

        @com.telcobright.core.annotation.ShardingKey
        @Column(name = "event_time")
        @Index(name = "idx_event_time")  // Ensure index on sharding key
        private LocalDateTime eventTime;

        @Column(name = "event_type")
        private String eventType;

        @Column(name = "payload")
        private String payload;

        public EventRecord() {}

        public EventRecord(String id, LocalDateTime eventTime, String eventType, String payload) {
            this.id = id;
            this.eventTime = eventTime;
            this.eventType = eventType;
            this.payload = payload;
        }

        @Override
        public String getId() { return id; }
        @Override
        public void setId(String id) { this.id = id; }
        @Override
        public LocalDateTime getPartitionColValue() { return eventTime; }
        @Override
        public void setPartitionColValue(LocalDateTime value) { this.eventTime = value; }

        public LocalDateTime getEventTime() { return eventTime; }
        public void setEventTime(LocalDateTime time) { this.eventTime = time; }
        public String getEventType() { return eventType; }
        public void setEventType(String type) { this.eventType = type; }
        public String getPayload() { return payload; }
        public void setPayload(String payload) { this.payload = payload; }
    }

    // Long-based entity for users
    @Table(name = "users")
    public static class UserRecord implements ShardingEntity<Long> {
        @Id(autoGenerated = false)
        private String id;

        @com.telcobright.core.annotation.ShardingKey
        @Column(name = "user_sequence")
        @Index(name = "idx_user_sequence")  // Ensure index on sharding key
        private Long userSequence;

        @Column(name = "username")
        private String username;

        @Column(name = "email")
        private String email;

        public UserRecord() {}

        public UserRecord(String id, Long userSequence, String username, String email) {
            this.id = id;
            this.userSequence = userSequence;
            this.username = username;
            this.email = email;
        }

        @Override
        public String getId() { return id; }
        @Override
        public void setId(String id) { this.id = id; }
        @Override
        public Long getPartitionColValue() { return userSequence; }
        @Override
        public void setPartitionColValue(Long value) { this.userSequence = value; }

        public Long getUserSequence() { return userSequence; }
        public void setUserSequence(Long seq) { this.userSequence = seq; }
        public String getUsername() { return username; }
        public void setUsername(String name) { this.username = name; }
        public String getEmail() { return email; }
        public void setEmail(String email) { this.email = email; }
    }

    // Integer-based entity for products
    @Table(name = "products")
    public static class ProductRecord implements ShardingEntity<Integer> {
        @Id(autoGenerated = false)
        private String id;

        @com.telcobright.core.annotation.ShardingKey
        @Column(name = "product_code")
        @Index(name = "idx_product_code")  // Ensure index on sharding key
        private Integer productCode;

        @Column(name = "name")
        private String name;

        @Column(name = "price")
        private Double price;

        public ProductRecord() {}

        public ProductRecord(String id, Integer productCode, String name, Double price) {
            this.id = id;
            this.productCode = productCode;
            this.name = name;
            this.price = price;
        }

        @Override
        public String getId() { return id; }
        @Override
        public void setId(String id) { this.id = id; }
        @Override
        public Integer getPartitionColValue() { return productCode; }
        @Override
        public void setPartitionColValue(Integer value) { this.productCode = value; }

        public Integer getProductCode() { return productCode; }
        public void setProductCode(Integer code) { this.productCode = code; }
        public String getName() { return name; }
        public void setName(String name) { this.name = name; }
        public Double getPrice() { return price; }
        public void setPrice(Double price) { this.price = price; }
    }

    @BeforeAll
    static void setup() throws Exception {
        System.out.println("Setting up test database: " + TEST_DB);

        // Create test database
        try (Connection conn = DriverManager.getConnection(
                "jdbc:mysql://127.0.0.1:3306?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=UTC",
                "root", "123456");
             Statement stmt = conn.createStatement()) {
            stmt.execute("CREATE DATABASE IF NOT EXISTS " + TEST_DB);
        }

        ShardConfig shardConfig = ShardConfig.builder()
            .shardId("shard1")
            .database(TEST_DB)
            .host("127.0.0.1")
            .port(3306)
            .username("root")
            .password("123456")
            .enabled(true)
            .build();

        // Build repository for LocalDateTime with 24 hourly partitions and 7 days retention
        dateRepository = SplitVerseRepository.<EventRecord, LocalDateTime>builder()
            .withSingleShard(shardConfig)
            .withEntityClass(EventRecord.class)
            .withRepositoryMode(RepositoryMode.MULTI_TABLE)
            .withNestedPartitions(true)
            .withNestedPartitionCount(24)  // 24 hourly partitions for daily tables
            .withRetentionDays(7)  // 7 days retention as specified
            .build();

        // Build repository for Long with default 20 partitions
        longRepository = SplitVerseRepository.<UserRecord, Long>builder()
            .withSingleShard(shardConfig)
            .withEntityClass(UserRecord.class)
            .withRepositoryMode(RepositoryMode.MULTI_TABLE)
            .withNestedPartitions(true)  // Uses default 20 partitions
            .withPartitionRange("VALUE_RANGE_10K")
            .build();

        // Build repository for Integer with default 20 partitions
        intRepository = SplitVerseRepository.<ProductRecord, Integer>builder()
            .withSingleShard(shardConfig)
            .withEntityClass(ProductRecord.class)
            .withRepositoryMode(RepositoryMode.MULTI_TABLE)
            .withNestedPartitions(true)  // Uses default 20 partitions
            .withPartitionRange("VALUE_RANGE_1K")
            .build();

        System.out.println("Repositories configured with nested partitioning:");
        System.out.println("  - Events: 24 hourly partitions per daily table, 7 days retention");
        System.out.println("  - Users: 20 hash partitions per table (Long type)");
        System.out.println("  - Products: 20 hash partitions per table (Integer type)");
    }

    @Test
    @Order(1)
    void testDateTypeWithHourlyPartitions() throws Exception {
        System.out.println("\n=== Test 1: LocalDateTime with 24 hourly partitions and 7-day retention ===");

        LocalDateTime now = LocalDateTime.now();
        List<EventRecord> allEvents = new ArrayList<>();

        // First, verify that 15 days of tables are created (7 days retention + buffer)
        System.out.println("Verifying table creation for 7-day retention period...");
        verifyTableCreation();

        // Insert events across 7 days (retention period) with multiple events per day
        System.out.println("Inserting events across 7 days...");
        for (int day = -3; day <= 3; day++) {
            LocalDateTime dayTime = now.plusDays(day);

            // Insert events for each hour of the day (testing all 24 partitions)
            for (int hour = 0; hour < 24; hour++) {
                EventRecord event = new EventRecord(
                    String.format("EVT_%d_%02d", day, hour),
                    dayTime.withHour(hour).withMinute(30).withSecond(0).withNano(0),
                    "TYPE_" + (hour % 5),  // 5 different event types
                    String.format("Event data for day %d hour %d", day, hour)
                );
                allEvents.add(event);
                dateRepository.insert(event);
            }
        }
        System.out.println("  ✓ Inserted " + allEvents.size() + " events across 7 days (24 events per day)");

        // Verify table structure and partitions
        String todayTable = "events_" + now.format(DateTimeFormatter.ofPattern("yyyyMMdd"));
        System.out.println("\nVerifying table structure for: " + todayTable);

        // Check partitions exist
        String partitionQuery = """
            SELECT COUNT(DISTINCT PARTITION_NAME) as partition_count
            FROM information_schema.PARTITIONS
            WHERE TABLE_SCHEMA = ? AND TABLE_NAME = ?
            """;

        try (Connection conn = DriverManager.getConnection(
                "jdbc:mysql://127.0.0.1:3306/" + TEST_DB + "?useSSL=false&serverTimezone=UTC",
                "root", "123456");
             PreparedStatement stmt = conn.prepareStatement(partitionQuery)) {

            stmt.setString(1, TEST_DB);
            stmt.setString(2, todayTable);

            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    int partitionCount = rs.getInt("partition_count");
                    assertEquals(24, partitionCount, "Should have 24 hourly partitions");
                    System.out.println("  ✓ Verified 24 hourly partitions in table");
                }
            }
        }

        // Verify index exists on sharding key
        verifyIndexExists(TEST_DB, todayTable, "idx_event_time");
        System.out.println("  ✓ Verified index on sharding key column");

        // Retrieve and verify all events
        System.out.println("\nRetrieving and verifying events...");
        int verifiedCount = 0;
        for (EventRecord original : allEvents) {
            EventRecord retrieved = dateRepository.findById(original.getId());
            assertNotNull(retrieved, "Should find event: " + original.getId());
            assertEquals(original.getEventType(), retrieved.getEventType());
            assertEquals(original.getPayload(), retrieved.getPayload());
            verifiedCount++;
        }
        System.out.println("  ✓ Successfully retrieved and verified all " + verifiedCount + " events");

        // Test range query with partition pruning
        System.out.println("\nTesting range query with partition pruning...");
        LocalDateTime startRange = now.withHour(10).withMinute(0).withSecond(0).withNano(0);
        LocalDateTime endRange = now.withHour(14).withMinute(0).withSecond(0).withNano(0);
        List<EventRecord> rangeEvents = dateRepository.findAllByPartitionRange(startRange, endRange);
        assertFalse(rangeEvents.isEmpty(), "Should find events in range");
        System.out.println("  ✓ Range query returned " + rangeEvents.size() + " events (partition pruning active)");
    }

    @Test
    @Order(2)
    void testLongTypeWithHashPartitions() throws Exception {
        System.out.println("\n=== Test 2: Long type with 20 hash partitions ===");

        List<UserRecord> allUsers = new ArrayList<>();

        // Insert users across different sequence ranges to span multiple tables
        System.out.println("Inserting users across multiple tables...");
        long[] baseSequences = {1000L, 11000L, 21000L, 31000L};  // Different 10K ranges

        for (long baseSeq : baseSequences) {
            // Insert 50 users per range
            for (int i = 0; i < 50; i++) {
                long sequence = baseSeq + (i * 10);
                UserRecord user = new UserRecord(
                    "USER_" + sequence,
                    sequence,
                    "user_" + sequence,
                    "user" + sequence + "@example.com"
                );
                allUsers.add(user);
                longRepository.insert(user);
            }
        }
        System.out.println("  ✓ Inserted " + allUsers.size() + " users across " + baseSequences.length + " tables");

        // Verify table structure - check one of the tables
        String tableName = "users_0_9999";  // First range table (10K range)
        System.out.println("\nVerifying table structure for: " + tableName);

        // Check partitions (should have 20 hash partitions)
        String partitionQuery = """
            SELECT COUNT(*) as partition_count
            FROM information_schema.PARTITIONS
            WHERE TABLE_SCHEMA = ? AND TABLE_NAME = ?
            AND PARTITION_NAME IS NOT NULL
            """;

        try (Connection conn = DriverManager.getConnection(
                "jdbc:mysql://127.0.0.1:3306/" + TEST_DB + "?useSSL=false&serverTimezone=UTC",
                "root", "123456");
             PreparedStatement stmt = conn.prepareStatement(partitionQuery)) {

            stmt.setString(1, TEST_DB);
            stmt.setString(2, tableName);

            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    int partitionCount = rs.getInt("partition_count");
                    assertEquals(20, partitionCount, "Should have 20 hash partitions");
                    System.out.println("  ✓ Verified 20 hash partitions in table");
                }
            }
        }

        // Verify index on sharding key
        verifyIndexExists(TEST_DB, tableName, "idx_user_sequence");
        System.out.println("  ✓ Verified index on sharding key column");

        // Retrieve and verify all users
        System.out.println("\nRetrieving and verifying users...");
        int verifiedCount = 0;
        for (UserRecord original : allUsers) {
            UserRecord retrieved = longRepository.findById(original.getId());
            assertNotNull(retrieved, "Should find user: " + original.getId());
            assertEquals(original.getUserSequence(), retrieved.getUserSequence());
            assertEquals(original.getEmail(), retrieved.getEmail());
            verifiedCount++;
        }
        System.out.println("  ✓ Successfully retrieved and verified all " + verifiedCount + " users");
    }

    @Test
    @Order(3)
    void testIntegerTypeWithHashPartitions() throws Exception {
        System.out.println("\n=== Test 3: Integer type with 20 hash partitions ===");

        List<ProductRecord> allProducts = new ArrayList<>();

        // Insert products across different code ranges to span multiple tables
        System.out.println("Inserting products across multiple tables...");
        int[] baseCodes = {100, 1100, 2100, 3100};  // Different 1K ranges

        for (int baseCode : baseCodes) {
            // Insert 50 products per range
            for (int i = 0; i < 50; i++) {
                int code = baseCode + (i * 5);
                ProductRecord product = new ProductRecord(
                    "PROD_" + code,
                    code,
                    "Product " + code,
                    99.99 + (code % 100)
                );
                allProducts.add(product);
                intRepository.insert(product);
            }
        }
        System.out.println("  ✓ Inserted " + allProducts.size() + " products across " + baseCodes.length + " tables");

        // Verify table structure - check one of the tables
        String tableName = "products_0_999";  // First range table
        System.out.println("\nVerifying table structure for: " + tableName);

        // Check partitions (should have 20 hash partitions)
        String partitionQuery = """
            SELECT COUNT(*) as partition_count
            FROM information_schema.PARTITIONS
            WHERE TABLE_SCHEMA = ? AND TABLE_NAME = ?
            AND PARTITION_NAME IS NOT NULL
            """;

        try (Connection conn = DriverManager.getConnection(
                "jdbc:mysql://127.0.0.1:3306/" + TEST_DB + "?useSSL=false&serverTimezone=UTC",
                "root", "123456");
             PreparedStatement stmt = conn.prepareStatement(partitionQuery)) {

            stmt.setString(1, TEST_DB);
            stmt.setString(2, tableName);

            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    int partitionCount = rs.getInt("partition_count");
                    assertEquals(20, partitionCount, "Should have 20 hash partitions");
                    System.out.println("  ✓ Verified 20 hash partitions in table");
                }
            }
        }

        // Verify index on sharding key
        verifyIndexExists(TEST_DB, tableName, "idx_product_code");
        System.out.println("  ✓ Verified index on sharding key column");

        // Retrieve and verify all products
        System.out.println("\nRetrieving and verifying products...");
        int verifiedCount = 0;
        for (ProductRecord original : allProducts) {
            ProductRecord retrieved = intRepository.findById(original.getId());
            assertNotNull(retrieved, "Should find product: " + original.getId());
            assertEquals(original.getProductCode(), retrieved.getProductCode());
            assertEquals(original.getPrice(), retrieved.getPrice(), 0.01);
            verifiedCount++;
        }
        System.out.println("  ✓ Successfully retrieved and verified all " + verifiedCount + " products");
    }

    @Test
    @Order(4)
    void testCrossTableDataIntegrity() throws Exception {
        System.out.println("\n=== Test 4: Cross-table data integrity and retrieval ===");

        // Test that data from different tables can be retrieved correctly
        LocalDateTime now = LocalDateTime.now();

        // Insert sample events in different daily tables
        List<String> eventIds = new ArrayList<>();
        for (int day = -2; day <= 2; day++) {
            String id = "INTEGRITY_TEST_" + day;
            EventRecord event = new EventRecord(
                id,
                now.plusDays(day),
                "INTEGRITY",
                "Testing cross-table retrieval for day " + day
            );
            dateRepository.insert(event);
            eventIds.add(id);
        }

        // Verify all events can be found across different tables
        System.out.println("Verifying cross-table retrieval...");
        for (String id : eventIds) {
            EventRecord found = dateRepository.findById(id);
            assertNotNull(found, "Should find event across tables: " + id);
            assertEquals("INTEGRITY", found.getEventType());
        }
        System.out.println("  ✓ All events retrieved successfully from different daily tables");

        // Test range query across multiple tables
        LocalDateTime rangeStart = now.minusDays(2);
        LocalDateTime rangeEnd = now.plusDays(2);
        List<EventRecord> rangeResults = dateRepository.findAllByPartitionRange(rangeStart, rangeEnd);

        // Should find at least the integrity test events
        assertTrue(rangeResults.size() >= eventIds.size(),
            "Range query should return events from multiple tables");
        System.out.println("  ✓ Range query successfully retrieved data across " +
            "multiple tables (" + rangeResults.size() + " events)");
    }

    /**
     * Verify that tables are created for the retention period
     * With 7-day retention, we expect 15 days of tables to be created
     */
    private void verifyTableCreation() throws SQLException {
        LocalDateTime now = LocalDateTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMdd");

        System.out.println("Checking for tables created with 7-day retention...");

        String query = """
            SELECT COUNT(DISTINCT TABLE_NAME) as table_count
            FROM information_schema.TABLES
            WHERE TABLE_SCHEMA = ?
            AND TABLE_NAME LIKE 'events_%'
            """;

        try (Connection conn = DriverManager.getConnection(
                "jdbc:mysql://127.0.0.1:3306/" + TEST_DB + "?useSSL=false&serverTimezone=UTC",
                "root", "123456");
             PreparedStatement stmt = conn.prepareStatement(query)) {

            stmt.setString(1, TEST_DB);

            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    int tableCount = rs.getInt("table_count");
                    System.out.println("  Found " + tableCount + " daily event tables");

                    // With 7-day retention, we expect ~15 days of tables
                    // (7 days back + today + 7 days forward = 15 days)
                    assertTrue(tableCount >= 13 && tableCount <= 16,
                        "Expected 13-16 tables for 7-day retention, but found " + tableCount);
                    System.out.println("  ✓ Verified table count is appropriate for 7-day retention");
                }
            }
        }

        // List all tables to show the date range
        String listQuery = """
            SELECT TABLE_NAME
            FROM information_schema.TABLES
            WHERE TABLE_SCHEMA = ?
            AND TABLE_NAME LIKE 'events_%'
            ORDER BY TABLE_NAME
            """;

        try (Connection conn = DriverManager.getConnection(
                "jdbc:mysql://127.0.0.1:3306/" + TEST_DB + "?useSSL=false&serverTimezone=UTC",
                "root", "123456");
             PreparedStatement stmt = conn.prepareStatement(listQuery)) {

            stmt.setString(1, TEST_DB);

            try (ResultSet rs = stmt.executeQuery()) {
                List<String> tables = new ArrayList<>();
                while (rs.next()) {
                    tables.add(rs.getString("TABLE_NAME"));
                }

                if (!tables.isEmpty()) {
                    String firstTable = tables.get(0);
                    String lastTable = tables.get(tables.size() - 1);
                    System.out.println("  Table range: " + firstTable + " to " + lastTable);

                    // Verify each table has 24 partitions
                    verifyTablePartitions(tables.get(tables.size()/2)); // Check middle table
                }
            }
        }
    }

    /**
     * Verify that a table has the expected number of partitions
     */
    private void verifyTablePartitions(String tableName) throws SQLException {
        String query = """
            SELECT COUNT(DISTINCT PARTITION_NAME) as partition_count
            FROM information_schema.PARTITIONS
            WHERE TABLE_SCHEMA = ? AND TABLE_NAME = ?
            """;

        try (Connection conn = DriverManager.getConnection(
                "jdbc:mysql://127.0.0.1:3306/" + TEST_DB + "?useSSL=false&serverTimezone=UTC",
                "root", "123456");
             PreparedStatement stmt = conn.prepareStatement(query)) {

            stmt.setString(1, TEST_DB);
            stmt.setString(2, tableName);

            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    int partitionCount = rs.getInt("partition_count");
                    assertEquals(24, partitionCount,
                        "Table " + tableName + " should have 24 hourly partitions");
                    System.out.println("  ✓ Verified " + tableName + " has 24 hourly partitions");
                }
            }
        }
    }

    /**
     * Helper method to verify index exists on a column
     */
    private static void verifyIndexExists(String database, String tableName, String indexName) throws SQLException {
        String sql = """
            SELECT COUNT(*) as index_count
            FROM information_schema.STATISTICS
            WHERE TABLE_SCHEMA = ? AND TABLE_NAME = ? AND INDEX_NAME = ?
            """;

        try (Connection conn = DriverManager.getConnection(
                "jdbc:mysql://127.0.0.1:3306/" + database + "?useSSL=false&serverTimezone=UTC",
                "root", "123456");
             PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setString(1, database);
            stmt.setString(2, tableName);
            stmt.setString(3, indexName);

            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    int indexCount = rs.getInt("index_count");
                    assertTrue(indexCount > 0, "Index " + indexName + " should exist on table " + tableName);
                }
            }
        }
    }

    @AfterAll
    static void cleanup() throws Exception {
        // Keep test database and data for inspection
        System.out.println("\n=== Test Database Retained for Inspection ===");
        System.out.println("Database: " + TEST_DB);
        System.out.println("This database contains all test tables and data.");
    }
}