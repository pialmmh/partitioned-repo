package com.telcobright.splitverse.tests;

import com.telcobright.core.annotation.Column;
import com.telcobright.core.annotation.Id;
import com.telcobright.core.annotation.ShardingKey;
import com.telcobright.core.annotation.Table;
import com.telcobright.core.entity.ShardingEntity;
import com.telcobright.core.repository.GenericMultiTableRepository;
import com.telcobright.core.repository.GenericPartitionedTableRepository;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.time.LocalDateTime;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Test to demonstrate disabling automatic partition management.
 * When autoManagePartitions is set to false, repositories should not:
 * 1. Automatically create new partitions
 * 2. Automatically drop old partitions
 * 3. Perform any partition maintenance during operations
 */
public class PartitionManagementDisabledTest {

    private static final String DB_URL = "jdbc:mysql://127.0.0.1:3306/testdb";
    private static final String DB_USER = "root";
    private static final String DB_PASSWORD = "123456";

    private Connection connection;

    @Table(name = "test_events")
    public static class TestEvent implements ShardingEntity<LocalDateTime> {
        @Id(autoGenerated = false)
        @Column(name = "event_id")
        private String eventId;

        @ShardingKey
        @Column(name = "event_time")
        private LocalDateTime eventTime;

        @Column(name = "event_data")
        private String eventData;

        // Constructors
        public TestEvent() {}

        public TestEvent(String eventId, LocalDateTime eventTime, String eventData) {
            this.eventId = eventId;
            this.eventTime = eventTime;
            this.eventData = eventData;
        }

        // Getters and setters
        public String getEventId() { return eventId; }
        public void setEventId(String eventId) { this.eventId = eventId; }

        public LocalDateTime getEventTime() { return eventTime; }
        public void setEventTime(LocalDateTime eventTime) { this.eventTime = eventTime; }

        public String getEventData() { return eventData; }
        public void setEventData(String eventData) { this.eventData = eventData; }

        @Override
        public String getId() { return eventId; }
        @Override
        public void setId(String id) { this.eventId = id; }
        @Override
        public LocalDateTime getPartitionColValue() { return eventTime; }
        @Override
        public void setPartitionColValue(LocalDateTime value) { this.eventTime = value; }
    }

    @BeforeEach
    public void setup() throws Exception {
        // First create the database if it doesn't exist
        try (Connection rootConn = DriverManager.getConnection(
                "jdbc:mysql://127.0.0.1:3306", DB_USER, DB_PASSWORD);
             Statement stmt = rootConn.createStatement()) {
            stmt.executeUpdate("CREATE DATABASE IF NOT EXISTS testdb");
        }

        // Now connect to the database
        connection = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);
        cleanupTables();
    }

    @AfterEach
    public void tearDown() throws Exception {
        cleanupTables();
        if (connection != null && !connection.isClosed()) {
            connection.close();
        }
    }

    private void cleanupTables() {
        try (Statement stmt = connection.createStatement()) {
            // Drop partitioned table
            stmt.executeUpdate("DROP TABLE IF EXISTS test_events");

            // Drop multi-table pattern tables
            ResultSet rs = stmt.executeQuery(
                "SELECT TABLE_NAME FROM information_schema.TABLES " +
                "WHERE TABLE_SCHEMA = 'testdb' AND TABLE_NAME LIKE 'test_multi_%'"
            );
            while (rs.next()) {
                String tableName = rs.getString("TABLE_NAME");
                stmt.executeUpdate("DROP TABLE IF EXISTS " + tableName);
            }
        } catch (Exception e) {
            System.err.println("Cleanup error: " + e.getMessage());
        }
    }

    @Test
    public void testPartitionedRepositoryWithDisabledManagement() throws Exception {
        System.out.println("Testing GenericPartitionedTableRepository with disabled partition management...");

        // Create repository with partition management disabled
        GenericPartitionedTableRepository<TestEvent, LocalDateTime> repository =
            GenericPartitionedTableRepository.<TestEvent, LocalDateTime>builder(TestEvent.class)
                .host("127.0.0.1")
                .port(3306)
                .database("testdb")
                .username("root")
                .password("123456")
                .tableName("test_events")
                .partitionRetentionPeriod(3)  // Only keep 3 days of data
                .autoManagePartitions(false)  // DISABLE automatic management
                .build();

        // Create events spanning 10 days (beyond retention period)
        LocalDateTime now = LocalDateTime.now();
        for (int i = -7; i <= 2; i++) {
            TestEvent event = new TestEvent(
                UUID.randomUUID().toString(),
                now.plusDays(i),
                "Test data for day " + i
            );
            repository.insert(event);
        }

        // Verify that old partitions are NOT dropped (because management is disabled)
        try (Statement stmt = connection.createStatement()) {
            ResultSet rs = stmt.executeQuery(
                "SELECT PARTITION_NAME FROM information_schema.PARTITIONS " +
                "WHERE TABLE_SCHEMA = 'testdb' AND TABLE_NAME = 'test_events' " +
                "ORDER BY PARTITION_NAME"
            );

            int partitionCount = 0;
            System.out.println("Existing partitions:");
            while (rs.next()) {
                String partitionName = rs.getString("PARTITION_NAME");
                if (partitionName != null) {
                    System.out.println("  - " + partitionName);
                    partitionCount++;
                }
            }

            // With autoManagePartitions=false and retentionDays=3,
            // we should still have ALL partitions (10 days worth)
            assertTrue(partitionCount >= 10,
                "All partitions should be retained when autoManagePartitions=false, found: " + partitionCount);
        }

        System.out.println("✓ Partitioned repository correctly retains all partitions when management is disabled");
    }

    @Test
    public void testMultiTableRepositoryWithDisabledManagement() throws Exception {
        System.out.println("Testing GenericMultiTableRepository with disabled partition management...");

        // Create repository with partition management disabled
        GenericMultiTableRepository<TestEvent, LocalDateTime> repository =
            GenericMultiTableRepository.<TestEvent, LocalDateTime>builder(TestEvent.class)
                .host("127.0.0.1")
                .port(3306)
                .database("testdb")
                .username("root")
                .password("123456")
                .tablePrefix("test_multi")
                .partitionRetentionPeriod(3)  // Only keep 3 days of tables
                .autoManagePartitions(false)  // DISABLE automatic management
                .build();

        // Create events spanning 10 days (beyond retention period)
        LocalDateTime now = LocalDateTime.now();
        for (int i = -7; i <= 2; i++) {
            TestEvent event = new TestEvent(
                UUID.randomUUID().toString(),
                now.plusDays(i),
                "Test data for day " + i
            );
            repository.insert(event);
        }

        // Verify that old tables are NOT dropped (because management is disabled)
        try (Statement stmt = connection.createStatement()) {
            ResultSet rs = stmt.executeQuery(
                "SELECT TABLE_NAME FROM information_schema.TABLES " +
                "WHERE TABLE_SCHEMA = 'testdb' AND TABLE_NAME LIKE 'test_multi_%' " +
                "ORDER BY TABLE_NAME"
            );

            int tableCount = 0;
            System.out.println("Existing tables:");
            while (rs.next()) {
                String tableName = rs.getString("TABLE_NAME");
                System.out.println("  - " + tableName);
                tableCount++;
            }

            // With autoManagePartitions=false and retentionDays=3,
            // we should still have ALL tables (10 days worth)
            assertTrue(tableCount >= 10,
                "All tables should be retained when autoManagePartitions=false, found: " + tableCount);
        }

        System.out.println("✓ Multi-table repository correctly retains all tables when management is disabled");
    }

    @Test
    public void testPartitionedRepositoryWithEnabledManagement() throws Exception {
        System.out.println("Testing GenericPartitionedTableRepository with enabled partition management...");

        // Create repository with partition management enabled (default)
        GenericPartitionedTableRepository<TestEvent, LocalDateTime> repository =
            GenericPartitionedTableRepository.<TestEvent, LocalDateTime>builder(TestEvent.class)
                .host("127.0.0.1")
                .port(3306)
                .database("testdb")
                .username("root")
                .password("123456")
                .tableName("test_events")
                .partitionRetentionPeriod(3)  // Only keep 3 days of data
                .autoManagePartitions(true)  // ENABLE automatic management (default)
                .build();

        // Create events spanning 10 days
        LocalDateTime now = LocalDateTime.now();
        for (int i = -7; i <= 2; i++) {
            TestEvent event = new TestEvent(
                UUID.randomUUID().toString(),
                now.plusDays(i),
                "Test data for day " + i
            );
            repository.insert(event);
        }

        // Verify that old partitions ARE dropped (because management is enabled)
        try (Statement stmt = connection.createStatement()) {
            ResultSet rs = stmt.executeQuery(
                "SELECT PARTITION_NAME FROM information_schema.PARTITIONS " +
                "WHERE TABLE_SCHEMA = 'testdb' AND TABLE_NAME = 'test_events' " +
                "ORDER BY PARTITION_NAME"
            );

            int partitionCount = 0;
            System.out.println("Existing partitions after automatic management:");
            while (rs.next()) {
                String partitionName = rs.getString("PARTITION_NAME");
                if (partitionName != null) {
                    System.out.println("  - " + partitionName);
                    partitionCount++;
                }
            }

            // With autoManagePartitions=true and retentionDays=3,
            // we should have roughly 6 partitions (3 past + 3 future)
            assertTrue(partitionCount <= 7,
                "Old partitions should be dropped when autoManagePartitions=true, found: " + partitionCount);
        }

        System.out.println("✓ Partitioned repository correctly manages partitions when management is enabled");
    }
}