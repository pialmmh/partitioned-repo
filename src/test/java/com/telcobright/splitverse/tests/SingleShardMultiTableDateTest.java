package com.telcobright.splitverse.tests;

import com.telcobright.core.repository.SplitVerseRepository;
import com.telcobright.splitverse.config.RepositoryMode;
import com.telcobright.splitverse.config.ShardConfig;
import com.telcobright.core.annotation.Table;
import com.telcobright.core.annotation.Id;
import com.telcobright.core.annotation.Column;
import com.telcobright.core.annotation.Index;
import com.telcobright.core.entity.ShardingEntity;
import org.junit.jupiter.api.*;
import java.sql.*;
import java.time.LocalDateTime;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;

/**
 * TEST GOALS:
 * - Validate MULTI_TABLE mode with date-based partitioning and nested partitions
 * - Test automatic table creation for different dates
 * - Verify tables are created with native partition for efficient searching
 */
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class SingleShardMultiTableDateTest {
    private static final String TEST_DB = "test_date_partition_" + System.currentTimeMillis();
    private static SplitVerseRepository<EventRecord, LocalDateTime> repository;

    @Table(name = "events")
    public static class EventRecord implements ShardingEntity<LocalDateTime> {
        @Id(autoGenerated = false)
        private String id;

        @com.telcobright.core.annotation.ShardingKey
        @Column(name = "event_time")
        @Index(name = "idx_event_time")
        private LocalDateTime eventTime;

        @Column(name = "data")
        private String data;

        public EventRecord() {}

        public EventRecord(String id, LocalDateTime eventTime, String data) {
            this.id = id;
            this.eventTime = eventTime;
            this.data = data;
        }

        @Override
        public String getId() { return id; }
        @Override
        public void setId(String id) { this.id = id; }
        @Override
        public LocalDateTime getPartitionColValue() { return eventTime; }
        @Override
        public void setPartitionColValue(LocalDateTime value) { this.eventTime = value; }

        public LocalDateTime getEventTime() { return eventTime; }
        public void setEventTime(LocalDateTime time) { this.eventTime = time; }
        public String getData() { return data; }
        public void setData(String data) { this.data = data; }
    }

    @BeforeAll
    static void setup() throws Exception {
        System.out.println("Setting up test database: " + TEST_DB);

        // Create test database
        try (Connection conn = DriverManager.getConnection(
                "jdbc:mysql://127.0.0.1:3306?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=UTC",
                "root", "123456");
             Statement stmt = conn.createStatement()) {
            stmt.execute("CREATE DATABASE IF NOT EXISTS " + TEST_DB);
        }

        // Configure repository with nested partitions
        ShardConfig shardConfig = ShardConfig.builder()
            .shardId("shard1")
            .database(TEST_DB)
            .host("127.0.0.1")
            .port(3306)
            .username("root")
            .password("123456")
            .enabled(true)
            .build();

        repository = SplitVerseRepository.<EventRecord, LocalDateTime>builder()
            .withSingleShard(shardConfig)
            .withEntityClass(EventRecord.class)
            .withRepositoryMode(RepositoryMode.MULTI_TABLE)
            .withNestedPartitions(true)
            .withNestedPartitionCount(24)  // 24 hourly partitions
            .withRetentionDays(3)
            .build();

        System.out.println("Repository configured with 24 hourly nested partitions");
    }

    @Test
    @Order(1)
    void testBasicInsertAndRetrieve() throws Exception {
        System.out.println("\nTest 1: Basic insert and retrieve");

        LocalDateTime now = LocalDateTime.now();
        EventRecord event = new EventRecord(
            UUID.randomUUID().toString(),
            now,
            "Test event"
        );

        repository.insert(event);
        System.out.println("Inserted event with ID: " + event.getId());

        EventRecord retrieved = repository.findById(event.getId());
        assertNotNull(retrieved, "Should find the event");
        assertEquals(event.getData(), retrieved.getData());
        System.out.println("Successfully retrieved event");
    }

    @Test
    @Order(2)
    void testMultipleDays() throws Exception {
        System.out.println("\nTest 2: Multiple days");

        LocalDateTime now = LocalDateTime.now();

        // Insert events for yesterday, today, and tomorrow
        for (int day = -1; day <= 1; day++) {
            EventRecord event = new EventRecord(
                "DAY_" + day,
                now.plusDays(day),
                "Event for day " + day
            );
            repository.insert(event);
            System.out.println("Inserted event for day " + day);
        }

        // Verify all events
        for (int day = -1; day <= 1; day++) {
            EventRecord found = repository.findById("DAY_" + day);
            assertNotNull(found, "Should find event for day " + day);
            assertEquals("Event for day " + day, found.getData());
        }
        System.out.println("All events verified across 3 days");
    }

    @AfterAll
    static void cleanup() throws Exception {
        // Keep database for inspection
        System.out.println("Keeping test database for inspection: " + TEST_DB);
    }
}