package com.telcobright.splitverse.tests;

import com.telcobright.core.repository.SplitVerseRepository;
import com.telcobright.splitverse.config.ShardConfig;
import com.telcobright.splitverse.config.RepositoryMode;
import com.telcobright.core.entity.ShardingEntity;
import com.telcobright.core.annotation.*;

import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;

/**
 * Comprehensive test for date-wise multi-table repository functionality.
 * Tests table creation, data insertion, querying across date ranges, and table management.
 */
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class DatewiseMultiTableTest {

    private static SplitVerseRepository<EventEntity, LocalDateTime> repository;
    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern("yyyyMMdd");
    private static final String TEST_DB = "test_multitable_" + System.currentTimeMillis();

    /**
     * Test entity representing events with timestamps
     */
    @Table(name = "event")
    public static class EventEntity implements ShardingEntity<LocalDateTime> {
        @Id(autoGenerated = false)
        @Column(name = "event_id")
        private String id;

        @Column(name = "event_name", nullable = false)
        private String eventName;

        @Column(name = "event_type")
        private String eventType;

        @ShardingKey
        @Column(name = "event_time", nullable = false)
        private LocalDateTime eventTime;

        @Column(name = "data")
        private String data;

        @Column(name = "status")
        private String status = "ACTIVE";

        // Constructors
        public EventEntity() {}

        public EventEntity(String eventName, String eventType, LocalDateTime eventTime, String data) {
            this.id = UUID.randomUUID().toString();
            this.eventName = eventName;
            this.eventType = eventType;
            this.eventTime = eventTime;
            this.data = data;
        }

        // ShardingEntity interface methods
        @Override
        public String getId() { return id; }

        @Override
        public void setId(String id) { this.id = id; }

        @Override
        public LocalDateTime getPartitionColValue() { return eventTime; }

        @Override
        public void setPartitionColValue(LocalDateTime value) { this.eventTime = value; }

        // Getters and setters
        public String getEventName() { return eventName; }
        public void setEventName(String eventName) { this.eventName = eventName; }

        public String getEventType() { return eventType; }
        public void setEventType(String eventType) { this.eventType = eventType; }

        public LocalDateTime getEventTime() { return eventTime; }
        public void setEventTime(LocalDateTime eventTime) { this.eventTime = eventTime; }

        public String getData() { return data; }
        public void setData(String data) { this.data = data; }

        public String getStatus() { return status; }
        public void setStatus(String status) { this.status = status; }
    }

    @BeforeAll
    static void setupRepository() throws Exception {
        System.out.println("\n=== Date-wise Multi-Table Repository Test ===");
        System.out.println("Creating test database: " + TEST_DB);

        // Create test database
        try (Connection conn = DriverManager.getConnection(
                "jdbc:mysql://127.0.0.1:3306", "root", "123456");
             Statement stmt = conn.createStatement()) {
            stmt.executeUpdate("CREATE DATABASE IF NOT EXISTS " + TEST_DB);
            System.out.println("✓ Database created");
        }

        // Configure shard
        ShardConfig shardConfig = ShardConfig.builder()
            .shardId("primary")
            .host("127.0.0.1")
            .port(3306)
            .database(TEST_DB)
            .username("root")
            .password("123456")
            .connectionPoolSize(10)
            .enabled(true)
            .build();

        // Create repository with MULTI_TABLE mode
        repository = SplitVerseRepository.<EventEntity, LocalDateTime>builder()
            .withSingleShard(shardConfig)
            .withEntityClass(EventEntity.class)
            .withRepositoryMode(RepositoryMode.MULTI_TABLE)
            .withRetentionDays(7)  // Keep tables for 7 days
            .build();

        System.out.println("✓ Repository initialized in MULTI_TABLE mode");
        System.out.println("  - Each day gets its own table: event_YYYYMMDD");
        System.out.println("  - Automatic table creation on insert");
        System.out.println("  - 7-day retention period\n");
    }

    @Test
    @Order(1)
    void testInsertEventsAcrossMultipleDays() throws Exception {
        System.out.println("\n1. Testing insert across multiple days:");

        LocalDateTime now = LocalDateTime.now();
        List<EventEntity> events = new ArrayList<>();

        // Create events for today
        events.add(new EventEntity("Login", "AUTH", now, "{\"user\":\"alice\"}"));
        events.add(new EventEntity("PageView", "TRACKING", now.minusHours(2), "{\"page\":\"/home\"}"));

        // Create events for yesterday
        events.add(new EventEntity("Purchase", "TRANSACTION", now.minusDays(1), "{\"amount\":99.99}"));
        events.add(new EventEntity("Logout", "AUTH", now.minusDays(1).minusHours(3), "{\"user\":\"bob\"}"));

        // Create events for 3 days ago
        events.add(new EventEntity("SignUp", "USER", now.minusDays(3), "{\"plan\":\"premium\"}"));
        events.add(new EventEntity("EmailSent", "NOTIFICATION", now.minusDays(3).plusHours(1), "{\"to\":\"user@example.com\"}"));

        // Insert all events
        for (EventEntity event : events) {
            repository.insert(event);
            System.out.printf("  ✓ Inserted: %s (%s) at %s\n",
                event.getEventName(),
                event.getEventType(),
                event.getEventTime().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm")));
        }

        System.out.println("\n  Total events inserted: " + events.size());

        // Verify tables were created
        verifyTablesExist(Arrays.asList(now, now.minusDays(1), now.minusDays(3)));
    }

    @Test
    @Order(2)
    void testQuerySingleDay() throws Exception {
        System.out.println("\n2. Testing query for single day:");

        LocalDateTime today = LocalDateTime.now();
        LocalDateTime startOfDay = today.toLocalDate().atStartOfDay();
        LocalDateTime endOfDay = startOfDay.plusDays(1).minusNanos(1);

        List<EventEntity> todayEvents = repository.findAllByPartitionRange(startOfDay, endOfDay);

        System.out.printf("  Found %d events for today (%s)\n",
            todayEvents.size(),
            today.format(DateTimeFormatter.ISO_LOCAL_DATE));

        for (EventEntity event : todayEvents) {
            System.out.printf("    - %s (%s) at %s\n",
                event.getEventName(),
                event.getEventType(),
                event.getEventTime().format(DateTimeFormatter.ofPattern("HH:mm:ss")));
        }

        assertTrue(todayEvents.size() >= 2, "Should have at least 2 events for today");
    }

    @Test
    @Order(3)
    void testQueryAcrossMultipleDays() throws Exception {
        System.out.println("\n3. Testing query across multiple days:");

        LocalDateTime now = LocalDateTime.now();
        LocalDateTime threeDaysAgo = now.minusDays(3);

        List<EventEntity> multiDayEvents = repository.findAllByPartitionRange(threeDaysAgo, now);

        System.out.printf("  Found %d events in last 3 days\n", multiDayEvents.size());

        // Group events by day
        Map<String, List<EventEntity>> eventsByDay = new HashMap<>();
        for (EventEntity event : multiDayEvents) {
            String day = event.getEventTime().format(DateTimeFormatter.ISO_LOCAL_DATE);
            eventsByDay.computeIfAbsent(day, k -> new ArrayList<>()).add(event);
        }

        System.out.println("  Events grouped by day:");
        for (Map.Entry<String, List<EventEntity>> entry : eventsByDay.entrySet()) {
            System.out.printf("    %s: %d events\n", entry.getKey(), entry.getValue().size());
        }

        assertTrue(multiDayEvents.size() >= 5, "Should have at least 5 events across 3 days");
        assertEquals(3, eventsByDay.size(), "Events should span 3 different days");
    }

    @Test
    @Order(4)
    void testUpdateEventAcrossTableBoundary() throws Exception {
        System.out.println("\n4. Testing update operation:");

        // Find an event from yesterday
        LocalDateTime yesterday = LocalDateTime.now().minusDays(1);
        LocalDateTime startOfYesterday = yesterday.toLocalDate().atStartOfDay();
        LocalDateTime endOfYesterday = startOfYesterday.plusDays(1).minusNanos(1);

        List<EventEntity> yesterdayEvents = repository.findAllByPartitionRange(startOfYesterday, endOfYesterday);
        assertFalse(yesterdayEvents.isEmpty(), "Should have events from yesterday");

        EventEntity eventToUpdate = yesterdayEvents.get(0);
        String originalName = eventToUpdate.getEventName();

        // Update the event
        eventToUpdate.setStatus("ARCHIVED");
        eventToUpdate.setData("{\"updated\":true}");
        repository.updateById(eventToUpdate.getId(), eventToUpdate);

        System.out.printf("  ✓ Updated event '%s' (ID: %s)\n", originalName, eventToUpdate.getId());

        // Verify update
        EventEntity updatedEvent = repository.findById(eventToUpdate.getId());
        assertNotNull(updatedEvent, "Should find updated event");
        assertEquals("ARCHIVED", updatedEvent.getStatus(), "Status should be updated");
        assertEquals("{\"updated\":true}", updatedEvent.getData(), "Data should be updated");

        System.out.println("  ✓ Update verified successfully");
    }

    @Test
    @Order(5)
    void testDeleteEvent() throws Exception {
        System.out.println("\n5. Testing delete operation:");

        // Create and insert a test event
        LocalDateTime twoDaysAgo = LocalDateTime.now().minusDays(2);
        EventEntity testEvent = new EventEntity("TestDelete", "TEST", twoDaysAgo, "{\"test\":true}");
        repository.insert(testEvent);
        System.out.printf("  Created test event with ID: %s\n", testEvent.getId());

        // Verify it exists
        EventEntity found = repository.findById(testEvent.getId());
        assertNotNull(found, "Event should exist before deletion");

        // Delete the event
        repository.deleteById(testEvent.getId());
        System.out.println("  ✓ Event deleted");

        // Verify deletion
        EventEntity afterDelete = repository.findById(testEvent.getId());
        assertNull(afterDelete, "Event should not exist after deletion");
        System.out.println("  ✓ Deletion verified");
    }

    @Test
    @Order(6)
    void testTableNamingConvention() throws Exception {
        System.out.println("\n6. Testing table naming convention:");

        LocalDateTime now = LocalDateTime.now();
        Set<String> expectedTables = new HashSet<>();

        // Calculate expected table names
        expectedTables.add("event_" + now.format(DATE_FORMAT));
        expectedTables.add("event_" + now.minusDays(1).format(DATE_FORMAT));
        expectedTables.add("event_" + now.minusDays(3).format(DATE_FORMAT));

        // Check actual tables in database
        try (Connection conn = DriverManager.getConnection(
                "jdbc:mysql://127.0.0.1:3306/" + TEST_DB, "root", "123456");
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery("SHOW TABLES LIKE 'event_%'")) {

            System.out.println("  Tables in database:");
            while (rs.next()) {
                String tableName = rs.getString(1);
                System.out.println("    - " + tableName);

                // Remove from expected set if found
                expectedTables.remove(tableName);
            }
        }

        assertTrue(expectedTables.isEmpty(), "All expected tables should exist: " + expectedTables);
        System.out.println("  ✓ All expected tables exist with correct naming");
    }

    @Test
    @Order(7)
    void testPerformanceWithManyTables() throws Exception {
        System.out.println("\n7. Testing performance with many events:");

        LocalDateTime now = LocalDateTime.now();
        int eventsPerDay = 100;
        int days = 3;

        long startTime = System.currentTimeMillis();

        // Insert many events across multiple days
        for (int day = 0; day < days; day++) {
            LocalDateTime eventTime = now.minusDays(day);
            List<EventEntity> batchEvents = new ArrayList<>();

            for (int i = 0; i < eventsPerDay; i++) {
                batchEvents.add(new EventEntity(
                    "Event_" + i,
                    "PERF_TEST",
                    eventTime.plusMinutes(i),
                    "{\"index\":" + i + "}"
                ));
            }

            repository.insertMultiple(batchEvents);
            System.out.printf("  Inserted %d events for day %d\n", eventsPerDay, day + 1);
        }

        long insertTime = System.currentTimeMillis() - startTime;
        System.out.printf("  Insert time: %d ms for %d events\n", insertTime, eventsPerDay * days);

        // Query performance test
        startTime = System.currentTimeMillis();
        List<EventEntity> allEvents = repository.findAllByPartitionRange(
            now.minusDays(days), now
        );
        long queryTime = System.currentTimeMillis() - startTime;

        System.out.printf("  Query time: %d ms for %d events\n", queryTime, allEvents.size());
        assertTrue(allEvents.size() >= eventsPerDay * days, "Should retrieve all inserted events");

        // Performance assertions
        assertTrue(insertTime < 10000, "Insert should complete within 10 seconds");
        assertTrue(queryTime < 2000, "Query should complete within 2 seconds");
    }

    // Helper method to verify tables exist
    private void verifyTablesExist(List<LocalDateTime> dates) throws Exception {
        System.out.println("\n  Verifying table creation:");

        try (Connection conn = DriverManager.getConnection(
                "jdbc:mysql://127.0.0.1:3306/" + TEST_DB, "root", "123456");
             Statement stmt = conn.createStatement()) {

            for (LocalDateTime date : dates) {
                String tableName = "event_" + date.format(DATE_FORMAT);
                ResultSet rs = stmt.executeQuery(
                    "SELECT COUNT(*) FROM information_schema.tables " +
                    "WHERE table_schema = '" + TEST_DB + "' " +
                    "AND table_name = '" + tableName + "'"
                );

                rs.next();
                boolean exists = rs.getInt(1) > 0;
                assertTrue(exists, "Table " + tableName + " should exist");
                System.out.println("    ✓ Table exists: " + tableName);
            }
        }
    }

    @AfterAll
    static void cleanup() throws Exception {
        System.out.println("\n=== Cleanup ===");

        if (repository != null) {
            repository.shutdown();
            System.out.println("✓ Repository shut down");
        }

        // Drop test database
        try (Connection conn = DriverManager.getConnection(
                "jdbc:mysql://127.0.0.1:3306", "root", "123456");
             Statement stmt = conn.createStatement()) {
            stmt.executeUpdate("DROP DATABASE IF EXISTS " + TEST_DB);
            System.out.println("✓ Test database dropped");
        }

        System.out.println("\n=== Date-wise Multi-Table Test Complete ===");
    }
}