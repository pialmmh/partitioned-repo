package com.telcobright.splitverse.tests;

import com.telcobright.api.ShardingRepository;
import com.telcobright.core.annotation.*;
import com.telcobright.core.entity.ShardingEntity;
import com.telcobright.core.enums.PartitionRange;
import com.telcobright.core.persistence.PersistenceProvider;
import com.telcobright.core.repository.SplitVerseRepository;
import com.telcobright.core.sql.SqlGeneratorByEntityRegistry;
import com.telcobright.core.sql.SqlStatementCache;
import com.telcobright.splitverse.config.RepositoryMode;
import com.telcobright.splitverse.config.ShardConfig;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;
import java.time.LocalDateTime;
import java.util.*;

import static org.junit.Assert.*;

/**
 * Test SQL pre-generation functionality
 */
public class SqlPregenerationTest {

    private static final String DB_HOST = "127.0.0.1";
    private static final int DB_PORT = 3306;
    private static final String DB_NAME = "test_splitverse_pregeneration";
    private static final String DB_USER = "root";
    private static final String DB_PASS = "123456";

    private ShardingRepository<TestEvent, LocalDateTime> repository;

    @Table(name = "test_events")
    public static class TestEvent implements ShardingEntity<LocalDateTime> {
        @Id(autoGenerated = false)
        @Column(name = "id")
        private String id;

        @ShardingKey
        @Column(name = "created_at")
        private LocalDateTime createdAt;

        @Column(name = "sequence_number")
        private Long sequenceNumber;

        @Column(name = "event_type")
        private String eventType;

        @Column(name = "payload")
        private String payload;

        public TestEvent() {
        }

        public TestEvent(String id, LocalDateTime createdAt, Long sequenceNumber, String eventType, String payload) {
            this.id = id;
            this.createdAt = createdAt;
            this.sequenceNumber = sequenceNumber;
            this.eventType = eventType;
            this.payload = payload;
        }

        @Override
        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        public LocalDateTime getCreatedAt() {
            return createdAt;
        }

        public void setCreatedAt(LocalDateTime createdAt) {
            this.createdAt = createdAt;
        }

        public Long getSequenceNumber() {
            return sequenceNumber;
        }

        public void setSequenceNumber(Long sequenceNumber) {
            this.sequenceNumber = sequenceNumber;
        }

        public String getEventType() {
            return eventType;
        }

        public void setEventType(String eventType) {
            this.eventType = eventType;
        }

        public String getPayload() {
            return payload;
        }

        public void setPayload(String payload) {
            this.payload = payload;
        }
    }

    @Before
    public void setUp() throws Exception {
        // Create database if it doesn't exist
        String createDbUrl = "jdbc:mysql://" + DB_HOST + ":" + DB_PORT +
            "?user=" + DB_USER + "&password=" + DB_PASS +
            "&useSSL=false&serverTimezone=UTC";

        try (Connection conn = DriverManager.getConnection(createDbUrl);
             Statement stmt = conn.createStatement()) {
            stmt.execute("CREATE DATABASE IF NOT EXISTS " + DB_NAME);
            System.out.println("[TEST] Database created/verified: " + DB_NAME);
        }

        // Clean up any existing tables
        String dbUrl = "jdbc:mysql://" + DB_HOST + ":" + DB_PORT + "/" + DB_NAME +
            "?user=" + DB_USER + "&password=" + DB_PASS +
            "&useSSL=false&serverTimezone=UTC";

        try (Connection conn = DriverManager.getConnection(dbUrl);
             Statement stmt = conn.createStatement()) {
            stmt.execute("DROP TABLE IF EXISTS test_events_0_9999");
            stmt.execute("DROP TABLE IF EXISTS test_events_10000_19999");
            stmt.execute("DROP TABLE IF EXISTS test_events_20000_29999");
            System.out.println("[TEST] Cleaned up existing tables");
        }
    }

    @After
    public void tearDown() {
        if (repository != null) {
            repository.shutdown();
        }
    }

    @Test
    public void testSqlPregenerationWithValueRange() throws Exception {
        System.out.println("\n=== Testing SQL Pre-generation with VALUE_RANGE_10K ===\n");

        // Create a shared SQL cache
        SqlStatementCache sqlCache = new SqlStatementCache();

        // Create repository with SQL pre-generation enabled
        ShardConfig shard = ShardConfig.builder()
            .shardId("shard-1")
            .host(DB_HOST)
            .port(DB_PORT)
            .database(DB_NAME)
            .username(DB_USER)
            .password(DB_PASS)
            .enabled(true)
            .build();

        repository = SplitVerseRepository.<TestEvent, LocalDateTime>builder()
            .withEntityClass(TestEvent.class)
            .withSingleShard(shard)
            .withRepositoryMode(RepositoryMode.MULTI_TABLE)
            .withTableName("test_events")
            .withPartitionRange(PartitionRange.VALUE_RANGE_10K)
            .withSqlPregeneration()  // Enable pre-generation
            .withDatabaseType(PersistenceProvider.DatabaseType.MYSQL)
            .withSqlCache(sqlCache)  // Use shared cache
            .build();

        // Verify cache statistics
        SqlStatementCache.CacheStatistics stats = sqlCache.getStatistics();
        System.out.println("[TEST] Cache statistics after pre-generation: " + stats);
        assertTrue("Cache should contain pre-generated statements", stats.totalStatements > 0);

        // Test with different batch sizes to verify cached SQL is used
        LocalDateTime now = LocalDateTime.now();

        // Test batch of 10 (should use cached SQL)
        List<TestEvent> batch10 = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            batch10.add(new TestEvent(
                UUID.randomUUID().toString(),
                now.minusDays(i),
                (long) (1000 + i),
                "TYPE_CACHED_10",
                "Testing cached SQL for batch of 10"
            ));
        }

        long startTime = System.currentTimeMillis();
        repository.insertMultiple(batch10);
        long time10 = System.currentTimeMillis() - startTime;
        System.out.println("[TEST] Inserted 10 events in " + time10 + "ms (using cached SQL)");

        // Test batch of 100 (should use cached SQL)
        List<TestEvent> batch100 = new ArrayList<>();
        for (int i = 0; i < 100; i++) {
            batch100.add(new TestEvent(
                UUID.randomUUID().toString(),
                now.minusDays(i % 30),
                (long) (2000 + i),
                "TYPE_CACHED_100",
                "Testing cached SQL for batch of 100"
            ));
        }

        startTime = System.currentTimeMillis();
        repository.insertMultiple(batch100);
        long time100 = System.currentTimeMillis() - startTime;
        System.out.println("[TEST] Inserted 100 events in " + time100 + "ms (using cached SQL)");

        // Test batch of 1000 (should use cached SQL)
        List<TestEvent> batch1000 = new ArrayList<>();
        for (int i = 0; i < 1000; i++) {
            batch1000.add(new TestEvent(
                UUID.randomUUID().toString(),
                now.minusDays(i % 60),
                (long) (10000 + i),
                "TYPE_CACHED_1000",
                "Testing cached SQL for batch of 1000"
            ));
        }

        startTime = System.currentTimeMillis();
        repository.insertMultiple(batch1000);
        long time1000 = System.currentTimeMillis() - startTime;
        System.out.println("[TEST] Inserted 1000 events in " + time1000 + "ms (using cached SQL)");

        // Test batch of 73 (non-standard size, should generate SQL at runtime)
        List<TestEvent> batch73 = new ArrayList<>();
        for (int i = 0; i < 73; i++) {
            batch73.add(new TestEvent(
                UUID.randomUUID().toString(),
                now.minusDays(i % 10),
                (long) (5000 + i),
                "TYPE_RUNTIME_73",
                "Testing runtime SQL generation for batch of 73"
            ));
        }

        startTime = System.currentTimeMillis();
        repository.insertMultiple(batch73);
        long time73 = System.currentTimeMillis() - startTime;
        System.out.println("[TEST] Inserted 73 events in " + time73 + "ms (runtime SQL generation)");

        // Verify data was inserted correctly
        List<TestEvent> retrieved = repository.findAllByDateRange(
            now.minusDays(60), now.plusDays(1)
        );

        System.out.println("[TEST] Retrieved " + retrieved.size() + " events");
        assertEquals("Should retrieve all inserted events", 1183, retrieved.size());

        // Final cache statistics
        stats = sqlCache.getStatistics();
        System.out.println("[TEST] Final cache statistics: " + stats);

        System.out.println("\n[TEST] SQL Pre-generation test completed successfully!");
    }

    @Test
    public void testSharedSqlRegistryAcrossRepositories() throws Exception {
        System.out.println("\n=== Testing Shared SQL Registry Across Multiple Repositories ===\n");

        // Create a shared registry and cache
        SqlGeneratorByEntityRegistry sharedRegistry = new SqlGeneratorByEntityRegistry();
        SqlStatementCache sharedCache = new SqlStatementCache();
        sharedRegistry.setCache(sharedCache);

        // Pre-generate SQL for TestEvent with different table patterns
        Map<Class<?>, List<String>> entityTableMap = new HashMap<>();
        List<String> tablePatterns = Arrays.asList(
            "test_events_0_9999",
            "test_events_10000_19999",
            "test_events_20000_29999"
        );
        entityTableMap.put(TestEvent.class, tablePatterns);

        System.out.println("[TEST] Pre-generating SQL for " + tablePatterns.size() + " table patterns...");
        sharedRegistry.pregenerateForTables(PersistenceProvider.DatabaseType.MYSQL, entityTableMap);

        // Verify pre-generation
        SqlStatementCache.CacheStatistics stats = sharedCache.getStatistics();
        System.out.println("[TEST] Cache statistics after pre-generation: " + stats);
        assertTrue("Cache should contain pre-generated statements", stats.totalStatements > 0);

        // Create first repository using the shared registry
        ShardConfig shard1 = ShardConfig.builder()
            .shardId("shard-1")
            .host(DB_HOST)
            .port(DB_PORT)
            .database(DB_NAME)
            .username(DB_USER)
            .password(DB_PASS)
            .enabled(true)
            .build();

        ShardingRepository<TestEvent, LocalDateTime> repository1 = SplitVerseRepository.<TestEvent, LocalDateTime>builder()
            .withEntityClass(TestEvent.class)
            .withSingleShard(shard1)
            .withRepositoryMode(RepositoryMode.MULTI_TABLE)
            .withTableName("test_events")
            .withPartitionRange(PartitionRange.VALUE_RANGE_10K)
            .withSqlRegistry(sharedRegistry)  // Use shared registry
            .withSqlCache(sharedCache)        // Use shared cache
            .build();

        // Insert data with first repository
        LocalDateTime now = LocalDateTime.now();
        List<TestEvent> events = new ArrayList<>();
        for (int i = 0; i < 100; i++) {
            events.add(new TestEvent(
                UUID.randomUUID().toString(),
                now.minusDays(i % 30),
                (long) (1000 + i),
                "SHARED_REGISTRY_TEST",
                "Testing shared registry"
            ));
        }

        long startTime = System.currentTimeMillis();
        repository1.insertMultiple(events);
        long insertTime = System.currentTimeMillis() - startTime;
        System.out.println("[TEST] Repository1: Inserted 100 events in " + insertTime + "ms using shared cache");

        // Verify the same cache is being used
        stats = sharedCache.getStatistics();
        System.out.println("[TEST] Shared cache statistics: " + stats);

        // Clean up
        repository1.shutdown();

        System.out.println("\n[TEST] Shared SQL registry test completed successfully!");
    }
}