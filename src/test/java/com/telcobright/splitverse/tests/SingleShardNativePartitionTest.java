package com.telcobright.splitverse.tests;

import com.telcobright.core.repository.SplitVerseRepository;
import com.telcobright.splitverse.config.ShardConfig;
import com.telcobright.splitverse.config.RepositoryMode;
import com.telcobright.core.entity.ShardingEntity;
import com.telcobright.core.annotation.*;
import com.telcobright.core.partition.PartitionType;

import org.junit.jupiter.api.*;
import static org.junit.jupiter.api.Assertions.*;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;
import java.sql.ResultSet;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;

/**
 * Comprehensive test for single-shard with native MySQL partitioning
 * This tests the SINGLE_TABLE mode with MySQL PARTITION BY RANGE
 */
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class SingleShardNativePartitionTest {

    private static SplitVerseRepository<CallRecord, LocalDateTime> repository;
    private static final String TEST_DB = "test_single_native_" + System.currentTimeMillis();
    private static final DateTimeFormatter DISPLAY_FORMAT = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

    @Table(name = "calls")
    public static class CallRecord implements ShardingEntity<LocalDateTime> {
        @Id(autoGenerated = false)
        @Column(name = "call_id")
        private String id;

        @Column(name = "call_type")
        private String callType;

        @ShardingKey
        @Column(name = "call_timestamp")
        private LocalDateTime callTimestamp;

        @Column(name = "caller_id")
        private String callerId;

        @Column(name = "duration")
        private Integer duration;

        @Column(name = "status")
        private String status;

        @Column(name = "description")
        private String description;

        public CallRecord() {}

        public CallRecord(String type, LocalDateTime timestamp, String callerId, Integer duration) {
            this.id = "CALL_" + System.nanoTime() + "_" + UUID.randomUUID().toString().substring(0, 8);
            this.callType = type;
            this.callTimestamp = timestamp;
            this.callerId = callerId;
            this.duration = duration;
            this.status = "ACTIVE";
            this.description = type + " call from " + callerId;
        }

        @Override
        public String getId() { return id; }
        @Override
        public void setId(String id) { this.id = id; }
        @Override
        public LocalDateTime getPartitionColValue() { return callTimestamp; }
        @Override
        public void setPartitionColValue(LocalDateTime value) { this.callTimestamp = value; }

        public String getCallType() { return callType; }
        public void setCallType(String callType) { this.callType = callType; }
        public LocalDateTime getCallTimestamp() { return callTimestamp; }
        public void setCallTimestamp(LocalDateTime callTimestamp) { this.callTimestamp = callTimestamp; }
        public String getCallerId() { return callerId; }
        public void setCallerId(String callerId) { this.callerId = callerId; }
        public Integer getDuration() { return duration; }
        public void setDuration(Integer duration) { this.duration = duration; }
        public String getStatus() { return status; }
        public void setStatus(String status) { this.status = status; }
        public String getDescription() { return description; }
        public void setDescription(String description) { this.description = description; }
    }

    @BeforeAll
    static void setup() throws Exception {
        System.out.println("\n=== Single-Shard Native Partition Test ===");
        System.out.println("Testing SINGLE_TABLE mode with MySQL native partitioning");

        // Create test database
        try (Connection conn = DriverManager.getConnection(
                "jdbc:mysql://127.0.0.1:3306", "root", "123456");
             Statement stmt = conn.createStatement()) {
            stmt.executeUpdate("CREATE DATABASE IF NOT EXISTS " + TEST_DB);
            System.out.println("Created test database: " + TEST_DB);
        }

        // Configure single shard with SINGLE_TABLE mode (native partitioning)
        ShardConfig shardConfig = ShardConfig.builder()
            .shardId("primary")
            .host("127.0.0.1")
            .port(3306)
            .database(TEST_DB)
            .username("root")
            .password("123456")
            .enabled(true)
            .build();

        repository = SplitVerseRepository.<CallRecord, LocalDateTime>builder()
            .withSingleShard(shardConfig)
            .withEntityClass(CallRecord.class)
            .withRepositoryMode(RepositoryMode.PARTITIONED)  // Native partition mode
            .withPartitionType(PartitionType.DATE_BASED)      // Date-based partitions
            .withRetentionDays(90)                             // Keep 90 days of partitions
            .build();

        System.out.println("Repository configured:");
        System.out.println("  - Mode: PARTITIONED (Native MySQL Partitioning)");
        System.out.println("  - Partition Type: DATE_BASED");
        System.out.println("  - Retention: 90 days");
        System.out.println("  - Single shard: " + TEST_DB);
    }

    @Test
    @Order(1)
    void testTableCreationWithPartitions() throws Exception {
        System.out.println("\n1. Testing native partitioned table creation:");

        // Check if table exists and has partitions
        try (Connection conn = DriverManager.getConnection(
                "jdbc:mysql://127.0.0.1:3306/" + TEST_DB, "root", "123456");
             Statement stmt = conn.createStatement()) {

            // Check table exists
            ResultSet rs = stmt.executeQuery(
                "SELECT COUNT(*) FROM information_schema.tables " +
                "WHERE table_schema = '" + TEST_DB + "' " +
                "AND table_name = 'calls'"
            );
            rs.next();
            assertEquals(1, rs.getInt(1), "Calls table should exist");

            // Check partitioning information
            rs = stmt.executeQuery(
                "SELECT partition_name, partition_expression, partition_description " +
                "FROM information_schema.partitions " +
                "WHERE table_schema = '" + TEST_DB + "' " +
                "AND table_name = 'calls' " +
                "AND partition_name IS NOT NULL " +
                "ORDER BY partition_ordinal_position"
            );

            int partitionCount = 0;
            System.out.println("  Partition details:");
            while (rs.next()) {
                partitionCount++;
                System.out.printf("    - %s: %s\n",
                    rs.getString("partition_name"),
                    rs.getString("partition_description"));
            }

            assertTrue(partitionCount > 0, "Table should have partitions");
            System.out.printf("  Total partitions: %d\n", partitionCount);
        }

        System.out.println("✓ Native partitioned table created successfully");
    }

    @Test
    @Order(2)
    void testInsertAcrossPartitions() throws Exception {
        System.out.println("\n2. Testing inserts across different partitions:");

        LocalDateTime now = LocalDateTime.now();
        Map<String, List<CallRecord>> callsByPeriod = new HashMap<>();

        // Insert calls across different time periods
        int[] daysAgo = {0, 1, 7, 30, 60, 89};
        for (int days : daysAgo) {
            LocalDateTime txnDate = now.minusDays(days);
            String periodKey = txnDate.format(DateTimeFormatter.ISO_LOCAL_DATE);
            List<CallRecord> periodTransactions = new ArrayList<>();

            for (int i = 0; i < 5; i++) {
                CallRecord txn = new CallRecord(
                    days == 0 ? "LOCAL" : "INTERNATIONAL",
                    txnDate.minusHours(i),
                    "CALLER_" + days,
                    60 * (days + 1) + i
                );
                repository.insert(txn);
                periodTransactions.add(txn);
            }

            callsByPeriod.put(periodKey, periodTransactions);
            System.out.printf("  Inserted 5 calls for %s (%d days ago)\n",
                periodKey, days);
        }

        // Verify all calls were inserted
        LocalDateTime rangeStart = now.minusDays(90);
        LocalDateTime rangeEnd = now.plusDays(1);
        List<CallRecord> allTransactions = repository.findAllByPartitionRange(rangeStart, rangeEnd);

        assertTrue(allTransactions.size() >= 30, "Should have at least 30 calls");
        System.out.printf("  Total calls inserted: %d\n", allTransactions.size());

        System.out.println("✓ Inserts across partitions working correctly");
    }

    @Test
    @Order(3)
    void testPartitionPruning() throws Exception {
        System.out.println("\n3. Testing partition pruning optimization:");

        LocalDateTime now = LocalDateTime.now();

        // Query specific date range (should use partition pruning)
        // Adjust for the minusHours offset used during insertion (up to 4 hours back)
        LocalDateTime weekAgo = now.minusDays(7).minusHours(5);  // Include all records from day 7
        LocalDateTime yesterday = now.minusDays(1).plusHours(1);  // Include all records from day 1

        long startTime = System.currentTimeMillis();
        List<CallRecord> weekTransactions = repository.findAllByPartitionRange(weekAgo, yesterday);
        long queryTime = System.currentTimeMillis() - startTime;

        System.out.printf("  Found %d calls in date range\n", weekTransactions.size());
        System.out.printf("  Query time: %d ms (partition pruning should optimize this)\n", queryTime);

        // Verify results are within date range
        for (CallRecord txn : weekTransactions) {
            assertTrue(!txn.getCallTimestamp().isBefore(weekAgo),
                "Transaction should not be before week ago");
            assertTrue(!txn.getCallTimestamp().isAfter(yesterday),
                "Transaction should not be after yesterday");
        }

        assertTrue(queryTime < 500, "Query should be fast due to partition pruning");
        System.out.println("✓ Partition pruning optimization working");
    }

    @Test
    @Order(4)
    void testUpdateWithinPartition() throws Exception {
        System.out.println("\n4. Testing updates within partitioned table:");

        LocalDateTime now = LocalDateTime.now();

        // Insert a transaction
        CallRecord txn = new CallRecord(
            "TRANSFER",
            now.minusDays(2),
            "CALLER_UPDATE",
            500
        );
        repository.insert(txn);
        System.out.printf("  Inserted transaction: %s\n", txn.getId());

        // Update the transaction
        txn.setStatus("COMPLETED");
        txn.setDescription("Updated transfer transaction");
        repository.updateById(txn.getId(), txn);
        System.out.println("  Updated transaction status and description");

        // Verify update
        CallRecord updated = repository.findById(txn.getId());
        assertNotNull(updated, "Should find updated transaction");
        assertEquals("COMPLETED", updated.getStatus());
        assertEquals("Updated transfer transaction", updated.getDescription());

        // Test update with partition range constraint
        LocalDateTime rangeStart = now.minusDays(3);
        LocalDateTime rangeEnd = now.minusDays(1);
        txn.setStatus("VERIFIED");
        repository.updateByIdAndPartitionColRange(txn.getId(), txn, rangeStart, rangeEnd);

        CallRecord verified = repository.findById(txn.getId());
        assertEquals("VERIFIED", verified.getStatus());

        System.out.println("✓ Updates within partitioned table working correctly");
    }

    @Test
    @Order(5)
    void testDeleteWithPartitioning() throws Exception {
        System.out.println("\n5. Testing deletes with partitioning:");

        LocalDateTime now = LocalDateTime.now();

        // Insert calls to delete
        List<CallRecord> toDelete = new ArrayList<>();
        for (int i = 0; i < 3; i++) {
            CallRecord txn = new CallRecord(
                "REFUND",
                now.minusDays(i * 10),
                "CALLER_DELETE_" + i,
                100 * i
            );
            repository.insert(txn);
            toDelete.add(txn);
        }
        System.out.printf("  Inserted %d calls to delete\n", toDelete.size());

        // Delete by ID (should work across partitions)
        repository.deleteById(toDelete.get(0).getId());
        assertNull(repository.findById(toDelete.get(0).getId()),
            "First transaction should be deleted");

        // Delete with partition range
        CallRecord secondTxn = toDelete.get(1);
        LocalDateTime rangeStart = secondTxn.getCallTimestamp().minusDays(1);
        LocalDateTime rangeEnd = secondTxn.getCallTimestamp().plusDays(1);
        repository.deleteByIdAndPartitionColRange(secondTxn.getId(), rangeStart, rangeEnd);
        assertNull(repository.findById(secondTxn.getId()),
            "Second transaction should be deleted with range");

        System.out.println("✓ Deletes with partitioning working correctly");
    }

    @Test
    @Order(6)
    void testPaginationOnPartitionedTable() throws Exception {
        System.out.println("\n6. Testing pagination on partitioned table:");

        // Insert sequential calls
        LocalDateTime now = LocalDateTime.now();
        List<String> allIds = new ArrayList<>();

        for (int day = 0; day < 5; day++) {
            for (int hour = 0; hour < 4; hour++) {
                CallRecord txn = new CallRecord(
                    "BATCH",
                    now.minusDays(day).minusHours(hour),
                    "CALLER_BATCH",
                    1000 + (day * 10) + hour
                );
                repository.insert(txn);
                allIds.add(txn.getId());
            }
        }
        Collections.sort(allIds);
        System.out.printf("  Inserted %d calls for pagination test\n", allIds.size());

        // Test pagination - find the starting point for our test data
        String startCursor = allIds.get(0);  // Use first ID from our test data
        String cursor = "";

        // Find a cursor just before our first test record
        List<CallRecord> beforeRecords = repository.findBatchByIdGreaterThan("", 1000);
        for (CallRecord rec : beforeRecords) {
            if (rec.getId().compareTo(startCursor) >= 0) {
                break;
            }
            cursor = rec.getId();
        }

        int totalFetched = 0;
        int pageCount = 0;
        int pageSize = 7;
        List<String> fetchedIds = new ArrayList<>();

        while (totalFetched < 20) {
            List<CallRecord> page = repository.findBatchByIdGreaterThan(cursor, pageSize);
            if (page.isEmpty()) break;

            pageCount++;

            // Only count records that are in our test set
            int countInPage = 0;
            for (CallRecord rec : page) {
                if (allIds.contains(rec.getId())) {
                    countInPage++;
                    fetchedIds.add(rec.getId());
                }
                cursor = rec.getId();  // Always update cursor to continue pagination
            }

            totalFetched += countInPage;
            System.out.printf("  Page %d: fetched %d records (test data: %d)\n", pageCount, page.size(), countInPage);

            // Verify ordering
            for (int i = 1; i < page.size(); i++) {
                assertTrue(page.get(i - 1).getId().compareTo(page.get(i).getId()) < 0,
                    "IDs should be in ascending order");
            }

            if (totalFetched >= 20) break;
        }

        assertEquals(20, fetchedIds.size(), "Should fetch exactly 20 records from our test set");
        System.out.println("✓ Pagination on partitioned table working correctly");
    }

    @Test
    @Order(7)
    void testPerformanceComparison() throws Exception {
        System.out.println("\n7. Testing performance with native partitioning:");

        LocalDateTime now = LocalDateTime.now();
        int recordCount = 100;

        // Measure bulk insert performance
        long startTime = System.currentTimeMillis();
        List<CallRecord> bulkTransactions = new ArrayList<>();

        for (int i = 0; i < recordCount; i++) {
            CallRecord txn = new CallRecord(
                "PERF_TEST",
                now.minusDays(i % 30),  // Spread across 30 days
                "CALLER_PERF_" + (i % 10),
                1000 + i
            );
            bulkTransactions.add(txn);
        }

        repository.insertMultiple(bulkTransactions);
        long insertTime = System.currentTimeMillis() - startTime;

        System.out.printf("  Inserted %d records in %d ms\n", recordCount, insertTime);
        assertTrue(insertTime < 5000, "Bulk insert should complete within 5 seconds");

        // Measure query performance with partition pruning
        startTime = System.currentTimeMillis();
        List<CallRecord> lastWeek = repository.findAllByPartitionRange(
            now.minusDays(7), now
        );
        long queryTime = System.currentTimeMillis() - startTime;

        System.out.printf("  Queried %d records from last week in %d ms\n",
            lastWeek.size(), queryTime);
        assertTrue(queryTime < 500, "Partition-pruned query should be fast");

        // Test finding specific record
        startTime = System.currentTimeMillis();
        CallRecord found = repository.findById(bulkTransactions.get(50).getId());
        long findTime = System.currentTimeMillis() - startTime;

        assertNotNull(found, "Should find specific transaction");
        System.out.printf("  Found specific record by ID in %d ms\n", findTime);
        assertTrue(findTime < 100, "Finding by ID should be very fast");

        System.out.println("✓ Performance with native partitioning is excellent");
    }

    @Test
    @Order(8)
    void testPartitionMaintenanceConfig() throws Exception {
        System.out.println("\n8. Testing partition maintenance configuration:");

        // Verify retention period is configured
        System.out.println("  Partition retention: 90 days (configured)");

        // In production, old partitions would be automatically dropped
        // based on the retention period configuration

        // Query to see partition information
        try (Connection conn = DriverManager.getConnection(
                "jdbc:mysql://127.0.0.1:3306/" + TEST_DB, "root", "123456");
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery(
                "SELECT COUNT(*) as partition_count " +
                "FROM information_schema.partitions " +
                "WHERE table_schema = '" + TEST_DB + "' " +
                "AND table_name = 'calls' " +
                "AND partition_name IS NOT NULL")) {

            rs.next();
            int partitionCount = rs.getInt("partition_count");
            System.out.printf("  Current partition count: %d\n", partitionCount);
            assertTrue(partitionCount > 0, "Should have active partitions");
        }

        System.out.println("✓ Partition maintenance configured correctly");
    }

    @AfterAll
    static void cleanup() throws Exception {
        System.out.println("\n=== Cleanup ===");

        if (repository != null) {
            repository.shutdown();
            System.out.println("Repository shut down");
        }

        // Drop test database
        try (Connection conn = DriverManager.getConnection(
                "jdbc:mysql://127.0.0.1:3306", "root", "123456");
             Statement stmt = conn.createStatement()) {
            stmt.executeUpdate("DROP DATABASE IF EXISTS " + TEST_DB);
            System.out.println("Test database dropped: " + TEST_DB);
        }

        System.out.println("✓ Cleanup complete");
    }
}